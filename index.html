<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Run - Bullet Hell Shooter</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        #settingsBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #settingsBtn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        #settingsPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #4488ff;
            border-radius: 15px;
            padding: 25px;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            z-index: 200;
            display: none;
            min-width: 300px;
            max-width: 90%;
            box-shadow: 0 0 30px rgba(68, 136, 255, 0.5);
        }

        #settingsPanel h2 {
            text-align: center;
            margin-bottom: 20px;
            color: #4488ff;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .setting-group {
            margin-bottom: 15px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #aaccff;
        }

        .setting-group input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: #223355;
            border-radius: 4px;
            outline: none;
        }

        .setting-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #4488ff;
            border-radius: 50%;
            cursor: pointer;
        }

        .setting-value {
            text-align: right;
            font-size: 12px;
            color: #88aadd;
            margin-top: 3px;
        }

        #closeSettings {
            width: 100%;
            padding: 12px;
            margin-top: 15px;
            background: #4488ff;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #closeSettings:hover {
            background: #5599ff;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 16px;
            z-index: 50;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
        }

        #hud div {
            margin-bottom: 5px;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #ff4444;
            border-radius: 15px;
            padding: 30px 50px;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            z-index: 150;
            display: none;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 68, 68, 0.5);
        }

        #gameOver h2 {
            color: #ff4444;
            font-size: 32px;
            margin-bottom: 15px;
        }

        #gameOver p {
            font-size: 18px;
            margin-bottom: 20px;
        }

        #restartBtn {
            padding: 12px 30px;
            background: #ff4444;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            text-transform: uppercase;
        }

        #restartBtn:hover {
            background: #ff5555;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #0a0a20 0%, #1a1a40 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            z-index: 300;
            font-family: 'Segoe UI', Arial, sans-serif;
            color: white;
            padding-top: 20px;
            overflow-y: auto;
        }

        #startScreen h1 {
            font-size: 36px;
            color: #4488ff;
            text-shadow: 0 0 20px rgba(68, 136, 255, 0.8);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        #startScreen p {
            font-size: 14px;
            color: #aaccff;
            margin-bottom: 15px;
            text-align: center;
            max-width: 80%;
            line-height: 1.4;
        }

        #modelGrid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            padding: 10px;
            max-width: 100%;
            width: 100%;
        }

        .model-card {
            background: rgba(30, 30, 60, 0.8);
            border: 1px solid #334;
            border-radius: 8px;
            padding: 5px;
            text-align: center;
        }

        .model-card canvas {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 4px;
            background: #111;
        }

        .model-card .model-name {
            font-size: 11px;
            color: #88aadd;
            margin-top: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #startBtn {
            padding: 15px 50px;
            background: #4488ff;
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 20px rgba(68, 136, 255, 0.5);
            margin: 20px 0;
        }

        #startBtn:hover {
            background: #5599ff;
            box-shadow: 0 0 30px rgba(68, 136, 255, 0.8);
        }

        #loadingText {
            color: #4488ff;
            font-size: 18px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>

    <div id="startScreen">
        <h1>Space Run</h1>
        <p>Drag to move ship. Up to advance, down to retreat.<br>Weapons fire automatically!</p>
        <div id="loadingText">Loading models...</div>
        <div id="modelGrid"></div>
        <button id="startBtn" style="display: none;">Start Game</button>
    </div>

    <button id="settingsBtn" style="display: none;">âš™</button>

    <div id="settingsPanel">
        <h2>Settings</h2>
        <div class="setting-group">
            <label>X Sensitivity (Horizontal)</label>
            <input type="range" id="xSensitivity" min="0.5" max="3" step="0.1" value="1.5">
            <div class="setting-value" id="xSensitivityValue">1.5</div>
        </div>
        <div class="setting-group">
            <label>Y Sensitivity (Vertical)</label>
            <input type="range" id="ySensitivity" min="0.5" max="3" step="0.1" value="1.2">
            <div class="setting-value" id="ySensitivityValue">1.2</div>
        </div>
        <div class="setting-group">
            <label>Max Ship Height (% of screen)</label>
            <input type="range" id="maxHeight" min="30" max="70" step="5" value="50">
            <div class="setting-value" id="maxHeightValue">50%</div>
        </div>
        <div class="setting-group">
            <label>Ship Speed</label>
            <input type="range" id="shipSpeed" min="0.5" max="2" step="0.1" value="1">
            <div class="setting-value" id="shipSpeedValue">1.0x</div>
        </div>
        <div class="setting-group">
            <label>Fire Rate</label>
            <input type="range" id="fireRate" min="0.5" max="3" step="0.1" value="1">
            <div class="setting-value" id="fireRateValue">1.0x</div>
        </div>
        <div class="setting-group">
            <label>Scroll Speed</label>
            <input type="range" id="scrollSpeed" min="0.5" max="2" step="0.1" value="1">
            <div class="setting-value" id="scrollSpeedValue">1.0x</div>
        </div>
        <button id="closeSettings">Close</button>
    </div>

    <div id="hud" style="display: none;">
        <div>Score: <span id="score">0</span></div>
        <div>Health: <span id="health">100</span></div>
        <div>Wave: <span id="wave">1</span></div>
    </div>

    <div id="gameOver">
        <h2>Game Over</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button id="restartBtn">Play Again</button>
    </div>

    <script>
        // Ship model names
        const shipNames = ['Bob', 'Challenger', 'Dispatcher', 'Executioner', 'Imperial',
                          'Insurgent', 'Omen', 'Pancake', 'Spitfire', 'Striker', 'Zenith'];
        const colorVariants = ['Blue', 'Green', 'Orange', 'Purple', 'Red'];

        // Game Settings
        const settings = {
            xSensitivity: 1.5,
            ySensitivity: 1.2,
            maxHeight: 0.5,
            shipSpeed: 1.0,
            fireRate: 1.0,
            scrollSpeed: 1.0,
            playerShip: 'Bob',
            playerColor: 'Blue',
            enemyShip: 'Spitfire',
            enemyColor: 'Red'
        };

        // Loaded model templates
        const modelTemplates = {};
        const previewScenes = [];

        // Game State
        let gameState = {
            score: 0,
            health: 100,
            wave: 1,
            isPlaying: false,
            isPaused: false,
            enemies: [],
            playerBullets: [],
            enemyBullets: [],
            stars: [],
            lastFireTime: 0,
            waveTimer: 0,
            enemiesInWave: 0,
            enemiesSpawned: 0
        };

        // Main game canvas and engine
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true);

        // Game dimensions
        let gameWidth, gameHeight, orthoHeight = 10, orthoWidth;

        function updateGameDimensions() {
            gameWidth = engine.getRenderWidth();
            gameHeight = engine.getRenderHeight();
            const aspect = gameWidth / gameHeight;
            orthoWidth = orthoHeight * aspect;
        }

        // Create preview cards for each ship
        async function createModelPreviews() {
            const modelGrid = document.getElementById('modelGrid');
            const loadingText = document.getElementById('loadingText');

            let loadedCount = 0;
            const totalModels = shipNames.length;

            for (const shipName of shipNames) {
                // Create card element
                const card = document.createElement('div');
                card.className = 'model-card';

                const previewCanvas = document.createElement('canvas');
                previewCanvas.id = `preview-${shipName}`;
                card.appendChild(previewCanvas);

                const nameLabel = document.createElement('div');
                nameLabel.className = 'model-name';
                nameLabel.textContent = shipName;
                card.appendChild(nameLabel);

                modelGrid.appendChild(card);

                // Create preview scene
                const previewEngine = new BABYLON.Engine(previewCanvas, true);
                const previewScene = new BABYLON.Scene(previewEngine);
                previewScene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.15, 1);

                // Camera for preview
                const camera = new BABYLON.ArcRotateCamera('camera', 0, Math.PI / 3, 5, BABYLON.Vector3.Zero(), previewScene);

                // Lighting
                const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), previewScene);
                light.intensity = 1.0;
                const light2 = new BABYLON.DirectionalLight('light2', new BABYLON.Vector3(1, -1, 1), previewScene);
                light2.intensity = 0.5;

                try {
                    // Load the model
                    const basePath = `assets/Ultimate Spaceships/${shipName}/`;
                    const result = await BABYLON.SceneLoader.ImportMeshAsync('', basePath + 'glTF/', `${shipName}.gltf`, previewScene);

                    // Get the root mesh
                    const rootMesh = result.meshes[0];

                    // Load and apply texture
                    const texturePath = `${basePath}Textures/${shipName}_Blue.png`;
                    const texture = new BABYLON.Texture(texturePath, previewScene);

                    result.meshes.forEach(mesh => {
                        if (mesh.material) {
                            mesh.material.dispose();
                        }
                        const mat = new BABYLON.StandardMaterial(`${shipName}Mat`, previewScene);
                        mat.diffuseTexture = texture;
                        mat.emissiveTexture = texture;
                        mat.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                        mat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                        mesh.material = mat;
                    });

                    // Center and scale the model
                    const boundingInfo = rootMesh.getHierarchyBoundingVectors(true);
                    const size = boundingInfo.max.subtract(boundingInfo.min);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 2 / maxDim;
                    rootMesh.scaling = new BABYLON.Vector3(scale, scale, scale);

                    // Center it
                    const center = boundingInfo.min.add(boundingInfo.max).scale(0.5 * scale);
                    rootMesh.position = center.negate();

                    // Store rotation reference
                    previewScene.shipMesh = rootMesh;

                    // Store template info for game use
                    modelTemplates[shipName] = {
                        path: basePath,
                        scale: scale
                    };

                } catch (e) {
                    console.error(`Failed to load ${shipName}:`, e);
                    // Create placeholder
                    const placeholder = BABYLON.MeshBuilder.CreateBox('placeholder', {size: 1}, previewScene);
                    const mat = new BABYLON.StandardMaterial('placeholderMat', previewScene);
                    mat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                    placeholder.material = mat;
                    previewScene.shipMesh = placeholder;
                }

                // Render loop for this preview
                previewEngine.runRenderLoop(() => {
                    if (previewScene.shipMesh) {
                        previewScene.shipMesh.rotation.y += 0.02;
                    }
                    previewScene.render();
                });

                previewScenes.push({ engine: previewEngine, scene: previewScene });

                loadedCount++;
                loadingText.textContent = `Loading models... ${loadedCount}/${totalModels}`;
            }

            loadingText.style.display = 'none';
            document.getElementById('startBtn').style.display = 'block';
        }

        // Main game scene
        let scene, playerShip, playerShipMesh;
        let materials = {};

        function createMainScene() {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.02, 0.02, 0.08, 1);

            // Orthographic camera for 2D gameplay
            const camera = new BABYLON.FreeCamera('camera', new BABYLON.Vector3(0, 0, -10), scene);
            camera.setTarget(new BABYLON.Vector3(0, 0, 0));
            camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;

            function updateCamera() {
                updateGameDimensions();
                const aspect = gameWidth / gameHeight;
                camera.orthoTop = orthoHeight;
                camera.orthoBottom = -orthoHeight;
                camera.orthoLeft = -orthoHeight * aspect;
                camera.orthoRight = orthoHeight * aspect;
            }
            updateCamera();
            window.addEventListener('resize', updateCamera);

            // Lighting
            const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, -1), scene);
            light.intensity = 1.0;
            const light2 = new BABYLON.DirectionalLight('light2', new BABYLON.Vector3(0, 0, -1), scene);
            light2.intensity = 0.8;

            // Create materials
            materials.playerBullet = new BABYLON.StandardMaterial('playerBulletMat', scene);
            materials.playerBullet.emissiveColor = new BABYLON.Color3(0, 1, 0.5);

            materials.enemyBullet = new BABYLON.StandardMaterial('enemyBulletMat', scene);
            materials.enemyBullet.emissiveColor = new BABYLON.Color3(1, 0.5, 0);

            return scene;
        }

        // Load a ship model for gameplay
        async function loadShipModel(shipName, colorVariant, targetScene) {
            const basePath = `assets/Ultimate Spaceships/${shipName}/`;

            try {
                const result = await BABYLON.SceneLoader.ImportMeshAsync('', basePath + 'glTF/', `${shipName}.gltf`, targetScene);
                const rootMesh = result.meshes[0];

                // Load texture
                const texturePath = `${basePath}Textures/${shipName}_${colorVariant}.png`;
                const texture = new BABYLON.Texture(texturePath, targetScene);

                result.meshes.forEach(mesh => {
                    if (mesh.material) {
                        mesh.material.dispose();
                    }
                    const mat = new BABYLON.StandardMaterial(`${shipName}${colorVariant}Mat`, targetScene);
                    mat.diffuseTexture = texture;
                    mat.emissiveTexture = texture;
                    mat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                    mesh.material = mat;
                });

                // Scale appropriately for the game
                const boundingInfo = rootMesh.getHierarchyBoundingVectors(true);
                const size = boundingInfo.max.subtract(boundingInfo.min);
                const maxDim = Math.max(size.x, size.y, size.z);
                const gameScale = 1.5 / maxDim;
                rootMesh.scaling = new BABYLON.Vector3(gameScale, gameScale, gameScale);

                // Rotate to face upward (toward +Y in our 2D view)
                rootMesh.rotation.x = Math.PI / 2;

                return rootMesh;
            } catch (e) {
                console.error(`Failed to load ship ${shipName}:`, e);
                // Return a placeholder
                const placeholder = BABYLON.MeshBuilder.CreateBox('placeholder', {width: 0.8, height: 1.2, depth: 0.3}, targetScene);
                const mat = new BABYLON.StandardMaterial('placeholderMat', targetScene);
                mat.diffuseColor = colorVariant === 'Blue' ? new BABYLON.Color3(0.2, 0.4, 1) : new BABYLON.Color3(1, 0.2, 0.2);
                mat.emissiveColor = mat.diffuseColor.scale(0.3);
                placeholder.material = mat;
                return placeholder;
            }
        }

        // Create player ship
        async function createPlayerShip() {
            playerShip = new BABYLON.TransformNode('playerShip', scene);

            playerShipMesh = await loadShipModel(settings.playerShip, settings.playerColor, scene);
            playerShipMesh.parent = playerShip;

            playerShip.position = new BABYLON.Vector3(0, -7, 0);
            playerShip.targetX = 0;
            playerShip.targetY = -7;

            return playerShip;
        }

        // Create stars
        function createStars(count = 150) {
            updateGameDimensions();

            for (let i = 0; i < count; i++) {
                const size = Math.random() * 0.08 + 0.02;
                const star = BABYLON.MeshBuilder.CreateSphere('star' + i, { diameter: size }, scene);

                star.position.x = (Math.random() - 0.5) * orthoWidth * 2.5;
                star.position.y = (Math.random() - 0.5) * orthoHeight * 2.5;
                star.position.z = 1 + Math.random() * 2;

                const starMat = new BABYLON.StandardMaterial('starMat' + i, scene);
                const brightness = Math.random() * 0.5 + 0.5;
                starMat.emissiveColor = new BABYLON.Color3(brightness, brightness, brightness * 0.9);
                star.material = starMat;

                star.speed = (Math.random() * 0.3 + 0.1) * (0.5 + size * 5);
                gameState.stars.push(star);
            }
        }

        // Create enemy
        async function createEnemy(type = 'basic', x, y) {
            const enemy = new BABYLON.TransformNode('enemy', scene);

            // Load the enemy ship model
            const enemyMesh = await loadShipModel(settings.enemyShip, settings.enemyColor, scene);
            enemyMesh.parent = enemy;

            // Rotate to face downward (toward player)
            enemyMesh.rotation.x = -Math.PI / 2;

            enemy.position.x = x;
            enemy.position.y = y;
            enemy.position.z = 0;
            enemy.type = type;
            enemy.health = type === 'shooter' ? 3 : type === 'fast' ? 1 : 2;
            enemy.speed = type === 'fast' ? 0.08 : 0.03;
            enemy.lastFireTime = 0;
            enemy.fireRate = type === 'shooter' ? 1500 : 3000;
            enemy.movementPattern = Math.random() > 0.5 ? 'sine' : 'straight';
            enemy.startX = x;
            enemy.time = Math.random() * Math.PI * 2;
            enemy.mesh = enemyMesh;

            return enemy;
        }

        // Create bullet
        function createBullet(isPlayer, x, y, velocityX = 0, velocityY = 0.2) {
            const bullet = BABYLON.MeshBuilder.CreateSphere('bullet', {
                diameter: isPlayer ? 0.15 : 0.12
            }, scene);

            bullet.position.x = x;
            bullet.position.y = y;
            bullet.position.z = 0;
            bullet.material = isPlayer ? materials.playerBullet : materials.enemyBullet;
            bullet.velocityX = velocityX;
            bullet.velocityY = velocityY;
            bullet.isPlayer = isPlayer;

            return bullet;
        }

        // Input handling
        let inputState = {
            isPressed: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0
        };

        function handleInputStart(x, y) {
            inputState.isPressed = true;
            inputState.startX = x;
            inputState.startY = y;
            inputState.currentX = x;
            inputState.currentY = y;
        }

        function handleInputMove(x, y) {
            if (inputState.isPressed) {
                inputState.currentX = x;
                inputState.currentY = y;
            }
        }

        function handleInputEnd() {
            inputState.isPressed = false;
        }

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handleInputStart(touch.clientX, touch.clientY);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handleInputMove(touch.clientX, touch.clientY);
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleInputEnd();
        }, { passive: false });

        canvas.addEventListener('mousedown', (e) => {
            handleInputStart(e.clientX, e.clientY);
        });

        canvas.addEventListener('mousemove', (e) => {
            handleInputMove(e.clientX, e.clientY);
        });

        canvas.addEventListener('mouseup', () => {
            handleInputEnd();
        });

        canvas.addEventListener('mouseleave', () => {
            handleInputEnd();
        });

        // Update player position
        function updatePlayerPosition(deltaTime) {
            if (!inputState.isPressed || !playerShip) return 0.3;

            const deltaX = (inputState.currentX - inputState.startX) * settings.xSensitivity;
            const deltaY = (inputState.currentY - inputState.startY) * settings.ySensitivity;

            inputState.startX = inputState.currentX;
            inputState.startY = inputState.currentY;

            const worldDeltaX = (deltaX / gameWidth) * orthoWidth * 2;
            const worldDeltaY = -(deltaY / gameHeight) * orthoHeight * 2;

            playerShip.targetX += worldDeltaX;
            playerShip.targetY += worldDeltaY;

            const maxX = orthoWidth - 1;
            playerShip.targetX = Math.max(-maxX, Math.min(maxX, playerShip.targetX));

            const minY = -orthoHeight + 1;
            const maxY = -orthoHeight + (orthoHeight * 2 * settings.maxHeight);
            playerShip.targetY = Math.max(minY, Math.min(maxY, playerShip.targetY));

            const lerpFactor = 0.15 * settings.shipSpeed;
            playerShip.position.x += (playerShip.targetX - playerShip.position.x) * lerpFactor;
            playerShip.position.y += (playerShip.targetY - playerShip.position.y) * lerpFactor;

            const normalizedY = (playerShip.position.y + orthoHeight) / (orthoHeight * 2);
            return Math.max(0.1, normalizedY + 0.2);
        }

        // Fire weapons
        function firePlayerWeapons(currentTime) {
            if (!playerShip) return;

            const fireInterval = 150 / settings.fireRate;

            if (currentTime - gameState.lastFireTime > fireInterval && gameState.enemies.length > 0) {
                const bullet1 = createBullet(true, playerShip.position.x, playerShip.position.y + 0.5, 0, 0.3);
                gameState.playerBullets.push(bullet1);

                const bullet2 = createBullet(true, playerShip.position.x - 0.3, playerShip.position.y + 0.3, -0.02, 0.28);
                const bullet3 = createBullet(true, playerShip.position.x + 0.3, playerShip.position.y + 0.3, 0.02, 0.28);
                gameState.playerBullets.push(bullet2, bullet3);

                gameState.lastFireTime = currentTime;
            }
        }

        // Spawn wave
        function spawnWave() {
            const waveConfig = {
                1: { count: 5 },
                2: { count: 7 },
                3: { count: 8 },
                4: { count: 10 },
                5: { count: 12 }
            };

            const config = waveConfig[Math.min(gameState.wave, 5)] || waveConfig[5];
            gameState.enemiesInWave = config.count + Math.floor(Math.max(0, gameState.wave - 5) * 2);
            gameState.enemiesSpawned = 0;
        }

        // Spawn enemy
        async function spawnEnemy() {
            if (gameState.enemiesSpawned >= gameState.enemiesInWave) return;

            const types = ['basic', 'basic', 'fast', 'shooter'];
            const type = types[Math.floor(Math.random() * Math.min(types.length, 1 + gameState.wave))];

            const maxX = orthoWidth - 1;
            const x = (Math.random() - 0.5) * maxX * 1.5;
            const y = orthoHeight + 2;

            const enemy = await createEnemy(type, x, y);
            gameState.enemies.push(enemy);
            gameState.enemiesSpawned++;
        }

        // Update enemies
        function updateEnemies(deltaTime, currentTime, scrollMultiplier) {
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];

                enemy.time += deltaTime * 0.003;

                if (enemy.movementPattern === 'sine') {
                    enemy.position.x = enemy.startX + Math.sin(enemy.time) * 2;
                }

                enemy.position.y -= enemy.speed * settings.scrollSpeed * (0.5 + scrollMultiplier);

                if ((enemy.type === 'shooter' || enemy.type === 'basic') &&
                    currentTime - enemy.lastFireTime > enemy.fireRate && playerShip) {

                    const dx = playerShip.position.x - enemy.position.x;
                    const dy = playerShip.position.y - enemy.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 0) {
                        const bullet = createBullet(false, enemy.position.x, enemy.position.y - 0.3,
                            (dx / dist) * 0.1, (dy / dist) * 0.1);
                        gameState.enemyBullets.push(bullet);
                    }

                    enemy.lastFireTime = currentTime;
                }

                if (enemy.position.y < -orthoHeight - 2) {
                    enemy.getChildMeshes().forEach(m => m.dispose());
                    enemy.dispose();
                    gameState.enemies.splice(i, 1);
                }
            }
        }

        // Update bullets
        function updateBullets() {
            for (let i = gameState.playerBullets.length - 1; i >= 0; i--) {
                const bullet = gameState.playerBullets[i];
                bullet.position.x += bullet.velocityX;
                bullet.position.y += bullet.velocityY;

                let bulletHit = false;
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    const dx = bullet.position.x - enemy.position.x;
                    const dy = bullet.position.y - enemy.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 0.5) {
                        enemy.health--;
                        bullet.dispose();
                        gameState.playerBullets.splice(i, 1);
                        bulletHit = true;

                        if (enemy.health <= 0) {
                            const points = enemy.type === 'shooter' ? 30 : enemy.type === 'fast' ? 20 : 10;
                            gameState.score += points * gameState.wave;
                            updateHUD();

                            enemy.getChildMeshes().forEach(m => m.dispose());
                            enemy.dispose();
                            gameState.enemies.splice(j, 1);
                        }
                        break;
                    }
                }

                if (!bulletHit && bullet.position.y > orthoHeight + 2) {
                    bullet.dispose();
                    gameState.playerBullets.splice(i, 1);
                }
            }

            for (let i = gameState.enemyBullets.length - 1; i >= 0; i--) {
                const bullet = gameState.enemyBullets[i];
                bullet.position.x += bullet.velocityX;
                bullet.position.y += bullet.velocityY;

                if (playerShip) {
                    const dx = bullet.position.x - playerShip.position.x;
                    const dy = bullet.position.y - playerShip.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 0.5) {
                        gameState.health -= 10;
                        updateHUD();
                        bullet.dispose();
                        gameState.enemyBullets.splice(i, 1);

                        if (gameState.health <= 0) {
                            gameOver();
                        }
                        continue;
                    }
                }

                if (bullet.position.y < -orthoHeight - 2 || bullet.position.y > orthoHeight + 2 ||
                    bullet.position.x < -orthoWidth - 2 || bullet.position.x > orthoWidth + 2) {
                    bullet.dispose();
                    gameState.enemyBullets.splice(i, 1);
                }
            }
        }

        // Update stars
        function updateStars(scrollMultiplier) {
            const baseSpeed = 0.05 * settings.scrollSpeed;
            const adjustedSpeed = baseSpeed * (0.5 + scrollMultiplier);

            gameState.stars.forEach(star => {
                star.position.y -= star.speed * adjustedSpeed;

                if (star.position.y < -orthoHeight - 5) {
                    star.position.y = orthoHeight + 5;
                    star.position.x = (Math.random() - 0.5) * orthoWidth * 2.5;
                }
            });
        }

        // Check collisions
        function checkPlayerCollision() {
            if (!playerShip) return;

            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                const dx = playerShip.position.x - enemy.position.x;
                const dy = playerShip.position.y - enemy.position.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 0.7) {
                    gameState.health -= 25;
                    updateHUD();

                    enemy.getChildMeshes().forEach(m => m.dispose());
                    enemy.dispose();
                    gameState.enemies.splice(i, 1);

                    if (gameState.health <= 0) {
                        gameOver();
                    }
                }
            }
        }

        // Update HUD
        function updateHUD() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('health').textContent = Math.max(0, gameState.health);
            document.getElementById('wave').textContent = gameState.wave;
        }

        // Game over
        function gameOver() {
            gameState.isPlaying = false;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOver').style.display = 'block';
        }

        // Reset game
        async function resetGame() {
            gameState.enemies.forEach(enemy => {
                enemy.getChildMeshes().forEach(m => m.dispose());
                enemy.dispose();
            });
            gameState.enemies = [];

            gameState.playerBullets.forEach(b => b.dispose());
            gameState.playerBullets = [];
            gameState.enemyBullets.forEach(b => b.dispose());
            gameState.enemyBullets = [];

            gameState.score = 0;
            gameState.health = 100;
            gameState.wave = 1;
            gameState.lastFireTime = 0;
            gameState.waveTimer = 0;
            gameState.enemiesInWave = 0;
            gameState.enemiesSpawned = 0;

            if (playerShip) {
                playerShip.position.x = 0;
                playerShip.position.y = -7;
                playerShip.targetX = 0;
                playerShip.targetY = -7;
            }

            updateHUD();
            spawnWave();
        }

        // Settings UI
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsPanel = document.getElementById('settingsPanel');
        const closeSettings = document.getElementById('closeSettings');

        settingsBtn.addEventListener('click', () => {
            settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
            gameState.isPaused = settingsPanel.style.display === 'block';
        });

        closeSettings.addEventListener('click', () => {
            settingsPanel.style.display = 'none';
            gameState.isPaused = false;
        });

        function setupSlider(id, settingKey, suffix = '', multiplier = 1) {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(id + 'Value');

            slider.addEventListener('input', () => {
                const value = parseFloat(slider.value);
                settings[settingKey] = value * multiplier;
                valueDisplay.textContent = value + suffix;
            });
        }

        setupSlider('xSensitivity', 'xSensitivity');
        setupSlider('ySensitivity', 'ySensitivity');
        setupSlider('maxHeight', 'maxHeight', '%', 0.01);
        setupSlider('shipSpeed', 'shipSpeed', 'x');
        setupSlider('fireRate', 'fireRate', 'x');
        setupSlider('scrollSpeed', 'scrollSpeed', 'x');

        // Start game
        const startScreen = document.getElementById('startScreen');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const gameOverPanel = document.getElementById('gameOver');

        startBtn.addEventListener('click', async () => {
            // Stop preview renders
            previewScenes.forEach(p => {
                p.engine.stopRenderLoop();
                p.scene.dispose();
                p.engine.dispose();
            });

            startScreen.style.display = 'none';
            document.getElementById('settingsBtn').style.display = 'flex';
            document.getElementById('hud').style.display = 'block';

            // Create main game scene
            createMainScene();
            await createPlayerShip();
            createStars();
            spawnWave();

            gameState.isPlaying = true;

            // Main game loop
            let lastTime = performance.now();
            let spawnTimer = 0;

            scene.registerBeforeRender(() => {
                if (!gameState.isPlaying || gameState.isPaused) return;

                const currentTime = performance.now();
                const deltaTime = Math.min(currentTime - lastTime, 50);
                lastTime = currentTime;

                const scrollMultiplier = updatePlayerPosition(deltaTime);
                updateStars(scrollMultiplier);
                firePlayerWeapons(currentTime);

                spawnTimer += deltaTime;
                if (spawnTimer > 800 && gameState.enemiesSpawned < gameState.enemiesInWave) {
                    spawnEnemy();
                    spawnTimer = 0;
                }

                if (gameState.enemiesSpawned >= gameState.enemiesInWave && gameState.enemies.length === 0) {
                    gameState.wave++;
                    updateHUD();
                    spawnWave();
                }

                updateEnemies(deltaTime, currentTime, scrollMultiplier);
                updateBullets();
                checkPlayerCollision();
            });

            engine.runRenderLoop(() => {
                scene.render();
            });
        });

        restartBtn.addEventListener('click', () => {
            gameOverPanel.style.display = 'none';
            gameState.isPlaying = true;
            resetGame();
        });

        // Handle resize
        window.addEventListener('resize', () => {
            engine.resize();
            updateGameDimensions();
        });

        // Initialize - load model previews
        createModelPreviews();
    </script>
</body>
</html>
