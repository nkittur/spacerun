<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Run - Bullet Hell Shooter</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #gameContainer {
            width: 100%;
            height: 100%;
            max-width: 500px;
            margin: 0 auto;
            position: relative;
            background: #000;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        #settingsPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #4488ff;
            border-radius: 15px;
            padding: 25px;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            z-index: 200;
            display: none;
            min-width: 300px;
            max-width: 90%;
            box-shadow: 0 0 30px rgba(68, 136, 255, 0.5);
        }

        #settingsPanel h2 {
            text-align: center;
            margin-bottom: 20px;
            color: #4488ff;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .setting-group {
            margin-bottom: 15px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #aaccff;
        }

        .setting-group input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: #223355;
            border-radius: 4px;
            outline: none;
        }

        .setting-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #4488ff;
            border-radius: 50%;
            cursor: pointer;
        }

        .setting-value {
            text-align: right;
            font-size: 12px;
            color: #88aadd;
            margin-top: 3px;
        }

        .checkbox-group {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #334;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-size: 14px;
            color: #aaccff;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #4488ff;
            cursor: pointer;
        }

        #closeSettings {
            width: 100%;
            padding: 12px;
            margin-top: 15px;
            background: #4488ff;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #closeSettings:hover {
            background: #5599ff;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 14px;
            z-index: 50;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
        }

        #hud div {
            margin-bottom: 3px;
        }

        #shieldsDisplay {
            position: absolute;
            top: 10px;
            right: 60px;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 14px;
            z-index: 50;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #shieldsBar {
            width: 100px;
            height: 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #44aaff;
            border-radius: 6px;
            overflow: hidden;
        }

        #shieldsBarFill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #44aaff, #88ddff);
            transition: width 0.3s ease;
        }

        /* Resource collection notifications below top UI */
        #collectNotifications {
            position: absolute;
            top: 45px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 70;
            pointer-events: none;
        }

        .collect-notif {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 6px;
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 14px;
            font-weight: bold;
            animation: collectPop 2s forwards;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .collect-notif .symbol {
            width: 22px;
            height: 22px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: #000;
        }

        .collect-notif .amount {
            color: #fff;
        }

        @keyframes collectPop {
            0% { opacity: 0; transform: translateY(10px) scale(0.8); }
            10% { opacity: 1; transform: translateY(0) scale(1.1); }
            20% { transform: translateY(0) scale(1); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-10px); }
        }

        /* Harvest progress bar - positioned on planet */
        #harvestBar {
            position: absolute;
            height: 6px;
            background: rgba(0, 0, 0, 0.6);
            overflow: hidden;
            display: none;
            z-index: 60;
            border-radius: 3px;
        }

        #harvestBarFill {
            height: 100%;
            width: 0%;
            background: #44ffaa;
            transition: width 0.1s linear;
        }

        /* Targeting corners overlay */
        #targetingOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 55;
        }

        .targeting-corner {
            position: absolute;
            width: 20px;
            height: 20px;
            border-color: #44ffaa;
            border-style: solid;
            border-width: 0;
        }

        .targeting-corner.top-left {
            border-top-width: 3px;
            border-left-width: 3px;
        }

        .targeting-corner.top-right {
            border-top-width: 3px;
            border-right-width: 3px;
        }

        .targeting-corner.bottom-left {
            border-bottom-width: 3px;
            border-left-width: 3px;
        }

        .targeting-corner.bottom-right {
            border-bottom-width: 3px;
            border-right-width: 3px;
        }

        /* Planet info indicators - subtle and translucent */
        #planetInfo {
            position: absolute;
            display: none;
            flex-direction: row;
            gap: 12px;
            z-index: 56;
            pointer-events: none;
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 12px;
        }

        .planet-stat {
            display: flex;
            align-items: center;
            gap: 2px;
            opacity: 0.6;
        }

        .planet-stat.richness {
            color: #ffdd44;
            text-shadow: 0 0 4px rgba(255, 221, 68, 0.5);
        }

        .planet-stat.hazard {
            color: #ff6644;
            text-shadow: 0 0 4px rgba(255, 102, 68, 0.5);
        }

        /* Upgrade items (used in station outfitter) */
        .upgrade-section {
            width: 100%;
            max-width: 350px;
            margin-bottom: 20px;
        }

        .upgrade-section h3 {
            color: #88aadd;
            font-size: 14px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid #334;
            padding-bottom: 5px;
        }

        .upgrade-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(30, 40, 60, 0.8);
            border: 1px solid #335;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
        }

        .upgrade-item.owned {
            border-color: #44aa44;
            background: rgba(40, 60, 40, 0.5);
        }

        .upgrade-item.equipped {
            border-color: #44aaff;
            background: rgba(40, 60, 80, 0.5);
        }

        .upgrade-item.on-sale {
            border-color: #44ff44;
            background: rgba(30, 60, 30, 0.6);
        }

        .upgrade-item.hardpoint-slot {
            border-color: #6688aa;
            background: rgba(40, 50, 70, 0.7);
        }

        /* Weapon quality colors */
        .quality-poor { color: #888888; }
        .quality-common { color: #ffffff; }
        .quality-good { color: #44ff44; }
        .quality-excellent { color: #4488ff; }
        .quality-legendary { color: #ff8800; text-shadow: 0 0 8px #ff8800; }

        /* Weapon level badge */
        .weapon-level {
            display: inline-block;
            background: linear-gradient(135deg, #446 0%, #335 100%);
            border: 1px solid #668;
            border-radius: 3px;
            padding: 1px 5px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 5px;
        }

        .upgrade-info {
            flex: 1;
        }

        .upgrade-name {
            font-size: 14px;
            font-weight: bold;
            color: #fff;
        }

        .upgrade-desc {
            font-size: 11px;
            color: #88aacc;
            margin-top: 3px;
        }

        .upgrade-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
        }

        .upgrade-btn.buy {
            background: #44aa44;
            color: white;
        }

        .upgrade-btn.buy:disabled {
            background: #444;
            color: #666;
            cursor: not-allowed;
        }

        .upgrade-btn.equip {
            background: #4488ff;
            color: white;
        }

        .upgrade-btn.sell {
            background: #aa6644;
            color: white;
        }

        .upgrade-btn.unequip {
            background: #886644;
            color: white;
        }

        .upgrade-btn.equipped {
            background: #335;
            color: #88aacc;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #ff4444;
            border-radius: 15px;
            padding: 30px 50px;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            z-index: 150;
            display: none;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 68, 68, 0.5);
        }

        #gameOver h2 {
            color: #ff4444;
            font-size: 32px;
            margin-bottom: 15px;
        }

        #gameOver p {
            font-size: 18px;
            margin-bottom: 20px;
        }

        #restartBtn {
            padding: 12px 30px;
            background: #ff4444;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            text-transform: uppercase;
        }

        #restartBtn:hover {
            background: #ff5555;
        }

        /* Warp Gate HUD Previews - minimal, blends with background */
        #warpGatePanel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            pointer-events: none;
            z-index: 80;
            font-family: 'Courier New', monospace;
        }

        .gate-preview {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
        }

        .gate-hud {
            padding: 6px 10px;
            min-width: 80px;
        }

        .hud-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 11px;
            letter-spacing: 1px;
            text-shadow: 0 0 8px rgba(0,0,0,0.9), 0 0 3px rgba(0,0,0,1);
        }

        .hud-row:last-child {
            margin-bottom: 0;
        }

        .hud-label {
            color: rgba(150, 150, 180, 0.8);
            text-transform: uppercase;
            font-size: 9px;
            margin-right: 8px;
        }

        .hud-value {
            font-weight: bold;
            font-size: 13px;
            color: #fff;
        }

        .gate-preview.left .hud-value { color: #ffaa66; }
        .gate-preview.right .hud-value { color: #66ffaa; }

        /* Threat level indicator bar */
        .threat-bar {
            display: flex;
            gap: 3px;
        }

        .threat-pip {
            width: 6px;
            height: 10px;
            background: rgba(40, 40, 60, 0.5);
        }

        .threat-pip.active {
            background: currentColor;
            box-shadow: 0 0 6px currentColor;
        }

        .threat-low { color: #44ff88; }
        .threat-medium { color: #ffaa44; }
        .threat-high { color: #ff6644; }
        .threat-extreme { color: #ff4444; }

        /* Station icons - minimal dots */
        .station-icons {
            display: flex;
            gap: 4px;
        }

        .station-icon {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.4);
        }

        .station-icon.trade { color: #44aaff; text-shadow: 0 0 4px #44aaff; }
        .station-icon.armory { color: #ff4444; text-shadow: 0 0 4px #ff4444; }
        .station-icon.repair { color: #44ff88; text-shadow: 0 0 4px #44ff88; }
        .station-icon.fuel { color: #ffaa44; text-shadow: 0 0 4px #ffaa44; }

        .no-stations {
            color: rgba(100, 100, 120, 0.6);
            font-size: 10px;
        }

        /* Warp/Lightspeed Animation */
        #warpOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0,0,0,0.8) 100%);
            z-index: 250;
            display: none;
            overflow: hidden;
        }

        .warp-star {
            position: absolute;
            background: linear-gradient(to bottom, transparent, white, transparent);
            width: 2px;
            transform-origin: center bottom;
            animation: warpStreak 0.8s ease-in forwards;
        }

        @keyframes warpStreak {
            0% {
                height: 5px;
                opacity: 0;
            }
            20% {
                opacity: 1;
            }
            100% {
                height: 100vh;
                opacity: 0;
            }
        }

        #warpFlash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            opacity: 0;
            z-index: 260;
            pointer-events: none;
        }

        /* Speed Up Button - Sci-fi HUD style */
        #speedUpBtn {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 10px 16px;
            background: rgba(0, 20, 40, 0.85);
            border: 1px solid #4488ff;
            border-radius: 0;
            color: #4488ff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            letter-spacing: 2px;
            cursor: pointer;
            z-index: 60;
            display: none;
            transition: all 0.15s ease;
            text-transform: uppercase;
        }

        #speedUpBtn:hover {
            background: rgba(68, 136, 255, 0.2);
            box-shadow: 0 0 10px rgba(68, 136, 255, 0.3);
        }

        #speedUpBtn:active, #speedUpBtn.active {
            background: rgba(68, 136, 255, 0.4);
            color: white;
            box-shadow: 0 0 20px rgba(68, 136, 255, 0.6), inset 0 0 10px rgba(68, 136, 255, 0.3);
        }

        #speedUpBtn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #0a0a20 0%, #1a1a40 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 300;
            font-family: 'Segoe UI', Arial, sans-serif;
            color: white;
        }

        #startScreen h1 {
            font-size: 42px;
            color: #4488ff;
            text-shadow: 0 0 30px rgba(68, 136, 255, 0.8);
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 8px;
        }

        #startScreen .subtitle {
            font-size: 14px;
            color: #6699cc;
            margin-bottom: 50px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        #titleButtons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .title-btn {
            padding: 18px 60px;
            background: linear-gradient(180deg, #4488ff 0%, #2266dd 100%);
            border: 2px solid #66aaff;
            border-radius: 10px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            box-shadow: 0 0 20px rgba(68, 136, 255, 0.4);
            transition: all 0.2s ease;
            min-width: 220px;
        }

        .title-btn:hover {
            background: linear-gradient(180deg, #5599ff 0%, #3377ee 100%);
            box-shadow: 0 0 30px rgba(68, 136, 255, 0.7);
            transform: scale(1.02);
        }

        .title-btn:disabled {
            background: #334;
            border-color: #445;
            color: #667;
            cursor: not-allowed;
            box-shadow: none;
        }

        #continueBtn {
            display: none;
        }

        #loadingScreen {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        #loadingScreen .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #223;
            border-top-color: #4488ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #loadingScreen .loading-text {
            color: #4488ff;
            font-size: 18px;
            letter-spacing: 2px;
        }

        #startBtn {
            padding: 15px 50px;
            background: #4488ff;
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 20px rgba(68, 136, 255, 0.5);
            margin: 20px 0;
        }

        #startBtn:hover {
            background: #5599ff;
            box-shadow: 0 0 30px rgba(68, 136, 255, 0.8);
        }

        #loadingText {
            color: #4488ff;
            font-size: 18px;
            margin: 20px 0;
        }

        /* System Menu */
        #systemBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #systemBtn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        #systemMenu {
            position: absolute;
            top: 55px;
            right: 10px;
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #4488ff;
            border-radius: 10px;
            padding: 8px 0;
            z-index: 150;
            display: none;
            min-width: 150px;
            box-shadow: 0 0 20px rgba(68, 136, 255, 0.5);
        }

        .menu-item {
            padding: 12px 20px;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 14px;
            cursor: pointer;
            text-align: left;
            transition: background 0.2s;
        }

        .menu-item:hover {
            background: rgba(68, 136, 255, 0.3);
        }

        .menu-divider {
            height: 1px;
            background: rgba(68, 136, 255, 0.3);
            margin: 5px 0;
        }

        /* Saved Notification */
        #savedNotification {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(40, 180, 80, 0.9);
            border: 2px solid #4f4;
            border-radius: 8px;
            padding: 10px 25px;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 16px;
            z-index: 300;
            display: none;
            box-shadow: 0 0 15px rgba(68, 255, 68, 0.5);
            animation: fadeInOut 2s ease-in-out;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            15% { opacity: 1; transform: translateX(-50%) translateY(0); }
            85% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
        }

        /* Confirmation Dialog */
        #confirmDialog {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.98);
            border: 2px solid #ff6644;
            border-radius: 15px;
            padding: 25px;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            z-index: 250;
            display: none;
            min-width: 280px;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 100, 68, 0.5);
        }

        #confirmDialog h3 {
            margin-bottom: 15px;
            color: #ff8866;
        }

        #confirmDialog p {
            margin-bottom: 20px;
            font-size: 14px;
            color: #aaccff;
        }

        .confirm-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .confirm-btn {
            padding: 10px 25px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .confirm-btn.danger {
            background: #ff4444;
            color: white;
        }

        .confirm-btn.danger:hover {
            background: #ff6666;
        }

        .confirm-btn.cancel {
            background: #445566;
            color: white;
        }

        .confirm-btn.cancel:hover {
            background: #556677;
        }

        /* Station Interior View */
        #stationInterior {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a15;
            display: none;
            z-index: 200;
            font-family: 'Segoe UI', Arial, sans-serif;
            color: white;
        }

        #stationHub {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center top;
            background-repeat: no-repeat;
            z-index: 200;
            pointer-events: none;
        }

        #stationHubOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(10, 10, 20, 0.3) 0%, rgba(10, 10, 20, 0.7) 30%, rgba(10, 10, 20, 0.95) 60%);
            z-index: 201;
            pointer-events: none;
        }

        #stationHeader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            background: rgba(10, 10, 20, 0.95);
            border-bottom: 1px solid #335;
            z-index: 210;
        }

        #stationName {
            color: #44aaff;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(68, 170, 255, 0.5);
        }

        #stationCredits {
            color: #ffdd44;
            font-size: 14px;
            text-shadow: 0 0 8px rgba(255, 221, 68, 0.5);
        }

        #stationNav {
            position: fixed;
            top: 45px;
            left: 0;
            width: 100%;
            padding: 8px 5px;
            background: rgba(15, 15, 30, 0.95);
            display: flex;
            justify-content: center;
            gap: 5px;
            flex-wrap: wrap;
            border-bottom: 1px solid #335;
            z-index: 210;
            box-sizing: border-box;
        }

        .station-nav-btn {
            padding: 8px 12px;
            background: rgba(30, 40, 60, 0.8);
            border: 1px solid #335;
            border-radius: 5px;
            color: #88aacc;
            font-size: 11px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s ease;
        }

        .station-nav-btn:hover {
            background: rgba(50, 70, 100, 0.8);
            border-color: #446;
        }

        .station-nav-btn.active {
            background: rgba(68, 136, 255, 0.3);
            border-color: #4488ff;
            color: #4488ff;
        }

        .station-nav-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .station-nav-btn.disabled:hover {
            background: rgba(30, 40, 60, 0.8);
            border-color: #335;
        }

        #stationContent {
            position: fixed;
            top: 95px;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 15px;
            padding-bottom: 80px;
            overflow-y: scroll;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            box-sizing: border-box;
            z-index: 205;
        }

        .station-section {
            display: none;
        }

        .station-section.active {
            display: block;
        }

        .station-section h3 {
            color: #88aadd;
            font-size: 14px;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid #334;
            padding-bottom: 8px;
        }

        /* Bar Section - Rumors */
        .rumor-item {
            background: rgba(30, 40, 60, 0.6);
            border: 1px solid #334;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .rumor-source {
            color: #ffaa44;
            font-size: 11px;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .rumor-text {
            color: #ccd;
            font-size: 13px;
            line-height: 1.5;
            font-style: italic;
        }

        .tip-item {
            background: rgba(40, 60, 40, 0.5);
            border: 1px solid #4a6;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .tip-label {
            color: #6c8;
            font-size: 10px;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .tip-text {
            color: #afa;
            font-size: 13px;
            line-height: 1.4;
        }

        /* Outfitter Section - Weapons & Equipment */
        .outfitter-category {
            margin-bottom: 20px;
        }

        .outfitter-category h4 {
            color: #6a8;
            font-size: 12px;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        /* Future Section Placeholders */
        .coming-soon {
            text-align: center;
            padding: 40px 20px;
            color: #668;
        }

        .coming-soon-icon {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .coming-soon-text {
            font-size: 14px;
            color: #88a;
        }

        /* Depart Button */
        #stationDepartBtn {
            position: fixed;
            top: 8px;
            right: 10px;
            padding: 6px 12px;
            background: #ff8844;
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 11px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 220;
            box-shadow: 0 0 10px rgba(255, 136, 68, 0.4);
        }

        #stationDepartBtn:hover {
            background: #ffaa66;
            box-shadow: 0 0 15px rgba(255, 136, 68, 0.6);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
    <canvas id="renderCanvas"></canvas>

    <div id="startScreen">
        <h1>Space Run</h1>
        <div class="subtitle">Bullet Hell Shooter</div>
        <div id="titleButtons">
            <button id="newGameBtn" class="title-btn">New Game</button>
            <button id="continueBtn" class="title-btn">Continue</button>
        </div>
        <div id="loadingScreen">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading...</div>
        </div>
    </div>

    <button id="systemBtn" style="display: none;">â˜°</button>
    <div id="systemMenu">
        <div class="menu-item" id="menuSettings">âš™ Settings</div>
        <div class="menu-divider"></div>
        <div class="menu-item" id="menuSaveQuit">ðŸ’¾ Save & Quit</div>
        <div class="menu-item" id="menuNewGame">ðŸ”„ New Game</div>
    </div>
    <div id="savedNotification">Saved...</div>
    <div id="confirmDialog">
        <h3>Start New Game?</h3>
        <p>Your current progress will be lost if not saved.</p>
        <div class="confirm-buttons">
            <button class="confirm-btn danger" id="confirmNewGame">New Game</button>
            <button class="confirm-btn cancel" id="cancelNewGame">Cancel</button>
        </div>
    </div>

    <div id="settingsPanel">
        <h2>Settings</h2>
        <div class="setting-group">
            <label>X Sensitivity (Horizontal)</label>
            <input type="range" id="xSensitivity" min="0.5" max="3" step="0.1" value="1.5">
            <div class="setting-value" id="xSensitivityValue">1.5</div>
        </div>
        <div class="setting-group">
            <label>Y Sensitivity (Vertical)</label>
            <input type="range" id="ySensitivity" min="0.5" max="3" step="0.1" value="1.2">
            <div class="setting-value" id="ySensitivityValue">1.2</div>
        </div>
        <div class="setting-group">
            <label>Max Ship Height (% of screen)</label>
            <input type="range" id="maxHeight" min="30" max="70" step="5" value="50">
            <div class="setting-value" id="maxHeightValue">50%</div>
        </div>
        <div class="setting-group">
            <label>Ship Speed</label>
            <input type="range" id="shipSpeed" min="0.5" max="2" step="0.1" value="1">
            <div class="setting-value" id="shipSpeedValue">1.0x</div>
        </div>
        <div class="setting-group">
            <label>Fire Rate</label>
            <input type="range" id="fireRate" min="0.5" max="3" step="0.1" value="1">
            <div class="setting-value" id="fireRateValue">1.0x</div>
        </div>
        <div class="setting-group">
            <label>Scroll Speed</label>
            <input type="range" id="scrollSpeed" min="0.5" max="2" step="0.1" value="1">
            <div class="setting-value" id="scrollSpeedValue">1.0x</div>
        </div>
        <div class="setting-group checkbox-group">
            <label>
                <input type="checkbox" id="debugMode">
                Debug Mode (1000 credits at start)
            </label>
        </div>
        <button id="closeSettings">Close</button>
    </div>

    <div id="hud" style="display: none;">
        <div>Credits: <span id="creditsHud">0</span></div>
        <div>Health: <span id="health">100</span></div>
        <div>Level: <span id="level">1</span> | Wave: <span id="wave">1</span>/<span id="totalWaves">3</span></div>
    </div>

    <div id="shieldsDisplay" style="display: none;">
        <span>Base:</span>
        <div id="shieldsBar"><div id="shieldsBarFill"></div></div>
        <span id="shieldsValue">100</span>
    </div>

    <div id="collectNotifications"></div>

    <div id="harvestBar"><div id="harvestBarFill"></div></div>
    <div id="targetingOverlay">
        <div class="targeting-corner top-left"></div>
        <div class="targeting-corner top-right"></div>
        <div class="targeting-corner bottom-left"></div>
        <div class="targeting-corner bottom-right"></div>
    </div>
    <div id="planetInfo">
        <div class="planet-stat richness"><span id="richnessIcon">ðŸ’Ž</span><span id="richnessValue"></span></div>
        <div class="planet-stat hazard"><span id="hazardIcon">âš </span><span id="hazardValue"></span></div>
    </div>

    <!-- Station Interior View -->
    <div id="stationInterior">
        <div id="stationHub">
            <div id="stationHubOverlay"></div>
        </div>

        <div id="stationHeader">
            <div id="stationName">Starbase</div>
            <div id="stationCredits"><span id="creditsDisplay">0</span> CR</div>
        </div>

        <div id="stationNav">
            <button class="station-nav-btn active" data-section="bar">Bar</button>
            <button class="station-nav-btn" data-section="missions">Missions</button>
            <button class="station-nav-btn" data-section="outfitter">Outfitter</button>
            <button class="station-nav-btn" data-section="shipyard">Shipyard</button>
            <button class="station-nav-btn" data-section="trading">Trading</button>
        </div>

        <div id="stationContent">
            <!-- Bar Section -->
            <div id="sectionBar" class="station-section active">
                <h3>Station Bar</h3>
                <div id="barRumors"></div>
                <div id="barTips"></div>
            </div>

            <!-- Missions Section -->
            <div id="sectionMissions" class="station-section">
                <h3>Mission Board</h3>
                <div class="coming-soon">
                    <div class="coming-soon-icon">ðŸ“‹</div>
                    <div class="coming-soon-text">Mission contracts coming soon...</div>
                </div>
            </div>

            <!-- Outfitter Section -->
            <div id="sectionOutfitter" class="station-section">
                <h3>Outfitter</h3>
                <div class="outfitter-category">
                    <h4>Weapons</h4>
                    <div id="weaponsList"></div>
                </div>
            </div>

            <!-- Shipyard Section -->
            <div id="sectionShipyard" class="station-section">
                <h3>Shipyard</h3>
                <div class="coming-soon">
                    <div class="coming-soon-icon">ðŸš€</div>
                    <div class="coming-soon-text">Ship upgrades coming soon...</div>
                </div>
            </div>

            <!-- Trading Post Section -->
            <div id="sectionTrading" class="station-section">
                <h3>Trading Post</h3>
                <div class="coming-soon">
                    <div class="coming-soon-icon">ðŸ“¦</div>
                    <div class="coming-soon-text">Commodity trading coming soon...</div>
                </div>
            </div>
        </div>

        <button id="stationDepartBtn">Depart</button>
    </div>

    <div id="warpGatePanel">
        <div class="gate-preview left" id="gateLeftPreview">
            <div class="gate-hud">
                <div class="hud-row">
                    <span class="hud-label">THR</span>
                    <div class="threat-bar" id="gateLeftThreat"></div>
                </div>
                <div class="hud-row">
                    <span class="hud-label">WAV</span>
                    <span class="hud-value" id="gateLeftWaves">3</span>
                </div>
                <div class="hud-row">
                    <span class="hud-label">STA</span>
                    <div class="station-icons" id="gateLeftStations"></div>
                </div>
            </div>
        </div>
        <div class="gate-preview right" id="gateRightPreview">
            <div class="gate-hud">
                <div class="hud-row">
                    <span class="hud-label">THR</span>
                    <div class="threat-bar" id="gateRightThreat"></div>
                </div>
                <div class="hud-row">
                    <span class="hud-label">WAV</span>
                    <span class="hud-value" id="gateRightWaves">5</span>
                </div>
                <div class="hud-row">
                    <span class="hud-label">STA</span>
                    <div class="station-icons" id="gateRightStations"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="warpOverlay"></div>
    <div id="warpFlash"></div>

    <button id="speedUpBtn">&gt;&gt; WARP</button>

    <div id="gameOver">
        <h2>Game Over</h2>
        <p>Final Credits: <span id="finalCredits">0</span></p>
        <button id="restartBtn">Play Again</button>
    </div>
    </div><!-- end gameContainer -->

    <script>
        // Ship model names
        const shipNames = ['Bob', 'Challenger', 'Dispatcher', 'Executioner', 'Imperial',
                          'Insurgent', 'Omen', 'Pancake', 'Spitfire', 'Striker', 'Zenith'];
        const colorVariants = ['Blue', 'Green', 'Orange', 'Purple', 'Red'];

        // Resource types with colors for display
        const RESOURCES = {
            Iron: { color: '#aaaaaa', symbol: 'Fe' },
            Copper: { color: '#dd8844', symbol: 'Cu' },
            Silicon: { color: '#88aacc', symbol: 'Si' },
            Titanium: { color: '#ccccee', symbol: 'Ti' },
            Hydrogen: { color: '#aaddff', symbol: 'H' },
            Helium: { color: '#ffddaa', symbol: 'He' },
            Water: { color: '#4488ff', symbol: 'H2O' },
            Carbon: { color: '#444444', symbol: 'C' },
            Oxygen: { color: '#aaffaa', symbol: 'O' },
            Sulfur: { color: '#dddd44', symbol: 'S' },
            Nitrogen: { color: '#aaaaff', symbol: 'N' },
            Gold: { color: '#ffdd00', symbol: 'Au' }
        };

        // Planet types with their resources and image paths
        const PLANET_TYPES = {
            // Gaseous planets - yield gases
            BlueGiant: {
                category: 'Gaseous', folder: 'Blue Giant', prefix: 'BlueGiant',
                resources: { Hydrogen: [30, 50], Helium: [20, 40] }, harvests: 2, tint: [0.7, 0.8, 1.0]
            },
            GreenGiant: {
                category: 'Gaseous', folder: 'Green Giant', prefix: 'GreenGiant',
                resources: { Hydrogen: [25, 45], Nitrogen: [15, 30] }, harvests: 2, tint: [0.7, 1.0, 0.8]
            },
            OrangeGiant: {
                category: 'Gaseous', folder: 'Orange Giant', prefix: 'OrgangeGiant',
                resources: { Helium: [35, 55], Hydrogen: [20, 35] }, harvests: 2, tint: [1.0, 0.8, 0.6]
            },
            RedGiant: {
                category: 'Gaseous', folder: 'Red Giant', prefix: 'RedGiant',
                resources: { Hydrogen: [40, 60], Helium: [25, 40] }, harvests: 3, tint: [1.0, 0.7, 0.7]
            },
            YellowGiant: {
                category: 'Gaseous', folder: 'Yellow Giant', prefix: 'YellowGiant',
                resources: { Helium: [30, 50], Hydrogen: [25, 40] }, harvests: 2, tint: [1.0, 1.0, 0.8]
            },
            // Rocky planets - yield metals
            Rocky: {
                category: 'Solid', folder: 'Rocky', prefix: 'Rocky',
                resources: { Iron: [15, 30], Silicon: [10, 20] }, harvests: 2, tint: [0.9, 0.8, 0.7]
            },
            Cratered: {
                category: 'Solid', folder: 'Cratered', prefix: 'Cratered',
                resources: { Iron: [20, 35], Titanium: [10, 20] }, harvests: 2, tint: [0.8, 0.8, 0.8]
            },
            Barren: {
                category: 'Solid', folder: 'Barren', prefix: 'Barren',
                resources: { Silicon: [15, 25], Copper: [10, 20] }, harvests: 1, tint: [0.9, 0.85, 0.8]
            },
            Lunar: {
                category: 'Solid', folder: 'Lunar', prefix: 'Lunar',
                resources: { Titanium: [15, 30], Iron: [10, 20] }, harvests: 1, tint: [0.85, 0.85, 0.9]
            },
            // Ice planets - yield water and gases
            Frozen: {
                category: 'Solid', folder: 'Frozen', prefix: 'Frozen',
                resources: { Water: [25, 45], Nitrogen: [15, 25] }, harvests: 2, tint: [0.8, 0.9, 1.0]
            },
            Icy: {
                category: 'Solid', folder: 'Icy', prefix: 'Icy',
                resources: { Water: [30, 50], Oxygen: [10, 20] }, harvests: 2, tint: [0.85, 0.95, 1.0]
            },
            Glacial: {
                category: 'Solid', folder: 'Glacial', prefix: 'Glacial',
                resources: { Water: [35, 55], Nitrogen: [15, 30] }, harvests: 3, tint: [0.75, 0.9, 1.0]
            },
            // Volcanic - yield rare metals
            Magma: {
                category: 'Solid', folder: 'Magma', prefix: 'Magma',
                resources: { Iron: [25, 45], Sulfur: [20, 35], Gold: [5, 15] }, harvests: 2, tint: [1.0, 0.7, 0.5]
            },
            // Life planets - yield organics
            Lush: {
                category: 'Solid', folder: 'Lush', prefix: 'Lush',
                resources: { Carbon: [20, 40], Oxygen: [25, 45], Water: [15, 25] }, harvests: 3, tint: [0.8, 1.0, 0.8]
            },
            Tropical: {
                category: 'Solid', folder: 'Tropical', prefix: 'Tropical',
                resources: { Carbon: [25, 45], Oxygen: [20, 35], Water: [20, 35] }, harvests: 3, tint: [0.85, 1.0, 0.85]
            },
            Ocean: {
                category: 'Solid', folder: 'Ocean', prefix: 'Ocean',
                resources: { Water: [50, 80], Oxygen: [15, 30] }, harvests: 4, tint: [0.7, 0.85, 1.0]
            },
            // Arid planets
            Arid: {
                category: 'Solid', folder: 'Arid', prefix: 'Arid',
                resources: { Silicon: [20, 35], Copper: [15, 25] }, harvests: 1, tint: [1.0, 0.9, 0.7]
            },
            Dry: {
                category: 'Solid', folder: 'Dry', prefix: 'Dry',
                resources: { Silicon: [15, 30], Iron: [10, 20] }, harvests: 1, tint: [0.95, 0.85, 0.7]
            }
        };

        // Game Settings
        const settings = {
            xSensitivity: 1.5,
            ySensitivity: 1.2,
            maxHeight: 0.5,
            shipSpeed: 1.0,
            fireRate: 1.0,
            scrollSpeed: 1.0,
            playerShip: 'Bob',
            playerColor: 'Blue',
            enemyShip: 'Spitfire',
            enemyColor: 'Red',
            debugMode: localStorage.getItem('debugMode') === 'true'
        };

        // Loaded model templates
        const modelTemplates = {};

        // Sun types
        const SUN_TYPES = {
            YellowSun: { folder: 'Yellow Sun', prefix: 'Sun_Yellow', tint: [1.0, 1.0, 0.8] },
            RedSun: { folder: 'Red Sun', prefix: 'Sun_Red', tint: [1.0, 0.7, 0.6] },
            BlueSun: { folder: 'Blue Sun', prefix: 'Sun_Blue', tint: [0.7, 0.8, 1.0] }
        };

        // Game State
        let gameState = {
            score: 0,
            health: 100,
            wave: 1,
            isPlaying: false,
            isPaused: false,
            enemies: [],
            playerBullets: [],
            enemyBullets: [],
            loot: [],
            planets: [],
            suns: [],
            solarSystems: [],
            stars: [],
            lastFireTime: 0,
            waveTimer: 0,
            enemiesInWave: 0,
            enemiesSpawned: 0,
            nextSolarSystemY: 0,
            harvestingPlanet: null,
            harvestProgress: 0,
            resources: {},
            baseShields: 100,
            escapedEnemies: 0,
            pendingNotifications: {},
            // Zone/background tracking
            currentZone: 0,
            distanceTraveled: 0,
            transitionPhase: 0, // 0=none, 1=fading to starfield, 2=fading to next zone
            backgroundTransition: 0,
            // Starbase and weapons
            starbase: null,
            isDocked: false,
            wavesUntilStarbase: 1,
            credits: 0,
            ownedWeapons: [],  // Now stores full weapon objects
            equippedWeapons: [], // Weapons equipped on hardpoints
            beamActive: false,
            beamMesh: null,
            // Fleet and hardpoint system
            fleet: [],  // Array of ships with hardpoints
            stationWeapons: [],  // Weapons available at current station
            // River navigation - level system
            level: 1,
            levelWave: 0,           // Current wave within level (0 = not started)
            levelConfig: null,      // Config for current level
            stationsVisited: 0,     // How many stations visited this level
            warpGates: [],          // Active warp gates
            gateChoices: null,      // The two gate options
            showingGates: false,    // Whether gates are currently displayed
            levelEndSpawned: false, // Whether end-of-level content (reward + gates) has been spawned
            speedUp: false          // Speed-up button pressed
        };

        // Space zones - different areas with unique backgrounds (Starfield is transition zone)
        const SPACE_ZONES = [
            { name: 'Blue Nebula', folder: 'Blue Nebula', prefix: 'Blue_Nebula', variants: 8 },
            { name: 'Purple Nebula', folder: 'Purple Nebula', prefix: 'Purple_Nebula', variants: 8 },
            { name: 'Green Nebula', folder: 'Green Nebula', prefix: 'Green_Nebula', variants: 8 }
        ];

        // Starfield is used as neutral transition between zones
        const STARFIELD_ZONE = { name: 'Starfield', folder: 'Starfields', prefix: 'Starfield', variants: 8 };

        const ZONE_DISTANCE = 500; // Distance units per zone before transitioning

        // Level zone heights in world Y units (1 screen height â‰ˆ orthoHeight*2 â‰ˆ 20 units)
        const LEVEL_ZONE_HEIGHTS = {
            reward: 6,   // Y distance for reward/exploration zone (~0.3 screens)
            gate: 10     // Y distance for gate zone
        };

        // Weapon size categories (smaller can mount on larger hardpoints)
        const WEAPON_SIZES = ['light', 'medium', 'heavy', 'assault'];
        const WEAPON_SIZE_ORDER = { light: 0, medium: 1, heavy: 2, assault: 3 };

        // Weapon type definitions
        const WEAPON_TYPES = {
            bullet: { name: 'Projectile', speedMult: 1.0 },
            beam: { name: 'Beam', speedMult: 0 },  // Instant hit
            spread: { name: 'Spread', speedMult: 0.9 }
        };

        // Base weapon templates with level scaling configurations
        // Each weapon class scales differently with level:
        // - damagePerLevel: flat damage added per level
        // - damageMultPerLevel: % damage increase per level (compounding)
        // - fireRatePerLevel: ms reduction per level (lower = faster)
        // - projectilesPerLevel: extra projectiles gained per N levels
        // - spreadPerLevel: spread increase per level
        // - speedPerLevel: projectile speed multiplier per level
        const WEAPON_TEMPLATES = {
            // === LIGHT WEAPONS ===
            pulse_cannon: {
                baseName: 'Pulse Cannon',
                type: 'bullet',
                size: 'light',
                baseDamage: 8,
                baseFireRate: 300,
                baseSpread: 0,
                baseProjectiles: 1,
                baseSpeed: 0.35,
                baseCost: 80,
                // Balanced scaling - moderate improvements across the board
                scaling: {
                    damagePerLevel: 2,
                    damageMultPerLevel: 0.08,
                    fireRatePerLevel: -15,
                    projectilesPerLevel: 0,
                    spreadPerLevel: 0,
                    speedPerLevel: 0.02
                },
                variants: ['Mk', 'Type', 'Model']
            },
            light_laser: {
                baseName: 'Light Laser',
                type: 'beam',
                size: 'light',
                baseDamage: 12,
                baseFireRate: 800,
                baseSpread: 0.3,
                baseProjectiles: 1,
                baseSpeed: 0,
                baseCost: 120,
                // Beam width and damage scale, fire rate improves slowly
                scaling: {
                    damagePerLevel: 3,
                    damageMultPerLevel: 0.1,
                    fireRatePerLevel: -20,
                    projectilesPerLevel: 0,
                    spreadPerLevel: 0.05,  // Wider beam
                    speedPerLevel: 0
                },
                variants: ['Beam', 'Lance', 'Ray']
            },
            scatter_gun: {
                baseName: 'Scatter Gun',
                type: 'spread',
                size: 'light',
                baseDamage: 4,
                baseFireRate: 450,
                baseSpread: 0.4,
                baseProjectiles: 3,
                baseSpeed: 0.32,
                baseCost: 140,
                // More projectiles with level, small damage per projectile
                scaling: {
                    damagePerLevel: 1,
                    damageMultPerLevel: 0.05,
                    fireRatePerLevel: -10,
                    projectilesPerLevel: 0.4,  // +1 projectile every 2-3 levels
                    spreadPerLevel: 0.03,
                    speedPerLevel: 0.01
                },
                variants: ['Spreader', 'Scattershot', 'Pelter']
            },

            // === MEDIUM WEAPONS ===
            plasma_cannon: {
                baseName: 'Plasma Cannon',
                type: 'bullet',
                size: 'medium',
                baseDamage: 18,
                baseFireRate: 400,
                baseSpread: 0,
                baseProjectiles: 1,
                baseSpeed: 0.38,
                baseCost: 250,
                // High damage scaling, moderate fire rate improvement
                scaling: {
                    damagePerLevel: 5,
                    damageMultPerLevel: 0.12,
                    fireRatePerLevel: -12,
                    projectilesPerLevel: 0,
                    spreadPerLevel: 0,
                    speedPerLevel: 0.025
                },
                variants: ['Plasma', 'Ion', 'Particle']
            },
            twin_laser: {
                baseName: 'Twin Laser',
                type: 'beam',
                size: 'medium',
                baseDamage: 22,
                baseFireRate: 900,
                baseSpread: 0.5,
                baseProjectiles: 2,
                baseSpeed: 0,
                baseCost: 320,
                // More beams at high levels, wider coverage
                scaling: {
                    damagePerLevel: 4,
                    damageMultPerLevel: 0.08,
                    fireRatePerLevel: -25,
                    projectilesPerLevel: 0.25,  // Extra beam every 4 levels
                    spreadPerLevel: 0.06,
                    speedPerLevel: 0
                },
                variants: ['Dual', 'Twin', 'Binary']
            },
            burst_rifle: {
                baseName: 'Burst Rifle',
                type: 'spread',
                size: 'medium',
                baseDamage: 10,
                baseFireRate: 350,
                baseSpread: 0.25,
                baseProjectiles: 3,
                baseSpeed: 0.4,
                baseCost: 280,
                // Fast fire rate improvement, tight spread
                scaling: {
                    damagePerLevel: 2,
                    damageMultPerLevel: 0.07,
                    fireRatePerLevel: -20,
                    projectilesPerLevel: 0.3,
                    spreadPerLevel: -0.01,  // Tighter spread at higher levels
                    speedPerLevel: 0.03
                },
                variants: ['Burst', 'Volley', 'Salvo']
            },

            // === HEAVY WEAPONS ===
            mass_driver: {
                baseName: 'Mass Driver',
                type: 'bullet',
                size: 'heavy',
                baseDamage: 45,
                baseFireRate: 600,
                baseSpread: 0,
                baseProjectiles: 1,
                baseSpeed: 0.45,
                baseCost: 500,
                // Very high damage scaling, slow fire rate improvement
                scaling: {
                    damagePerLevel: 12,
                    damageMultPerLevel: 0.15,
                    fireRatePerLevel: -8,
                    projectilesPerLevel: 0,
                    spreadPerLevel: 0,
                    speedPerLevel: 0.04
                },
                variants: ['Kinetic', 'Impact', 'Slug']
            },
            heavy_beam: {
                baseName: 'Heavy Beam',
                type: 'beam',
                size: 'heavy',
                baseDamage: 55,
                baseFireRate: 1200,
                baseSpread: 0.8,
                baseProjectiles: 1,
                baseSpeed: 0,
                baseCost: 600,
                // Massive beam width scaling, high damage
                scaling: {
                    damagePerLevel: 10,
                    damageMultPerLevel: 0.1,
                    fireRatePerLevel: -30,
                    projectilesPerLevel: 0,
                    spreadPerLevel: 0.12,  // Much wider beam
                    speedPerLevel: 0
                },
                variants: ['Devastator', 'Annihilator', 'Obliterator']
            },
            flak_cannon: {
                baseName: 'Flak Cannon',
                type: 'spread',
                size: 'heavy',
                baseDamage: 15,
                baseFireRate: 500,
                baseSpread: 0.6,
                baseProjectiles: 5,
                baseSpeed: 0.3,
                baseCost: 520,
                // LOTS more projectiles, small damage per projectile
                scaling: {
                    damagePerLevel: 2,
                    damageMultPerLevel: 0.04,
                    fireRatePerLevel: -5,
                    projectilesPerLevel: 0.8,  // +1 projectile almost every level
                    spreadPerLevel: 0.04,
                    speedPerLevel: 0.01
                },
                variants: ['Flak', 'Shrapnel', 'Frag']
            },

            // === ASSAULT WEAPONS ===
            railgun: {
                baseName: 'Railgun',
                type: 'bullet',
                size: 'assault',
                baseDamage: 100,
                baseFireRate: 1200,
                baseSpread: 0,
                baseProjectiles: 1,
                baseSpeed: 0.5,
                baseCost: 1000,
                // MASSIVE damage and speed scaling, fire rate stays slow
                scaling: {
                    damagePerLevel: 25,
                    damageMultPerLevel: 0.2,
                    fireRatePerLevel: -5,  // Barely improves
                    projectilesPerLevel: 0,
                    spreadPerLevel: 0,
                    speedPerLevel: 0.08  // Very fast projectiles
                },
                variants: ['Gauss', 'Coil', 'Magnetic']
            },
            siege_laser: {
                baseName: 'Siege Laser',
                type: 'beam',
                size: 'assault',
                baseDamage: 120,
                baseFireRate: 1500,
                baseSpread: 1.2,
                baseProjectiles: 1,
                baseSpeed: 0,
                baseCost: 1200,
                // Enormous beam coverage, very high damage
                scaling: {
                    damagePerLevel: 20,
                    damageMultPerLevel: 0.12,
                    fireRatePerLevel: -40,
                    projectilesPerLevel: 0,
                    spreadPerLevel: 0.15,  // Massive beam width
                    speedPerLevel: 0
                },
                variants: ['Siege', 'Extinction', 'Apocalypse']
            },
            devastator: {
                baseName: 'Devastator',
                type: 'spread',
                size: 'assault',
                baseDamage: 30,
                baseFireRate: 700,
                baseSpread: 0.8,
                baseProjectiles: 7,
                baseSpeed: 0.35,
                baseCost: 1100,
                // Wall of projectiles, moderate damage each
                scaling: {
                    damagePerLevel: 4,
                    damageMultPerLevel: 0.06,
                    fireRatePerLevel: -10,
                    projectilesPerLevel: 1.0,  // +1 projectile every level
                    spreadPerLevel: 0.05,
                    speedPerLevel: 0.02
                },
                variants: ['Storm', 'Tempest', 'Maelstrom']
            }
        };

        // Maximum weapon level
        const MAX_WEAPON_LEVEL = 10;

        // Weapon quality modifiers (applied on top of level)
        const WEAPON_QUALITIES = {
            poor: { namePre: 'Worn', statMult: 0.8, costMult: 0.6 },
            common: { namePre: '', statMult: 1.0, costMult: 1.0 },
            good: { namePre: 'Refined', statMult: 1.1, costMult: 1.4 },
            excellent: { namePre: 'Superior', statMult: 1.2, costMult: 2.0 },
            legendary: { namePre: 'Legendary', statMult: 1.35, costMult: 3.5 }
        };

        // Calculate weapon stats based on level and template
        function calculateWeaponStats(template, level, quality) {
            const q = WEAPON_QUALITIES[quality];
            const s = template.scaling;
            const lvl = level - 1;  // Level 1 = base stats

            // Calculate each stat with level scaling
            let damage = template.baseDamage;
            damage += s.damagePerLevel * lvl;
            damage *= (1 + s.damageMultPerLevel * lvl);
            damage *= q.statMult;

            let fireRate = template.baseFireRate;
            fireRate += s.fireRatePerLevel * lvl;
            fireRate = Math.max(50, fireRate);  // Minimum 50ms fire rate

            let projectiles = template.baseProjectiles;
            projectiles += Math.floor(s.projectilesPerLevel * lvl);

            let spread = template.baseSpread;
            spread += s.spreadPerLevel * lvl;
            spread = Math.max(0, spread);  // Can't go negative

            let speed = template.baseSpeed;
            speed += s.speedPerLevel * lvl;

            let cost = template.baseCost;
            cost *= (1 + (level - 1) * 0.5);  // 50% more per level
            cost *= q.costMult;

            return {
                damage: Math.round(damage),
                fireRate: Math.round(fireRate),
                projectiles: Math.max(1, projectiles),
                spread: Math.round(spread * 100) / 100,
                speed: Math.round(speed * 100) / 100,
                cost: Math.round(cost)
            };
        }

        // Generate a random weapon based on zone level
        function generateWeapon(zoneLevel, maxSize = 'assault') {
            // Determine available sizes based on maxSize
            const maxSizeIdx = WEAPON_SIZE_ORDER[maxSize];
            const availableSizes = WEAPON_SIZES.filter(s => WEAPON_SIZE_ORDER[s] <= maxSizeIdx);

            // Higher zones unlock heavier weapons
            const sizeWeights = availableSizes.map((size) => {
                const sizeIdx = WEAPON_SIZE_ORDER[size];
                if (sizeIdx > Math.floor(zoneLevel / 2)) return 0.1;
                return 1.0;
            });
            const totalWeight = sizeWeights.reduce((a, b) => a + b, 0);
            let roll = Math.random() * totalWeight;
            let selectedSize = availableSizes[0];
            for (let i = 0; i < availableSizes.length; i++) {
                roll -= sizeWeights[i];
                if (roll <= 0) {
                    selectedSize = availableSizes[i];
                    break;
                }
            }

            // Get templates for this size
            const sizeTemplates = Object.entries(WEAPON_TEMPLATES)
                .filter(([_, t]) => t.size === selectedSize);
            const [templateId, template] = sizeTemplates[Math.floor(Math.random() * sizeTemplates.length)];

            // Determine weapon level based on zone (with some randomness)
            // Zone 1: levels 1-2, Zone 5: levels 3-6, Zone 10: levels 7-10
            const minLevel = Math.max(1, Math.floor(zoneLevel * 0.6));
            const maxLevel = Math.min(MAX_WEAPON_LEVEL, Math.ceil(zoneLevel * 1.2) + 1);
            const weaponLevel = minLevel + Math.floor(Math.random() * (maxLevel - minLevel + 1));

            // Determine quality (higher zones = better quality chance)
            const qualityRoll = Math.random() + (zoneLevel * 0.03) + (weaponLevel * 0.02);
            let quality;
            if (qualityRoll < 0.25) quality = 'poor';
            else if (qualityRoll < 0.55) quality = 'common';
            else if (qualityRoll < 0.8) quality = 'good';
            else if (qualityRoll < 0.95) quality = 'excellent';
            else quality = 'legendary';

            // Calculate stats
            const stats = calculateWeaponStats(template, weaponLevel, quality);
            const q = WEAPON_QUALITIES[quality];

            // Generate weapon name with variant and level
            const variant = template.variants[Math.floor(Math.random() * template.variants.length)];
            let weaponName = template.baseName;
            if (q.namePre) weaponName = `${q.namePre} ${weaponName}`;
            weaponName = `${weaponName} ${variant}-${weaponLevel}`;

            // Generate unique ID
            const weaponId = `${templateId}_L${weaponLevel}_${Date.now()}_${Math.floor(Math.random() * 10000)}`;

            return {
                id: weaponId,
                templateId: templateId,
                name: weaponName,
                desc: generateWeaponDesc(template, stats, weaponLevel),
                type: template.type,
                size: template.size,
                level: weaponLevel,
                damage: stats.damage,
                fireRate: stats.fireRate,
                spread: stats.spread,
                projectiles: stats.projectiles,
                speed: stats.speed,
                cost: stats.cost,
                quality: quality
            };
        }

        // Generate weapon description
        function generateWeaponDesc(template, stats, level) {
            const typeDesc = WEAPON_TYPES[template.type].name;
            const sizeDesc = template.size.charAt(0).toUpperCase() + template.size.slice(1);
            let desc = `Lv.${level} ${sizeDesc} ${typeDesc}. `;
            if (stats.projectiles > 1) {
                desc += `${stats.projectiles} projectiles. `;
            }
            if (template.type === 'beam') {
                desc += `Width: ${stats.spread.toFixed(1)}. `;
            }
            return desc.trim();
        }

        // Generate station weapons (3 weapons, one on sale)
        function generateStationWeapons(zoneLevel, maxSize = 'assault') {
            const weapons = [];
            for (let i = 0; i < 3; i++) {
                weapons.push(generateWeapon(zoneLevel, maxSize));
            }

            // Mark one random weapon as on sale (50% off)
            const saleIndex = Math.floor(Math.random() * 3);
            weapons[saleIndex].onSale = true;
            weapons[saleIndex].originalCost = weapons[saleIndex].cost;
            weapons[saleIndex].cost = Math.floor(weapons[saleIndex].cost * 0.5);

            return weapons;
        }

        // Ship definitions with hardpoints
        const SHIP_DEFINITIONS = {
            starter: {
                name: 'Scout',
                model: 'Bob',
                hardpoints: [
                    { size: 'light', position: { x: -0.3, y: 0.3 }, equipped: null },
                    { size: 'medium', position: { x: 0.3, y: 0.3 }, equipped: null }
                ]
            }
        };

        // Get player's heaviest hardpoint across fleet
        function getPlayerMaxHardpointSize() {
            if (!gameState.fleet || gameState.fleet.length === 0) {
                return 'medium'; // Default for starter ship
            }

            let maxSize = 'light';
            gameState.fleet.forEach(ship => {
                ship.hardpoints.forEach(hp => {
                    if (WEAPON_SIZE_ORDER[hp.size] > WEAPON_SIZE_ORDER[maxSize]) {
                        maxSize = hp.size;
                    }
                });
            });
            return maxSize;
        }

        // Check if weapon can mount on hardpoint
        function canMountWeapon(weapon, hardpoint) {
            return WEAPON_SIZE_ORDER[weapon.size] <= WEAPON_SIZE_ORDER[hardpoint.size];
        }

        // Legacy weapon definitions (for backward compatibility with owned weapons)
        const WEAPONS = {
            basic: {
                id: 'basic',
                name: 'Pulse Cannon Mk-1',
                desc: 'Lv.1 Light Projectile. Standard issue.',
                type: 'bullet',
                size: 'light',
                level: 1,
                damage: 8,
                fireRate: 300,
                spread: 0,
                projectiles: 1,
                speed: 0.35,
                cost: 0,
                quality: 'common'
            }
        };

        // Station types for level signatures
        const STATION_TYPES = ['Trade', 'Armory', 'Repair', 'Fuel'];

        // Generate a random level configuration
        function generateLevelConfig(levelNum) {
            // Difficulty scales with level
            const baseDifficulty = Math.min(levelNum, 10);

            // Random number of waves (2-6, scaling with level)
            const minWaves = Math.min(2 + Math.floor(levelNum / 3), 4);
            const maxWaves = Math.min(3 + Math.floor(levelNum / 2), 7);
            const waveCount = minWaves + Math.floor(Math.random() * (maxWaves - minWaves + 1));

            // Enemy strength: Low, Medium, High, Extreme
            const strengthRoll = Math.random() + (levelNum * 0.05);
            let threatLevel, threatClass;
            if (strengthRoll < 0.3) {
                threatLevel = 'Low';
                threatClass = 'safe';
            } else if (strengthRoll < 0.6) {
                threatLevel = 'Medium';
                threatClass = 'medium';
            } else if (strengthRoll < 0.85) {
                threatLevel = 'High';
                threatClass = 'danger';
            } else {
                threatLevel = 'Extreme';
                threatClass = 'danger';
            }

            // Enemy multiplier based on threat
            const enemyMultiplier = { 'Low': 0.7, 'Medium': 1.0, 'High': 1.3, 'Extreme': 1.6 }[threatLevel];

            // Stations (0-2, random types)
            // Level 1 always gets an Armory station for the outfitter
            const stations = [];
            if (levelNum === 1) {
                stations.push('Armory');
            } else {
                const stationCount = Math.floor(Math.random() * 3);
                for (let i = 0; i < stationCount; i++) {
                    stations.push(STATION_TYPES[Math.floor(Math.random() * STATION_TYPES.length)]);
                }
            }

            // Format stations for display
            let stationDisplay = 'None';
            if (stations.length > 0) {
                const stationCounts = {};
                stations.forEach(s => stationCounts[s] = (stationCounts[s] || 0) + 1);
                stationDisplay = Object.entries(stationCounts)
                    .map(([type, count]) => count > 1 ? `${count} ${type}` : type)
                    .join(', ');
            }

            // Calculate which waves should have stations after them
            // Distribute stations evenly through the level
            const stationWaves = [];
            if (stations.length > 0) {
                const interval = Math.floor(waveCount / (stations.length + 1));
                for (let i = 0; i < stations.length; i++) {
                    stationWaves.push(interval * (i + 1));
                }
            }

            return {
                waveCount,
                threatLevel,
                threatClass,
                enemyMultiplier,
                stations,
                stationWaves,  // Which wave numbers trigger station spawns
                stationDisplay,
                levelNum
            };
        }

        // Background meshes for crossfade (A=current, B=transition target, C=next zone)
        let backgroundMeshA = null;
        let backgroundMeshB = null;
        let backgroundMaterialA = null;
        let backgroundMaterialB = null;

        // Initialize resources
        function initResources() {
            gameState.resources = {};
            Object.keys(RESOURCES).forEach(r => gameState.resources[r] = 0);
        }

        // Main game canvas and engine
        const canvas = document.getElementById('renderCanvas');

        // Enable high DPI rendering for crisp visuals on retina displays
        const devicePixelRatio = window.devicePixelRatio || 1;
        const engine = new BABYLON.Engine(canvas, true, {
            preserveDrawingBuffer: true,
            stencil: true,
            antialias: true,
            premultipliedAlpha: false // Fix alpha blending artifacts on mobile
        });

        // Set hardware scaling to match device pixel ratio for crisp rendering
        engine.setHardwareScalingLevel(1 / devicePixelRatio);

        // Game dimensions
        let gameWidth, gameHeight, orthoHeight = 10, orthoWidth;

        function updateGameDimensions() {
            gameWidth = engine.getRenderWidth();
            gameHeight = engine.getRenderHeight();
            const aspect = gameWidth / gameHeight;
            orthoWidth = orthoHeight * aspect;
        }

        // Main game scene
        let scene, playerShip, playerShipMesh;
        let materials = {};

        function createMainScene() {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.02, 0.02, 0.08, 1);

            const camera = new BABYLON.FreeCamera('camera', new BABYLON.Vector3(0, 0, -10), scene);
            camera.setTarget(new BABYLON.Vector3(0, 0, 0));
            camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;

            function updateCamera() {
                updateGameDimensions();
                const aspect = gameWidth / gameHeight;
                camera.orthoTop = orthoHeight;
                camera.orthoBottom = -orthoHeight;
                camera.orthoLeft = -orthoHeight * aspect;
                camera.orthoRight = orthoHeight * aspect;
            }
            updateCamera();
            window.addEventListener('resize', updateCamera);

            const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, -1), scene);
            light.intensity = 1.0;
            const light2 = new BABYLON.DirectionalLight('light2', new BABYLON.Vector3(0, 0, -1), scene);
            light2.intensity = 0.8;

            // GlowLayer for suns, bullets, and explosions - whitelisted meshes
            sunGlowLayer = new BABYLON.GlowLayer('sunGlow', scene, {
                mainTextureFixedSize: 512,
                blurKernelSize: 24 // Tighter glow
            });
            sunGlowLayer.intensity = 0.7; // Reduced intensity

            // Separate glow layer for loot with subtle glow
            lootGlowLayer = new BABYLON.GlowLayer('lootGlow', scene, {
                mainTextureFixedSize: 256,
                blurKernelSize: 16
            });
            lootGlowLayer.intensity = 0.4;

            // DefaultRenderingPipeline for global bloom
            renderPipeline = new BABYLON.DefaultRenderingPipeline(
                'defaultPipeline',
                true,
                scene,
                [camera]
            );
            renderPipeline.bloomEnabled = true;
            renderPipeline.bloomKernel = 24; // Tighter bloom
            renderPipeline.bloomWeight = 0.25; // Subtle bloom
            renderPipeline.bloomThreshold = 0.7; // Higher threshold
            renderPipeline.bloomScale = 0.5;
            renderPipeline.imageProcessingEnabled = true;
            renderPipeline.imageProcessing.contrast = 1.1;
            renderPipeline.imageProcessing.exposure = 1.0;

            // Dynamic sun light - will be updated based on nearest sun
            const sunLight = new BABYLON.DirectionalLight('sunLight', new BABYLON.Vector3(0, -1, 0.5), scene);
            sunLight.intensity = 0;
            sunLight.diffuse = new BABYLON.Color3(1, 1, 1);
            sunLight.specular = new BABYLON.Color3(0.5, 0.5, 0.5);
            gameState.sunLight = sunLight;

            materials.playerBullet = new BABYLON.StandardMaterial('playerBulletMat', scene);
            materials.playerBullet.emissiveColor = new BABYLON.Color3(0, 1, 0.5);

            materials.enemyBullet = new BABYLON.StandardMaterial('enemyBulletMat', scene);
            materials.enemyBullet.emissiveColor = new BABYLON.Color3(1, 0.5, 0);

            // Create scrolling backgrounds for zone transitions
            createBackgrounds();

            return scene;
        }

        // Get background texture path for a zone
        function getBackgroundPath(zoneIndex) {
            const zone = SPACE_ZONES[zoneIndex % SPACE_ZONES.length];
            const variant = Math.floor(Math.random() * zone.variants) + 1;
            const variantStr = variant.toString().padStart(2, '0');
            return `assets/SBS - Seamless Space Backgrounds - Small 512x512/Small 512x512/${zone.folder}/${zone.prefix}_${variantStr}-512x512.png`;
        }

        // Create background meshes
        function createBackgrounds() {
            const bgSize = Math.max(orthoWidth, orthoHeight) * 3;

            // Background A (current)
            backgroundMeshA = BABYLON.MeshBuilder.CreatePlane('backgroundA', { width: bgSize, height: bgSize * 2 }, scene);
            backgroundMeshA.position.z = 5; // Far behind everything
            backgroundMeshA.position.y = 0;

            backgroundMaterialA = new BABYLON.StandardMaterial('bgMatA', scene);
            const textureA = new BABYLON.Texture(getBackgroundPath(0), scene);
            textureA.uScale = bgSize / 20;
            textureA.vScale = bgSize * 2 / 20;
            textureA.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;
            textureA.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;
            backgroundMaterialA.diffuseTexture = textureA;
            backgroundMaterialA.emissiveTexture = textureA;
            backgroundMaterialA.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            backgroundMaterialA.disableLighting = true;
            backgroundMaterialA.backFaceCulling = false;
            backgroundMeshA.material = backgroundMaterialA;
            backgroundMeshA.renderingGroupId = 0;

            // Background B (for transitions)
            backgroundMeshB = BABYLON.MeshBuilder.CreatePlane('backgroundB', { width: bgSize, height: bgSize * 2 }, scene);
            backgroundMeshB.position.z = 4.9; // Slightly in front of A
            backgroundMeshB.position.y = 0;
            backgroundMeshB.renderingGroupId = 0;

            backgroundMaterialB = new BABYLON.StandardMaterial('bgMatB', scene);
            backgroundMaterialB.diffuseColor = new BABYLON.Color3(0, 0, 0);
            backgroundMaterialB.emissiveColor = new BABYLON.Color3(0, 0, 0);
            backgroundMaterialB.disableLighting = true;
            backgroundMaterialB.backFaceCulling = false;
            backgroundMaterialB.alpha = 0;
            backgroundMeshB.material = backgroundMaterialB;
        }

        // Get starfield texture path
        function getStarfieldPath() {
            const variant = Math.floor(Math.random() * STARFIELD_ZONE.variants) + 1;
            const variantStr = variant.toString().padStart(2, '0');
            return `assets/SBS - Seamless Space Backgrounds - Small 512x512/Small 512x512/${STARFIELD_ZONE.folder}/${STARFIELD_ZONE.prefix}_${variantStr}-512x512.png`;
        }

        // Load texture into background B for transition
        function loadTransitionTexture(path) {
            const bgSize = Math.max(orthoWidth, orthoHeight) * 3;
            const texture = new BABYLON.Texture(path, scene);
            texture.uScale = bgSize / 20;
            texture.vScale = bgSize * 2 / 20;
            texture.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;
            texture.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;
            // Match current scroll offset
            if (backgroundMaterialA.diffuseTexture) {
                texture.vOffset = backgroundMaterialA.diffuseTexture.vOffset;
            }

            if (backgroundMaterialB.diffuseTexture) {
                backgroundMaterialB.diffuseTexture.dispose();
            }
            backgroundMaterialB.diffuseTexture = texture;
            backgroundMaterialB.emissiveTexture = texture;
            backgroundMaterialB.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
        }

        // Start transition to next zone (via starfield)
        function startZoneTransition() {
            if (gameState.transitionPhase !== 0) return;

            // Phase 1: Fade to starfield
            gameState.transitionPhase = 1;
            gameState.backgroundTransition = 0;
            loadTransitionTexture(getStarfieldPath());
        }

        // Update backgrounds (scrolling and transitions)
        function updateBackgrounds(scrollMultiplier, deltaTime) {
            if (!backgroundMeshA || !backgroundMeshB) return;

            // Track distance traveled based on scroll
            const scrollAmount = 0.015 * settings.scrollSpeed * (0.5 + scrollMultiplier);
            gameState.distanceTraveled += scrollAmount * deltaTime * 0.1;

            // Scroll both backgrounds
            // Very slow background scroll for ambient effect
            const scrollSpeed = 0.00005 * settings.scrollSpeed;
            if (backgroundMaterialA.diffuseTexture) {
                backgroundMaterialA.diffuseTexture.vOffset += scrollSpeed * deltaTime;
            }
            if (backgroundMaterialB.diffuseTexture && backgroundMaterialB.alpha > 0) {
                backgroundMaterialB.diffuseTexture.vOffset += scrollSpeed * deltaTime;
            }

            // Background transitions only happen when entering a new level through warp gates
            // (handled in startNewLevel -> changeToNewZone)
            // No automatic distance-based transitions within a level

            // Handle transition animation
            if (gameState.transitionPhase > 0) {
                gameState.backgroundTransition += deltaTime / 2000; // 2 second per phase

                backgroundMaterialB.alpha = Math.min(1, gameState.backgroundTransition);

                if (gameState.backgroundTransition >= 1) {
                    // Phase complete - swap backgrounds
                    const tempTexture = backgroundMaterialA.diffuseTexture;
                    backgroundMaterialA.diffuseTexture = backgroundMaterialB.diffuseTexture;
                    backgroundMaterialA.emissiveTexture = backgroundMaterialB.diffuseTexture;
                    backgroundMaterialB.diffuseTexture = null;
                    backgroundMaterialB.emissiveTexture = null;
                    backgroundMaterialB.alpha = 0;
                    if (tempTexture) tempTexture.dispose();

                    gameState.backgroundTransition = 0;

                    if (gameState.transitionPhase === 1) {
                        // Phase 1 complete (now showing starfield), start phase 2
                        gameState.transitionPhase = 2;
                        const nextZone = (gameState.currentZone + 1) % SPACE_ZONES.length;
                        loadTransitionTexture(getBackgroundPath(nextZone));
                    } else {
                        // Phase 2 complete (now showing next zone)
                        gameState.currentZone = (gameState.currentZone + 1) % SPACE_ZONES.length;
                        gameState.distanceTraveled = 0;
                        gameState.transitionPhase = 0;
                    }
                }
            }
        }

        // Show collection notification as icon at top
        function showResourceCollection(resourceType, amount) {
            // Batch notifications for the same resource
            if (!gameState.pendingNotifications[resourceType]) {
                gameState.pendingNotifications[resourceType] = {
                    amount: 0,
                    timeout: null
                };
            }

            gameState.pendingNotifications[resourceType].amount += amount;

            // Clear existing timeout and set a new one
            if (gameState.pendingNotifications[resourceType].timeout) {
                clearTimeout(gameState.pendingNotifications[resourceType].timeout);
            }

            // Show notification after small delay to batch rapid collections
            gameState.pendingNotifications[resourceType].timeout = setTimeout(() => {
                const totalAmount = gameState.pendingNotifications[resourceType].amount;
                delete gameState.pendingNotifications[resourceType];

                const container = document.getElementById('collectNotifications');
                const resourceInfo = RESOURCES[resourceType];

                const notif = document.createElement('div');
                notif.className = 'collect-notif';
                notif.innerHTML = `
                    <div class="symbol" style="background: ${resourceInfo.color}">${resourceInfo.symbol}</div>
                    <span class="amount">x${totalAmount}</span>
                `;
                container.appendChild(notif);

                setTimeout(() => notif.remove(), 2000);
            }, 100);
        }

        // Create explosion effect
        function createExplosion(x, y, size = 'small', color = 'orange') {
            if (!scene) return;

            const isLarge = size === 'large';
            const particleCount = isLarge ? 30 : 12;
            const explosionSize = isLarge ? 0.8 : 0.3;
            const duration = isLarge ? 600 : 300;

            const particles = [];
            const colors = {
                orange: { r: 1, g: 0.5, b: 0 },
                red: { r: 1, g: 0.2, b: 0.1 },
                blue: { r: 0.3, g: 0.5, b: 1 },
                yellow: { r: 1, g: 0.8, b: 0.2 },
                green: { r: 0.3, g: 1, b: 0.5 }
            };
            const baseColor = colors[color] || colors.orange;

            for (let i = 0; i < particleCount; i++) {
                const particle = BABYLON.MeshBuilder.CreateSphere('explosionParticle', {
                    diameter: explosionSize * (0.3 + Math.random() * 0.7)
                }, scene);

                particle.position.x = x;
                particle.position.y = y;
                particle.position.z = -0.1;

                const angle = Math.random() * Math.PI * 2;
                const speed = (isLarge ? 0.15 : 0.08) * (0.5 + Math.random());
                particle.velocityX = Math.cos(angle) * speed;
                particle.velocityY = Math.sin(angle) * speed;

                const mat = new BABYLON.StandardMaterial('explosionMat' + i, scene);
                const colorVariation = 0.8 + Math.random() * 0.4;
                mat.emissiveColor = new BABYLON.Color3(
                    baseColor.r * colorVariation,
                    baseColor.g * colorVariation,
                    baseColor.b * colorVariation
                );
                mat.disableLighting = true;
                particle.material = mat;

                // Add explosion particles to GlowLayer for dramatic glow effect
                if (sunGlowLayer) {
                    sunGlowLayer.addIncludedOnlyMesh(particle);
                }

                particle.renderingGroupId = 2;
                particle.startTime = performance.now();
                particle.duration = duration * (0.7 + Math.random() * 0.6);
                particles.push(particle);
            }

            const animateExplosion = () => {
                const now = performance.now();
                let allDone = true;

                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    const elapsed = now - p.startTime;
                    const progress = elapsed / p.duration;

                    if (progress >= 1) {
                        p.dispose();
                        particles.splice(i, 1);
                    } else {
                        allDone = false;
                        p.position.x += p.velocityX;
                        p.position.y += p.velocityY;
                        p.velocityX *= 0.95;
                        p.velocityY *= 0.95;
                        const scale = 1 - progress * 0.5;
                        p.scaling.setAll(scale);
                        if (p.material) p.material.alpha = 1 - progress;
                    }
                }

                if (!allDone) requestAnimationFrame(animateExplosion);
            };

            requestAnimationFrame(animateExplosion);
        }

        // Flash effect for ships when hit
        function flashShip(meshOrNode, duration = 150) {
            if (!meshOrNode) return;

            const meshes = meshOrNode.getChildMeshes ? meshOrNode.getChildMeshes() : [meshOrNode];
            const originalColors = [];

            meshes.forEach((mesh, i) => {
                if (mesh.material) {
                    originalColors[i] = mesh.material.emissiveColor.clone();
                    mesh.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
                }
            });

            setTimeout(() => {
                meshes.forEach((mesh, i) => {
                    if (mesh.material && originalColors[i]) {
                        mesh.material.emissiveColor = originalColors[i];
                    }
                });
            }, duration);
        }

        // Create loot drop when enemy dies (now gives resources)
        function createLoot(x, y, enemyType) {
            if (!scene) return;

            // Enemies drop ship materials
            const enemyResources = ['Iron', 'Copper', 'Titanium', 'Silicon'];
            // Loot based on enemy type: heavy drops most, light drops least
            let pieceCount;
            switch (enemyType) {
                case 'heavy': pieceCount = 4; break;
                case 'shooter': pieceCount = 3; break;
                case 'basic': pieceCount = 2; break;
                case 'light': pieceCount = 1; break;
                case 'fast': pieceCount = 1; break;
                default: pieceCount = 2;
            }

            for (let i = 0; i < pieceCount; i++) {
                // Assign a resource type and amount first (to determine size)
                const resourceType = enemyResources[Math.floor(Math.random() * enemyResources.length)];
                const resourceInfo = RESOURCES[resourceType];
                const resourceAmount = Math.floor(Math.random() * 3) + 1;

                // Size varies by quantity: 1=small, 2=medium, 3=large
                const baseSize = 0.22;
                const sizeBonus = resourceAmount * 0.06;
                const size = baseSize + sizeBonus + Math.random() * 0.04;

                // Tech crate cube
                const lootMesh = BABYLON.MeshBuilder.CreateBox('loot', { size: size }, scene);

                const offsetX = (Math.random() - 0.5) * 1.5;
                const offsetY = (Math.random() - 0.5) * 1.5;
                lootMesh.position.x = x + offsetX;
                lootMesh.position.y = y + offsetY;
                lootMesh.position.z = -0.15;
                lootMesh.renderingGroupId = 2;

                lootMesh.rotation.x = Math.random() * Math.PI * 2;
                lootMesh.rotation.y = Math.random() * Math.PI * 2;
                lootMesh.rotation.z = Math.random() * Math.PI * 2;

                // Parse hex color
                const hex = resourceInfo.color;
                const r = parseInt(hex.slice(1,3), 16) / 255;
                const g = parseInt(hex.slice(3,5), 16) / 255;
                const b = parseInt(hex.slice(5,7), 16) / 255;

                // Metal texture for base appearance
                const metalTex = new BABYLON.Texture('assets/stellar objects/metal_texture_small.jpg', scene);
                metalTex.uScale = 1;
                metalTex.vScale = 1;

                // Reflective metallic material colored by composition (no glow)
                const lootMat = new BABYLON.StandardMaterial('lootMat', scene);
                lootMat.diffuseTexture = metalTex;
                lootMat.diffuseColor = new BABYLON.Color3(0.4 + r * 0.5, 0.4 + g * 0.5, 0.4 + b * 0.5);
                lootMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.9);
                lootMat.specularPower = 16;
                lootMesh.material = lootMat;

                lootMesh.velocityX = offsetX * 0.02;
                lootMesh.velocityY = offsetY * 0.02;
                lootMesh.rotSpeed = (Math.random() - 0.5) * 0.06;
                lootMesh.pulsePhase = Math.random() * Math.PI * 2;
                lootMesh.baseColor = { r, g, b };
                lootMesh.resourceType = resourceType;
                lootMesh.resourceAmount = resourceAmount;
                lootMesh.spawnTime = performance.now();
                lootMesh.lootMat = lootMat;
                lootMesh.metalTex = metalTex;

                gameState.loot.push(lootMesh);
            }
        }

        // Update loot
        function updateLoot(scrollMultiplier) {
            if (!playerShip) return;

            const now = performance.now();

            for (let i = gameState.loot.length - 1; i >= 0; i--) {
                const loot = gameState.loot[i];

                loot.velocityX *= 0.98;
                loot.velocityY *= 0.98;

                loot.position.x += loot.velocityX;
                loot.position.y += loot.velocityY - 0.02 * settings.scrollSpeed * (0.5 + scrollMultiplier);

                // Slower, more subtle rotation
                loot.rotation.x += loot.rotSpeed * 0.5;
                loot.rotation.y += loot.rotSpeed * 0.8;
                loot.rotation.z += loot.rotSpeed * 0.3;

                const dx = loot.position.x - playerShip.position.x;
                const dy = loot.position.y - playerShip.position.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 1.2) {
                    // Collect resource (no notification for enemy loot, only planets)
                    gameState.resources[loot.resourceType] += loot.resourceAmount;
                    gameState.score += loot.resourceAmount * 5;
                    updateHUD();

                    createExplosion(loot.position.x, loot.position.y, 'small', 'blue');

                    if (loot.metalTex) loot.metalTex.dispose();
                    loot.dispose();
                    gameState.loot.splice(i, 1);
                    continue;
                }

                if (loot.position.y < -orthoHeight - 2) {
                    if (loot.metalTex) loot.metalTex.dispose();
                    loot.dispose();
                    gameState.loot.splice(i, 1);
                }
            }
        }

        // Global glow layer for suns (initialized in setupScene)
        let sunGlowLayer = null;
        let lootGlowLayer = null;
        let renderPipeline = null;

        // Create a radial gradient texture for sun corona (circular glow)
        function createCoronaTexture(tint, size = 256) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Create radial gradient from center (opaque) to edge (transparent)
            const centerX = size / 2;
            const centerY = size / 2;
            const radius = size / 2;

            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
            gradient.addColorStop(0, `rgba(${Math.floor(tint[0]*255)}, ${Math.floor(tint[1]*255)}, ${Math.floor(tint[2]*255)}, 0.6)`);
            gradient.addColorStop(0.3, `rgba(${Math.floor(tint[0]*255)}, ${Math.floor(tint[1]*255)}, ${Math.floor(tint[2]*255)}, 0.3)`);
            gradient.addColorStop(0.6, `rgba(${Math.floor(tint[0]*255)}, ${Math.floor(tint[1]*255)}, ${Math.floor(tint[2]*255)}, 0.1)`);
            gradient.addColorStop(1, `rgba(${Math.floor(tint[0]*255)}, ${Math.floor(tint[1]*255)}, ${Math.floor(tint[2]*255)}, 0)`);

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);

            const texture = new BABYLON.DynamicTexture('coronaTexture', canvas, scene, false);
            texture.hasAlpha = true;
            return texture;
        }

        // Create a sun with smooth radial corona glow
        function createSun(x, y) {
            if (!scene) return null;

            const sunTypeKeys = Object.keys(SUN_TYPES);
            const sunTypeKey = sunTypeKeys[Math.floor(Math.random() * sunTypeKeys.length)];
            const sunType = SUN_TYPES[sunTypeKey];

            const variant = Math.floor(Math.random() * 5) + 1;
            const variantStr = variant.toString().padStart(2, '0');
            const imagePath = `assets/Medium Planets 256x256/Suns/${sunType.folder}/${sunType.prefix}_${variantStr}-256x256.png`;

            const sunSize = 4 + Math.random() * 2; // 4-6 units

            // Create parent node for sun + corona
            const sunNode = new BABYLON.TransformNode('sunNode', scene);
            sunNode.position.x = x;
            sunNode.position.y = y;
            sunNode.position.z = 3; // Far behind everything except background

            // Create single corona with radial gradient texture
            const coronaSize = sunSize * 2.5;
            const corona = BABYLON.MeshBuilder.CreatePlane('corona', { size: coronaSize }, scene);
            corona.parent = sunNode;
            corona.position.z = 0.1; // Slightly behind sun

            const coronaTexture = createCoronaTexture(sunType.tint);
            const coronaMat = new BABYLON.StandardMaterial('coronaMat', scene);
            coronaMat.diffuseTexture = coronaTexture;
            coronaMat.emissiveTexture = coronaTexture;
            coronaMat.opacityTexture = coronaTexture;
            coronaMat.useAlphaFromDiffuseTexture = true;
            coronaMat.disableLighting = true;
            coronaMat.backFaceCulling = false;
            coronaMat.disableDepthWrite = true;
            corona.material = coronaMat;
            corona.renderingGroupId = 1;

            sunNode.coronas = [corona];

            // Create the sun mesh
            const sun = BABYLON.MeshBuilder.CreatePlane('sun', { size: sunSize }, scene);
            sun.parent = sunNode;
            sun.position.z = 0;

            const texture = new BABYLON.Texture(imagePath, scene);
            texture.hasAlpha = true;

            const mat = new BABYLON.StandardMaterial('sunMat', scene);
            mat.diffuseTexture = texture;
            mat.emissiveTexture = texture;
            mat.emissiveColor = new BABYLON.Color3(
                sunType.tint[0],
                sunType.tint[1],
                sunType.tint[2]
            );
            mat.useAlphaFromDiffuseTexture = true;
            mat.backFaceCulling = false;
            mat.disableLighting = true;
            mat.disableDepthWrite = true;
            sun.material = mat;
            sun.renderingGroupId = 1;

            sunNode.size = sunSize;
            sunNode.glowSize = sunSize * 4;
            sunNode.isSun = true;
            sunNode.tint = sunType.tint;
            sunNode.sunMesh = sun;

            return sunNode;
        }

        // Create a planet at specific position
        function createPlanetAt(x, y) {
            if (!scene) return null;

            const typeKeys = Object.keys(PLANET_TYPES);
            const typeKey = typeKeys[Math.floor(Math.random() * typeKeys.length)];
            const planetType = PLANET_TYPES[typeKey];

            const variant = Math.floor(Math.random() * 5) + 1;
            const variantStr = variant.toString().padStart(2, '0');
            const imagePath = `assets/Medium Planets 256x256/${planetType.category}/${planetType.folder}/${planetType.prefix}_${variantStr}-256x256.png`;

            const planetSize = 2 + Math.random() * 1.5; // 2-3.5 units

            const planet = BABYLON.MeshBuilder.CreatePlane('planet', { size: planetSize }, scene);
            planet.position.x = x;
            planet.position.y = y;
            planet.position.z = 0.5;

            const texture = new BABYLON.Texture(imagePath, scene);
            texture.hasAlpha = true;

            const mat = new BABYLON.StandardMaterial('planetMat', scene);
            mat.diffuseTexture = texture;
            mat.emissiveTexture = texture;
            mat.emissiveColor = new BABYLON.Color3(
                planetType.tint[0] * 0.3,
                planetType.tint[1] * 0.3,
                planetType.tint[2] * 0.3
            );
            mat.useAlphaFromDiffuseTexture = true;
            mat.backFaceCulling = false;
            mat.disableLighting = true;
            // Disable depth writing so ships/bullets render on top
            mat.disableDepthWrite = true;
            planet.material = mat;

            // Render in group 1 (after background, before game objects)
            planet.renderingGroupId = 1;

            planet.planetType = typeKey;
            planet.planetData = planetType;
            planet.harvestsRemaining = planetType.harvests;
            planet.size = planetSize;
            planet.harvestRadius = planetSize * 0.8;

            // Richness affects loot multiplier (1-5 scale)
            planet.richness = Math.floor(Math.random() * 5) + 1;
            // Hazardousness affects harvest time (1-5 scale, higher = longer)
            planet.hazard = Math.floor(Math.random() * 5) + 1;
            // Base harvest time is 4 seconds, hazard adds 1s per level
            planet.harvestTime = 3000 + planet.hazard * 1000; // 4s to 8s

            return planet;
        }

        // Create a solar system (sun with orbiting planets)
        function createSolarSystem() {
            if (!scene) return;

            // Center of solar system - no gate avoidance needed
            // Reward zone spawns systems BEFORE gates exist
            const centerX = (Math.random() - 0.5) * (orthoWidth * 1.2);
            const centerY = orthoHeight + 8; // Start above screen

            // Create sun at center
            const sun = createSun(centerX, centerY);
            if (sun) {
                gameState.suns.push(sun);
            }

            // Create 2-5 planets orbiting the sun
            const planetCount = 2 + Math.floor(Math.random() * 4);
            const minOrbitRadius = sun ? sun.size * 0.8 : 3;

            for (let i = 0; i < planetCount; i++) {
                const orbitRadius = minOrbitRadius + 2 + i * 2 + Math.random() * 1.5;
                const angle = Math.random() * Math.PI * 2;

                const px = centerX + Math.cos(angle) * orbitRadius;
                const py = centerY + Math.sin(angle) * orbitRadius * 0.4; // Flatten orbits

                const planet = createPlanetAt(px, py);
                if (planet) {
                    planet.orbitCenterX = centerX;
                    planet.orbitRadius = orbitRadius;
                    planet.orbitAngle = angle;
                    planet.orbitSpeed = 0.0003 + Math.random() * 0.0002;
                    gameState.planets.push(planet);
                }
            }

            // Schedule next solar system with spacing (screen's worth on average)
            const spacing = orthoHeight * 2 * (0.7 + Math.random() * 0.6); // 0.7-1.3 screens
            gameState.nextSolarSystemY = centerY + spacing;
        }

        // Create starbase
        function createStarbase() {
            if (!scene || gameState.starbase) return;

            const starbaseSize = 2.5; // Smaller than planets
            const starbase = BABYLON.MeshBuilder.CreatePlane('starbase', { size: starbaseSize }, scene);

            starbase.position.x = (Math.random() - 0.5) * orthoWidth;
            starbase.position.y = orthoHeight + starbaseSize;
            starbase.position.z = 0.2; // In front of planets and suns

            const texture = new BABYLON.Texture('assets/stellar objects/starbase.png', scene);
            texture.hasAlpha = true;

            const mat = new BABYLON.StandardMaterial('starbaseMat', scene);
            mat.diffuseTexture = texture;
            mat.emissiveTexture = texture;
            mat.emissiveColor = new BABYLON.Color3(0.4, 0.4, 0.5);
            mat.useAlphaFromDiffuseTexture = true;
            mat.backFaceCulling = false;
            starbase.material = mat;
            starbase.renderingGroupId = 2;

            // Exclude starbase from GlowLayer to prevent bloom washout
            if (sunGlowLayer) {
                sunGlowLayer.addExcludedMesh(starbase);
            }

            starbase.size = starbaseSize;
            starbase.dockRadius = starbaseSize * 0.8;

            gameState.starbase = starbase;
        }

        // Update starbase
        function updateStarbase(scrollMultiplier, deltaTime) {
            if (!gameState.starbase || !playerShip) return;

            const starbase = gameState.starbase;

            // Move starbase down
            starbase.position.y -= 0.015 * settings.scrollSpeed * (0.5 + scrollMultiplier);

            // Slow rotation
            starbase.rotation.z += 0.002;

            // Check distance to player for docking
            const dx = starbase.position.x - playerShip.position.x;
            const dy = starbase.position.y - playerShip.position.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Check if starbase is fully visible
            const fullyVisible = starbase.position.y < (orthoHeight - starbase.size / 2);

            if (fullyVisible && dist < starbase.dockRadius) {
                // Show docking progress using harvest bar
                if (!gameState.harvestingPlanet) {
                    gameState.harvestProgress += deltaTime / 1500; // 1.5 seconds to dock

                    const harvestBar = document.getElementById('harvestBar');
                    const harvestBarFill = document.getElementById('harvestBarFill');
                    harvestBar.style.display = 'block';
                    harvestBarFill.style.width = `${Math.min(100, gameState.harvestProgress * 100)}%`;

                    // Position bar at starbase
                    const screenPos = worldToScreen(starbase.position.x, starbase.position.y);
                    const screenSize = (starbase.size / (orthoHeight * 2)) * canvas.clientHeight;
                    const halfSize = screenSize / 2;
                    const barWidth = screenSize;
                    harvestBar.style.left = (screenPos.x - barWidth / 2) + 'px';
                    harvestBar.style.top = (screenPos.y + halfSize + 8) + 'px';
                    harvestBar.style.width = barWidth + 'px';
                    harvestBar.style.transform = 'none';

                    if (gameState.harvestProgress >= 1) {
                        // Docked!
                        openDockingScreen();
                    }
                }
            } else {
                if (!gameState.harvestingPlanet && gameState.harvestProgress > 0 && !gameState.isDocked) {
                    gameState.harvestProgress = 0;
                    document.getElementById('harvestBar').style.display = 'none';
                }
            }

            // Remove if off screen - spawn next wave
            if (starbase.position.y < -orthoHeight - starbase.size) {
                starbase.dispose();
                gameState.starbase = null;
                spawnWave(); // Spawn next wave
            }
        }

        // Station interior images mapping
        const STATION_INTERIORS = {
            hub: 'assets/interiors/interior_starbase.png',
            bar: 'assets/interiors/interior_bar.png',
            missions: 'assets/interiors/interior_missions.png',
            outfitter: 'assets/interiors/interior_outfitter.png',
            shipyard: 'assets/interiors/interior_shipyard.png',
            trading: 'assets/interiors/interior_trading.png'
        };

        // Station names by type
        const STATION_NAMES = {
            Trade: ['Merchant\'s Haven', 'Trade Hub Alpha', 'Commerce Station', 'The Exchange'],
            Armory: ['Weapons Depot', 'Arsenal Station', 'Military Outpost', 'The Armory'],
            Repair: ['Dry Dock', 'Repair Bay', 'Mechanic\'s Rest', 'Service Station'],
            Fuel: ['Fuel Depot', 'Refueling Station', 'Gas Giant Outpost', 'Energy Hub']
        };

        // Rumors and tips for the bar
        const BAR_RUMORS = [
            { source: 'Grizzled Pilot', text: 'The warp gates with lower threat levels might have less loot, but you\'ll live longer to spend it.' },
            { source: 'Merchant Captain', text: 'I heard the Outfitter in this sector got a shipment of beam lasers. Pricey, but worth every credit.' },
            { source: 'Former Pirate', text: 'Those gas giants are goldmines for hydrogen. Just watch out for the radiation.' },
            { source: 'Station Bartender', text: 'Business has been slow since the raiders moved into the outer sectors.' },
            { source: 'Nervous Trader', text: 'The extreme threat zones... I\'ve seen ships go in. Never seen them come out.' },
            { source: 'Old Spacer', text: 'Back in my day, we didn\'t have fancy tri-shot cannons. Just grit and basic pulse weapons.' },
            { source: 'Dock Worker', text: 'Watch your shields when you\'re near those suns. The radiation will cook you alive.' },
            { source: 'Retired Commander', text: 'The beam laser cuts through multiple enemies in a line. Slow to fire, but devastating.' },
            { source: 'Smuggler', text: 'Ocean planets are swimming in water. Good money if you can harvest it.' },
            { source: 'Mysterious Figure', text: 'There are rumors of ancient alien shipyards in the deep sectors... someday.' }
        ];

        const BAR_TIPS = [
            'Harvest planets by flying close to them. Bigger planets take longer but yield more resources.',
            'Each weapon has different strengths. Rapid Fire is great for swarms, Beam Laser for lines of enemies.',
            'Watch the threat indicator on warp gates - higher threat means more enemies but potentially better rewards.',
            'Station types vary: Armory for weapons, Trade for goods, Repair for your ship, Fuel for... fuel.',
            'Your base shields protect you from escaped enemies. Keep an eye on that bar!',
            'Magma planets can drop Gold - rare and valuable.',
            'The speed-up button (WARP) makes travel faster when there are no enemies around.'
        ];

        // Current station type (set when docking)
        let currentStationType = 'Trade';

        // Open station interior screen
        function openDockingScreen() {
            gameState.isDocked = true;
            gameState.isPaused = true;
            gameState.harvestProgress = 0;
            document.getElementById('harvestBar').style.display = 'none';

            // Determine station type from level config
            if (gameState.levelConfig && gameState.levelConfig.stations.length > 0) {
                const stationIndex = Math.min(gameState.stationsVisited, gameState.levelConfig.stations.length - 1);
                currentStationType = gameState.levelConfig.stations[stationIndex] || 'Trade';
            }

            // Generate weapons for sale at this station
            generateStationInventory();

            updateStationInterior();
            document.getElementById('stationInterior').style.display = 'flex';

            // Switch to bar section by default
            switchStationSection('bar');
        }

        // Update station interior with current state
        function updateStationInterior() {
            // Set station name
            const nameList = STATION_NAMES[currentStationType] || STATION_NAMES.Trade;
            const stationName = nameList[Math.floor(Math.random() * nameList.length)];
            document.getElementById('stationName').textContent = stationName;

            // Set credits
            document.getElementById('creditsDisplay').textContent = gameState.credits;

            // Set hub background image
            document.getElementById('stationHub').style.backgroundImage = `url('${STATION_INTERIORS.hub}')`;

            // Populate bar section with rumors and tips
            populateBarSection();

            // Populate weapons in outfitter
            updateWeaponsList();
        }

        // Populate bar section with random rumors and tips
        function populateBarSection() {
            const rumorsContainer = document.getElementById('barRumors');
            const tipsContainer = document.getElementById('barTips');

            // Pick 2-3 random rumors
            const shuffledRumors = [...BAR_RUMORS].sort(() => Math.random() - 0.5);
            const selectedRumors = shuffledRumors.slice(0, 2 + Math.floor(Math.random() * 2));

            rumorsContainer.innerHTML = selectedRumors.map(rumor => `
                <div class="rumor-item">
                    <div class="rumor-source">${rumor.source}</div>
                    <div class="rumor-text">"${rumor.text}"</div>
                </div>
            `).join('');

            // Pick 1-2 random tips
            const shuffledTips = [...BAR_TIPS].sort(() => Math.random() - 0.5);
            const selectedTips = shuffledTips.slice(0, 1 + Math.floor(Math.random() * 2));

            tipsContainer.innerHTML = selectedTips.map(tip => `
                <div class="tip-item">
                    <div class="tip-label">Pilot Tip</div>
                    <div class="tip-text">${tip}</div>
                </div>
            `).join('');
        }

        // Generate weapons for station when docking
        function generateStationInventory() {
            const zoneLevel = gameState.level || 1;
            const maxSize = getPlayerMaxHardpointSize();
            gameState.stationWeapons = generateStationWeapons(zoneLevel, maxSize);
        }

        // Get quality color class
        function getQualityClass(quality) {
            const classes = {
                poor: 'quality-poor',
                common: 'quality-common',
                good: 'quality-good',
                excellent: 'quality-excellent',
                superior: 'quality-superior'
            };
            return classes[quality] || 'quality-common';
        }

        // Update weapons list in outfitter
        function updateWeaponsList() {
            document.getElementById('creditsDisplay').textContent = gameState.credits;

            const weaponsList = document.getElementById('weaponsList');
            weaponsList.innerHTML = '';

            // First show current ship hardpoints
            const hardpointSection = document.createElement('div');
            hardpointSection.className = 'hardpoint-section';
            hardpointSection.innerHTML = '<h3 style="color: #88ccff; margin: 0 0 10px 0;">Your Ship - Hardpoints</h3>';

            if (gameState.fleet && gameState.fleet.length > 0) {
                const ship = gameState.fleet[0];
                ship.hardpoints.forEach((hp, idx) => {
                    const item = document.createElement('div');
                    item.className = 'upgrade-item hardpoint-slot';
                    const sizeLabel = hp.size.charAt(0).toUpperCase() + hp.size.slice(1);
                    const equippedWeapon = hp.equipped;

                    let weaponInfo = '<span style="color: #666;">Empty</span>';
                    let unequipBtn = '';
                    if (equippedWeapon) {
                        const qClass = getQualityClass(equippedWeapon.quality);
                        const lvl = equippedWeapon.level || 1;
                        const projInfo = equippedWeapon.projectiles > 1 ? ` x${equippedWeapon.projectiles}` : '';
                        weaponInfo = `<span class="${qClass}">${equippedWeapon.name}</span> <span class="weapon-level">Lv.${lvl}</span><br><span style="color: #888; font-size: 11px;">DMG: ${equippedWeapon.damage}${projInfo} | ROF: ${(1000/equippedWeapon.fireRate).toFixed(1)}/s</span>`;
                        unequipBtn = `<button class="upgrade-btn unequip" onclick="unequipWeapon(${idx})">Remove</button>`;
                    }

                    item.innerHTML = `
                        <div class="upgrade-info">
                            <div class="upgrade-name">[${sizeLabel}] Hardpoint ${idx + 1}</div>
                            <div class="upgrade-desc">${weaponInfo}</div>
                        </div>
                        ${unequipBtn}
                    `;
                    hardpointSection.appendChild(item);
                });
            }
            weaponsList.appendChild(hardpointSection);

            // Inventory section - owned weapons not currently equipped
            const inventorySection = document.createElement('div');
            inventorySection.className = 'inventory-section';
            inventorySection.innerHTML = '<h3 style="color: #aaffaa; margin: 15px 0 10px 0;">Inventory</h3>';

            const equippedIds = (gameState.fleet && gameState.fleet[0])
                ? gameState.fleet[0].hardpoints.filter(hp => hp.equipped).map(hp => hp.equipped.id)
                : [];

            const inventoryWeapons = gameState.ownedWeapons.filter(w => !equippedIds.includes(w.id));

            if (inventoryWeapons.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.style.color = '#666';
                emptyMsg.style.padding = '10px';
                emptyMsg.textContent = 'No unequipped weapons';
                inventorySection.appendChild(emptyMsg);
            } else {
                inventoryWeapons.forEach(weapon => {
                    const item = document.createElement('div');
                    const qClass = getQualityClass(weapon.quality);
                    item.className = 'upgrade-item';

                    // Find EMPTY hardpoints this can mount on
                    const compatibleHardpoints = (gameState.fleet && gameState.fleet[0])
                        ? gameState.fleet[0].hardpoints
                            .map((hp, idx) => ({ hp, idx }))
                            .filter(({ hp }) => !hp.equipped && canMountWeapon(weapon, hp))
                            .map(({ idx }) => idx)
                        : [];

                    let mountBtns = compatibleHardpoints.map(idx =>
                        `<button class="upgrade-btn equip" onclick="mountWeapon('${weapon.id}', ${idx})">Mount HP${idx + 1}</button>`
                    ).join(' ');

                    if (compatibleHardpoints.length === 0) {
                        // Check if there are compatible slots but they're full
                        const hasCompatibleSlots = (gameState.fleet && gameState.fleet[0])
                            ? gameState.fleet[0].hardpoints.some(hp => canMountWeapon(weapon, hp))
                            : false;
                        if (hasCompatibleSlots) {
                            mountBtns = '<span style="color: #ffaa44; font-size: 11px;">All compatible hardpoints full</span>';
                        } else {
                            mountBtns = '<span style="color: #ff6666; font-size: 11px;">No compatible hardpoint</span>';
                        }
                    }

                    // Add sell button - sell for 50% of original cost
                    const sellPrice = Math.floor((weapon.originalCost || weapon.cost || 50) * 0.5);
                    const sellBtn = `<button class="upgrade-btn sell" onclick="sellWeapon('${weapon.id}')">Sell ${sellPrice}cr</button>`;

                    const lvl = weapon.level || 1;
                    const projInfo = weapon.projectiles > 1 ? ` x${weapon.projectiles}` : '';
                    const typeLabel = weapon.type.charAt(0).toUpperCase() + weapon.type.slice(1);

                    item.innerHTML = `
                        <div class="upgrade-info">
                            <div class="upgrade-name ${qClass}">${weapon.name} <span class="weapon-level">Lv.${lvl}</span> <span style="color: #888; font-size: 11px;">[${weapon.size}]</span></div>
                            <div class="upgrade-desc">${weapon.desc}</div>
                            <div style="font-size: 11px; color: #aaa;">DMG: ${weapon.damage}${projInfo} | ROF: ${(1000/weapon.fireRate).toFixed(1)}/s | ${typeLabel}</div>
                        </div>
                        <div class="mount-buttons">${mountBtns} ${sellBtn}</div>
                    `;
                    inventorySection.appendChild(item);
                });
            }
            weaponsList.appendChild(inventorySection);

            // Station weapons for sale
            const shopSection = document.createElement('div');
            shopSection.className = 'shop-section';
            shopSection.innerHTML = '<h3 style="color: #ffcc44; margin: 15px 0 10px 0;">Weapons For Sale</h3>';

            if (!gameState.stationWeapons || gameState.stationWeapons.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.style.color = '#666';
                emptyMsg.style.padding = '10px';
                emptyMsg.textContent = 'No weapons available';
                shopSection.appendChild(emptyMsg);
            } else {
                gameState.stationWeapons.forEach((weapon, idx) => {
                    const canAfford = gameState.credits >= weapon.cost;
                    const qClass = getQualityClass(weapon.quality);
                    const lvl = weapon.level || 1;
                    const projInfo = weapon.projectiles > 1 ? ` x${weapon.projectiles}` : '';
                    const typeLabel = weapon.type.charAt(0).toUpperCase() + weapon.type.slice(1);

                    const item = document.createElement('div');
                    item.className = 'upgrade-item' + (weapon.onSale ? ' on-sale' : '');

                    let priceHtml = `${weapon.cost} cr`;
                    if (weapon.onSale) {
                        priceHtml = `<span style="text-decoration: line-through; color: #888;">${weapon.originalCost}</span> <span style="color: #44ff44;">${weapon.cost} cr (50% OFF!)</span>`;
                    }

                    item.innerHTML = `
                        <div class="upgrade-info">
                            <div class="upgrade-name ${qClass}">${weapon.name} <span class="weapon-level">Lv.${lvl}</span> <span style="color: #888; font-size: 11px;">[${weapon.size}]</span></div>
                            <div class="upgrade-desc">${weapon.desc}</div>
                            <div style="font-size: 11px; color: #aaa;">DMG: ${weapon.damage}${projInfo} | ROF: ${(1000/weapon.fireRate).toFixed(1)}/s | ${typeLabel}</div>
                            <div style="font-size: 12px; margin-top: 3px;">${priceHtml}</div>
                        </div>
                        <button class="upgrade-btn buy" ${canAfford ? '' : 'disabled'} onclick="buyStationWeapon(${idx})">Buy</button>
                    `;
                    shopSection.appendChild(item);
                });
            }
            weaponsList.appendChild(shopSection);
        }

        // Switch station section
        function switchStationSection(sectionName) {
            // Update nav buttons
            document.querySelectorAll('.station-nav-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.section === sectionName) {
                    btn.classList.add('active');
                }
            });

            // Update sections
            document.querySelectorAll('.station-section').forEach(section => {
                section.classList.remove('active');
            });

            const sectionId = 'section' + sectionName.charAt(0).toUpperCase() + sectionName.slice(1);
            const section = document.getElementById(sectionId);
            if (section) {
                section.classList.add('active');
            }

            // Update hub background based on section
            const bgImage = STATION_INTERIORS[sectionName] || STATION_INTERIORS.hub;
            document.getElementById('stationHub').style.backgroundImage = `url('${bgImage}')`;
        }

        // Buy weapon from station
        function buyStationWeapon(stationIdx) {
            const weapon = gameState.stationWeapons[stationIdx];
            if (!weapon || gameState.credits < weapon.cost) return;

            gameState.credits -= weapon.cost;
            gameState.ownedWeapons.push(weapon);
            gameState.stationWeapons.splice(stationIdx, 1);  // Remove from station inventory
            updateWeaponsList();
        }

        // Mount weapon to hardpoint
        function mountWeapon(weaponId, hardpointIdx) {
            if (!gameState.fleet || gameState.fleet.length === 0) return;

            const ship = gameState.fleet[0];
            const hardpoint = ship.hardpoints[hardpointIdx];
            const weapon = gameState.ownedWeapons.find(w => w.id === weaponId);

            if (!weapon || !hardpoint) return;
            if (!canMountWeapon(weapon, hardpoint)) return;

            // If hardpoint has a weapon, put it back in inventory (already there since we track by id)
            // Just update the equipped reference
            hardpoint.equipped = weapon;

            // Update equippedWeapons array for firing
            syncEquippedWeapons();
            updateWeaponsList();
        }

        // Unequip weapon from hardpoint
        function unequipWeapon(hardpointIdx) {
            if (!gameState.fleet || gameState.fleet.length === 0) return;

            const ship = gameState.fleet[0];
            const hardpoint = ship.hardpoints[hardpointIdx];

            if (!hardpoint || !hardpoint.equipped) return;

            hardpoint.equipped = null;

            // Update equippedWeapons array for firing
            syncEquippedWeapons();
            updateWeaponsList();
        }

        // Sell weapon from inventory
        function sellWeapon(weaponId) {
            const weaponIdx = gameState.ownedWeapons.findIndex(w => w.id === weaponId);
            if (weaponIdx === -1) return;

            const weapon = gameState.ownedWeapons[weaponIdx];

            // Can't sell if it's equipped
            const isEquipped = gameState.fleet && gameState.fleet[0] &&
                gameState.fleet[0].hardpoints.some(hp => hp.equipped && hp.equipped.id === weaponId);
            if (isEquipped) return;

            // Sell for 50% of cost
            const sellPrice = Math.floor((weapon.originalCost || weapon.cost || 50) * 0.5);
            gameState.credits += sellPrice;

            // Remove from inventory
            gameState.ownedWeapons.splice(weaponIdx, 1);

            updateWeaponsList();
        }

        // Sync equippedWeapons array from fleet hardpoints
        function syncEquippedWeapons() {
            if (!gameState.fleet || gameState.fleet.length === 0) {
                gameState.equippedWeapons = [WEAPONS.basic];
                return;
            }

            const ship = gameState.fleet[0];
            gameState.equippedWeapons = ship.hardpoints.map(hp => hp.equipped);
        }

        // Legacy functions for backward compatibility
        function buyWeapon(weaponId) {
            // Legacy - not used with new system
        }

        function equipWeapon(weaponId) {
            // Legacy - not used with new system
        }

        // Close station interior and depart
        function departStarbase() {
            gameState.isDocked = false;
            gameState.isPaused = false;
            document.getElementById('stationInterior').style.display = 'none';

            // Increment stations visited counter
            gameState.stationsVisited++;

            // Remove starbase
            if (gameState.starbase) {
                gameState.starbase.dispose();
                gameState.starbase = null;
            }

            // Spawn next wave
            spawnWave();

            // Save game after departing
            saveGame();
            showSavedNotification();
        }

        // Initialize station navigation
        function initStationNav() {
            document.querySelectorAll('.station-nav-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const section = btn.dataset.section;
                    if (!btn.classList.contains('disabled')) {
                        switchStationSection(section);
                    }
                });
            });

            // Depart button
            document.getElementById('stationDepartBtn').addEventListener('click', departStarbase);
        }

        // Make functions available globally for onclick
        window.buyWeapon = buyWeapon;
        window.equipWeapon = equipWeapon;
        window.buyStationWeapon = buyStationWeapon;
        window.mountWeapon = mountWeapon;
        window.unequipWeapon = unequipWeapon;
        window.sellWeapon = sellWeapon;
        window.switchStationSection = switchStationSection;

        // ========== RIVER NAVIGATION - WARP GATES ==========

        // Generate all end-of-level content (reward zone + gate zone)
        // Uses position-based spawning - content is placed at specific Y coordinates
        function generateLevelEndContent() {
            if (!scene || gameState.levelEndSpawned) return;

            // Base spawn position - above the visible screen
            const baseSpawnY = orthoHeight + 10;

            // 1. REWARD ZONE: Spawn solar system(s) as reward for completing waves
            const rewardY = baseSpawnY;
            createSolarSystemAt(rewardY);

            // 2. GATE ZONE: Spawn warp gates after the reward zone
            const gateY = rewardY + LEVEL_ZONE_HEIGHTS.reward;
            createWarpGates(gateY);

            gameState.levelEndSpawned = true;
        }

        // Create a solar system at a specific Y position
        function createSolarSystemAt(spawnY) {
            if (!scene) return;

            const centerX = (Math.random() - 0.5) * (orthoWidth * 1.2);
            const centerY = spawnY;

            // Create sun at center
            const sun = createSun(centerX, centerY);
            if (sun) {
                gameState.suns.push(sun);
            }

            // Create 2-5 planets orbiting the sun
            const planetCount = 2 + Math.floor(Math.random() * 4);
            const minOrbitRadius = sun ? sun.size * 0.8 : 3;

            for (let i = 0; i < planetCount; i++) {
                const orbitRadius = minOrbitRadius + 2 + i * 2 + Math.random() * 1.5;
                const angle = Math.random() * Math.PI * 2;

                const px = centerX + Math.cos(angle) * orbitRadius;
                const py = centerY + Math.sin(angle) * orbitRadius * 0.4;

                const planet = createPlanetAt(px, py);
                if (planet) {
                    planet.orbitCenterX = centerX;
                    planet.orbitRadius = orbitRadius;
                    planet.orbitAngle = angle;
                    planet.orbitSpeed = 0.0003 + Math.random() * 0.0002;
                    gameState.planets.push(planet);
                }
            }
        }

        // Create warp gates at specified Y position
        function createWarpGates(spawnY) {
            if (!scene || gameState.showingGates) return;

            // Gate dimensions for positioning
            const gateSize = 7;
            const gateSpacing = gateSize + 1;
            const gateY = spawnY !== undefined ? spawnY : orthoHeight + gateSize / 2;
            const leftGateX = -gateSpacing / 2;
            const rightGateX = gateSpacing / 2;

            // Generate two different level options
            const nextLevel = gameState.level + 1;
            gameState.gateChoices = {
                left: generateLevelConfig(nextLevel),
                right: generateLevelConfig(nextLevel)
            };

            // Update UI with gate signatures
            updateGateUI();

            // Create the gate meshes using dimensions from above
            // Left gate (orange)
            const leftGate = createGateMesh('warpGateLeft', leftGateX, gateY, gateSize, [1, 0.5, 0.2]);
            leftGate.gateId = 'left';
            gameState.warpGates.push(leftGate);

            // Right gate (green)
            const rightGate = createGateMesh('warpGateRight', rightGateX, gateY, gateSize, [0.2, 1, 0.5]);
            rightGate.gateId = 'right';
            gameState.warpGates.push(rightGate);

            gameState.showingGates = true;
            document.getElementById('warpGatePanel').style.display = 'flex';
        }

        // Create a single warp gate mesh using the warpgate.png texture
        function createGateMesh(name, x, y, size, color) {
            const gate = BABYLON.MeshBuilder.CreatePlane(name, { size: size }, scene);

            gate.position.x = x;
            gate.position.y = y;
            gate.position.z = 0.1;

            const texture = new BABYLON.Texture('assets/stellar objects/warpgate.png', scene);
            texture.hasAlpha = true;

            const mat = new BABYLON.StandardMaterial(name + 'Mat', scene);
            mat.diffuseTexture = texture;
            mat.emissiveTexture = texture;
            // Tint with the gate color
            mat.emissiveColor = new BABYLON.Color3(color[0] * 0.6, color[1] * 0.6, color[2] * 0.6);
            mat.useAlphaFromDiffuseTexture = true;
            mat.backFaceCulling = false;
            mat.disableLighting = true;
            gate.material = mat;
            // Disable depth write so ships render on top when flying through
            mat.disableDepthWrite = true;
            gate.renderingGroupId = 1;

            // Add to glow layer for the glowing effect
            if (sunGlowLayer) {
                sunGlowLayer.addIncludedOnlyMesh(gate);
            }

            gate.size = size;
            gate.enterRadius = size * 0.4;
            gate.tintColor = color;

            return gate;
        }

        // Update the gate UI panels with sci-fi HUD style
        function updateGateUI() {
            if (!gameState.gateChoices) return;

            // Generate threat bar pips (4 pips, filled based on threat level)
            const getThreatBar = (config) => {
                const threatLevels = { 'Low': 1, 'Medium': 2, 'High': 3, 'Extreme': 4 };
                const threatColors = { 'Low': 'threat-low', 'Medium': 'threat-medium', 'High': 'threat-high', 'Extreme': 'threat-extreme' };
                const level = threatLevels[config.threatLevel] || 1;
                const colorClass = threatColors[config.threatLevel];
                let html = '';
                for (let i = 0; i < 4; i++) {
                    html += `<div class="threat-pip ${i < level ? 'active ' + colorClass : ''}"></div>`;
                }
                return html;
            };

            // Station icons with letter codes
            const getStationIcons = (config) => {
                if (config.stations.length === 0) return '<span class="no-stations">--</span>';
                const stationCodes = { 'Trade': 'T', 'Armory': 'A', 'Repair': 'R', 'Fuel': 'F' };
                const stationClasses = { 'Trade': 'trade', 'Armory': 'armory', 'Repair': 'repair', 'Fuel': 'fuel' };
                return config.stations.map(s =>
                    `<div class="station-icon ${stationClasses[s]}">${stationCodes[s]}</div>`
                ).join('');
            };

            // Left gate
            document.getElementById('gateLeftThreat').innerHTML = getThreatBar(gameState.gateChoices.left);
            document.getElementById('gateLeftWaves').textContent = gameState.gateChoices.left.waveCount;
            document.getElementById('gateLeftStations').innerHTML = getStationIcons(gameState.gateChoices.left);

            // Right gate
            document.getElementById('gateRightThreat').innerHTML = getThreatBar(gameState.gateChoices.right);
            document.getElementById('gateRightWaves').textContent = gameState.gateChoices.right.waveCount;
            document.getElementById('gateRightStations').innerHTML = getStationIcons(gameState.gateChoices.right);
        }

        // Update warp gates (movement and collision)
        function updateWarpGates(scrollMultiplier, deltaTime) {
            if (!gameState.showingGates || gameState.warpGates.length === 0) return;

            // Find reference gate for Y position check
            const leftGate = gameState.warpGates.find(g => g.gateId === 'left');
            const rightGate = gameState.warpGates.find(g => g.gateId === 'right');

            for (let i = gameState.warpGates.length - 1; i >= 0; i--) {
                const gate = gameState.warpGates[i];

                // Move gate down
                gate.position.y -= 0.01 * settings.scrollSpeed * (0.5 + scrollMultiplier);

                // Slow rotation
                gate.rotation.z += 0.005;

                // Update UI position below gate (so player can see it longer)
                const screenPos = worldToScreen(gate.position.x, gate.position.y - gate.size / 2 - 0.5);
                const previewId = gate.gateId === 'left' ? 'gateLeftPreview' : 'gateRightPreview';
                const preview = document.getElementById(previewId);
                if (preview) {
                    preview.style.left = screenPos.x + 'px';
                    preview.style.top = screenPos.y + 'px';
                    preview.style.transform = 'translate(-50%, 0)';
                }
            }

            // Check if player has committed to a gate (halfway across screen and past gate Y)
            if (playerShip && leftGate) {
                const gateY = leftGate.position.y;
                const gateRadius = leftGate.enterRadius;

                // Player must be past the gate vertically (above it, since Y increases upward)
                if (playerShip.position.y > gateY - gateRadius * 0.5) {
                    // Determine which half of the screen player is on
                    const playerX = playerShip.position.x;
                    const halfScreen = orthoWidth * 0.3; // 30% from center = committed

                    if (playerX < -halfScreen) {
                        // Player committed to left gate
                        enterWarpGate('left');
                        return;
                    } else if (playerX > halfScreen) {
                        // Player committed to right gate
                        enterWarpGate('right');
                        return;
                    }
                }

                // Tint background based on which side player is leaning toward
                updateGateBackgroundTint(playerShip.position.x, leftGate, rightGate);
            }

            // Remove if off screen (player stayed in center too long)
            if (leftGate && leftGate.position.y < -orthoHeight - leftGate.size) {
                // Force player into gate based on their X position
                enterWarpGate(playerShip.position.x < 0 ? 'left' : 'right');
                return;
            }
        }

        // Tint background subtly based on gate choice
        function updateGateBackgroundTint(playerX, leftGate, rightGate) {
            // Calculate how far player is toward each side
            const maxOffset = orthoWidth * 0.5;
            const normalizedX = Math.max(-1, Math.min(1, playerX / maxOffset));

            // Get colors for each gate
            const leftColor = leftGate ? leftGate.tintColor : [1, 0.5, 0.2];
            const rightColor = rightGate ? rightGate.tintColor : [0.2, 1, 0.5];

            // Blend based on position (subtle effect)
            const intensity = Math.abs(normalizedX) * 0.15;
            let r, g, b;
            if (normalizedX < 0) {
                r = leftColor[0] * intensity;
                g = leftColor[1] * intensity;
                b = leftColor[2] * intensity;
            } else {
                r = rightColor[0] * intensity;
                g = rightColor[1] * intensity;
                b = rightColor[2] * intensity;
            }

            // Apply to ambient light or scene clear color
            if (scene) {
                scene.ambientColor = new BABYLON.Color3(0.05 + r, 0.05 + g, 0.1 + b);
            }
        }

        // Handle entering a warp gate
        function enterWarpGate(gateId) {
            const chosenConfig = gameState.gateChoices[gateId];

            // Reset ambient color
            if (scene) {
                scene.ambientColor = new BABYLON.Color3(0.05, 0.05, 0.1);
            }

            // Clean up gates
            gameState.warpGates.forEach(gate => {
                if (sunGlowLayer) {
                    sunGlowLayer.removeIncludedOnlyMesh(gate);
                }
                gate.dispose();
            });
            gameState.warpGates = [];
            gameState.showingGates = false;
            gameState.gateChoices = null;
            document.getElementById('warpGatePanel').style.display = 'none';

            // Pause game during warp
            gameState.isPaused = true;

            // Show warp animation
            playWarpAnimation(() => {
                // After animation, start new level with fresh background
                startNewLevel(chosenConfig);
                // Save game progress when entering new level
                saveGame();
                showSavedNotification();
                gameState.isPaused = false;
            });
        }

        // Play lightspeed warp animation
        function playWarpAnimation(callback) {
            const overlay = document.getElementById('warpOverlay');
            const flash = document.getElementById('warpFlash');
            overlay.style.display = 'block';
            overlay.innerHTML = '';

            // Create streaking stars
            const starCount = 50;
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'warp-star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 50 + '%';
                star.style.animationDelay = (Math.random() * 0.3) + 's';
                star.style.opacity = 0.5 + Math.random() * 0.5;
                overlay.appendChild(star);
            }

            // Flash and transition
            setTimeout(() => {
                flash.style.transition = 'opacity 0.15s ease-in';
                flash.style.opacity = '1';
            }, 600);

            setTimeout(() => {
                flash.style.transition = 'opacity 0.4s ease-out';
                flash.style.opacity = '0';
                overlay.style.display = 'none';
                overlay.innerHTML = '';
                if (callback) callback();
            }, 800);
        }

        // Start a new level with the given config - fresh start with new background
        function startNewLevel(config) {
            gameState.level = config.levelNum;
            gameState.levelConfig = config;
            gameState.levelWave = 0;
            gameState.stationsVisited = 0;
            gameState.wave = (gameState.level - 1) * 5 + 1; // Global wave number for difficulty

            // Reset level end state for new level
            gameState.levelEndSpawned = false;

            // Clear all existing game objects for fresh start
            clearLevelObjects();

            // Change to a new random background zone
            changeToNewZone();

            // Reset player position to center-bottom
            if (playerShip) {
                playerShip.position.x = 0;
                playerShip.position.y = -7;
                playerShip.targetX = 0;
                playerShip.targetY = -7;
            }

            // Reset solar system spawning
            gameState.nextSolarSystemY = orthoHeight + 15;

            // Update HUD to show level
            updateHUD();

            // Start first wave
            spawnWave();
        }

        // Clear all level objects for fresh start
        function clearLevelObjects() {
            // Clear enemies
            gameState.enemies.forEach(e => {
                e.getChildMeshes().forEach(m => m.dispose());
                e.dispose();
            });
            gameState.enemies = [];

            // Clear bullets
            gameState.playerBullets.forEach(b => b.dispose());
            gameState.playerBullets = [];
            gameState.enemyBullets.forEach(b => b.dispose());
            gameState.enemyBullets = [];

            // Clear loot
            gameState.loot.forEach(l => {
                l.getChildMeshes().forEach(m => m.dispose());
                l.dispose();
            });
            gameState.loot = [];

            // Clear planets
            gameState.planets.forEach(p => p.dispose());
            gameState.planets = [];

            // Clear suns (with their corona children)
            gameState.suns.forEach(s => {
                if (s.coronas) {
                    s.coronas.forEach(c => c.dispose());
                }
                if (s.sunMesh) {
                    s.sunMesh.dispose();
                }
                s.dispose();
            });
            gameState.suns = [];

            // Clear starbase
            if (gameState.starbase) {
                gameState.starbase.dispose();
                gameState.starbase = null;
            }

            // Reset spawn timers
            gameState.enemiesInWave = 0;
            gameState.enemiesSpawned = 0;
        }

        // Change to a new random background zone
        function changeToNewZone() {
            // Pick a different zone than current
            let newZone;
            do {
                newZone = Math.floor(Math.random() * SPACE_ZONES.length);
            } while (newZone === gameState.currentZone && SPACE_ZONES.length > 1);

            gameState.currentZone = newZone;
            gameState.distanceTraveled = 0;

            // Update background texture
            if (backgroundMaterialA && backgroundMaterialA.diffuseTexture) {
                backgroundMaterialA.diffuseTexture.dispose();
                const bgSize = Math.max(orthoWidth, orthoHeight) * 3;
                const newTexture = new BABYLON.Texture(getBackgroundPath(newZone), scene);
                newTexture.uScale = bgSize / 20;
                newTexture.vScale = bgSize * 2 / 20;
                newTexture.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;
                newTexture.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;
                newTexture.vOffset = 0;
                backgroundMaterialA.diffuseTexture = newTexture;
                backgroundMaterialA.emissiveTexture = newTexture;
            }
        }

        // ========== END RIVER NAVIGATION ==========

        // Update suns
        function updateSuns(scrollMultiplier) {
            for (let i = gameState.suns.length - 1; i >= 0; i--) {
                const sun = gameState.suns[i];

                const moveAmount = 0.015 * settings.scrollSpeed * (0.5 + scrollMultiplier);
                sun.position.y -= moveAmount;

                // Rotate the sun mesh (not the whole node with coronas)
                if (sun.sunMesh) {
                    sun.sunMesh.rotation.z += 0.0005;
                }

                if (sun.position.y < -orthoHeight - sun.glowSize) {
                    // Dispose corona meshes
                    if (sun.coronas) {
                        sun.coronas.forEach(c => c.dispose());
                    }
                    if (sun.sunMesh) {
                        sun.sunMesh.dispose();
                    }
                    sun.dispose();
                    gameState.suns.splice(i, 1);
                }
            }
        }

        // Apply subtle sun color tinting to ships when near a sun
        // Ships are excluded from GlowLayer so they won't be washed out
        // The silhouette effect happens naturally when ship is in front of the bright sun
        function applySunLighting() {
            // Simplified: no complex calculations needed since ships are excluded from bloom
            // Just apply subtle color tinting based on nearest sun
            if (gameState.suns.length === 0) return;

            const applyTintToMesh = (mesh, dist, tint) => {
                if (!mesh.material || mesh.name.indexOf('exhaust') !== -1) return;

                const tintRange = 15; // How close before sun tint applies
                if (dist < tintRange) {
                    const intensity = 1 - dist / tintRange;
                    // Subtle sun color tint on the ship
                    mesh.material.emissiveColor = new BABYLON.Color3(
                        0.25 + tint[0] * intensity * 0.15,
                        0.25 + tint[1] * intensity * 0.15,
                        0.25 + tint[2] * intensity * 0.15
                    );
                } else {
                    // Normal lighting
                    mesh.material.emissiveColor = new BABYLON.Color3(0.25, 0.25, 0.25);
                }
            };

            const applyToObject = (objX, objY, meshes) => {
                let nearestDist = Infinity;
                let nearestTint = [1, 1, 1];

                for (const sun of gameState.suns) {
                    const dx = sun.position.x - objX;
                    const dy = sun.position.y - objY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestTint = sun.tint;
                    }
                }

                meshes.forEach(mesh => applyTintToMesh(mesh, nearestDist, nearestTint));
            };

            // Apply to player ship
            if (playerShipMesh) {
                const playerMeshes = playerShipMesh.getChildMeshes(false) || [];
                if (playerShipMesh.material) playerMeshes.push(playerShipMesh);
                applyToObject(playerShip.position.x, playerShip.position.y, playerMeshes);
            }

            // Apply to enemies
            for (const enemy of gameState.enemies) {
                if (enemy.mesh) {
                    const enemyMeshes = enemy.mesh.getChildMeshes(false) || [];
                    if (enemy.mesh.material) enemyMeshes.push(enemy.mesh);
                    applyToObject(enemy.position.x, enemy.position.y, enemyMeshes);
                }
            }

            // Apply to starbase
            if (gameState.starbase) {
                const starbaseMeshes = gameState.starbase.getChildMeshes ? gameState.starbase.getChildMeshes(false) || [] : [];
                if (gameState.starbase.material) starbaseMeshes.push(gameState.starbase);
                applyToObject(gameState.starbase.position.x, gameState.starbase.position.y, starbaseMeshes);
            }

            // Update DirectionalLight for dramatic sun lighting from above
            if (gameState.sunLight && playerShip) {
                let nearestSun = null;
                let nearestDist = Infinity;

                for (const sun of gameState.suns) {
                    const dx = sun.position.x - playerShip.position.x;
                    const dy = sun.position.y - playerShip.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestSun = sun;
                    }
                }

                if (nearestSun) {
                    // Direction from sun (above) pointing down at player
                    const dx = playerShip.position.x - nearestSun.position.x;
                    const dy = playerShip.position.y - nearestSun.position.y;
                    // Light comes from high above (strong Y component) with slight XY offset toward player
                    gameState.sunLight.direction = new BABYLON.Vector3(
                        dx * 0.1,
                        -1,
                        0.3
                    ).normalize();

                    // Intensity based on distance - stronger when closer
                    const maxRange = 20;
                    const intensity = Math.max(0, 1 - nearestDist / maxRange) * 1.5;
                    gameState.sunLight.intensity = intensity;

                    // Use sun's color for the light
                    gameState.sunLight.diffuse = new BABYLON.Color3(
                        nearestSun.tint[0],
                        nearestSun.tint[1],
                        nearestSun.tint[2]
                    );
                    gameState.sunLight.specular = new BABYLON.Color3(
                        nearestSun.tint[0] * 0.5,
                        nearestSun.tint[1] * 0.5,
                        nearestSun.tint[2] * 0.5
                    );
                } else {
                    gameState.sunLight.intensity = 0;
                }
            }
        }

        // Convert world position to screen position
        function worldToScreen(worldX, worldY) {
            // Use CSS pixel dimensions for DOM element positioning
            const cssWidth = canvas.clientWidth;
            const cssHeight = canvas.clientHeight;
            const screenX = ((worldX + orthoWidth) / (orthoWidth * 2)) * cssWidth;
            const screenY = ((orthoHeight - worldY) / (orthoHeight * 2)) * cssHeight;
            return { x: screenX, y: screenY };
        }

        // Update targeting overlay
        function updateTargetingOverlay(planet) {
            const overlay = document.getElementById('targetingOverlay');
            const corners = overlay.querySelectorAll('.targeting-corner');
            const harvestBar = document.getElementById('harvestBar');
            const planetInfo = document.getElementById('planetInfo');

            if (!planet) {
                corners.forEach(c => c.style.display = 'none');
                harvestBar.style.display = 'none';
                planetInfo.style.display = 'none';
                return;
            }

            const screenPos = worldToScreen(planet.position.x, planet.position.y);
            // Use CSS pixels for proper sizing - tight on planet
            const screenSize = (planet.size / (orthoHeight * 2)) * canvas.clientHeight;
            const halfSize = screenSize / 2;

            // Richness determines targeting color
            const richnessColors = {
                1: '#888888', // Grey - common
                2: '#44aa44', // Green - uncommon
                3: '#4488ff', // Blue - rare
                4: '#aa44ff', // Purple - epic
                5: '#ffaa00'  // Gold - legendary
            };
            const targetColor = richnessColors[planet.richness] || '#888888';
            corners.forEach(c => c.style.borderColor = targetColor);

            const positions = [
                { x: screenPos.x - halfSize - 10, y: screenPos.y - halfSize - 10 }, // top-left
                { x: screenPos.x + halfSize - 10, y: screenPos.y - halfSize - 10 }, // top-right
                { x: screenPos.x - halfSize - 10, y: screenPos.y + halfSize - 10 }, // bottom-left
                { x: screenPos.x + halfSize - 10, y: screenPos.y + halfSize - 10 }  // bottom-right
            ];

            corners.forEach((corner, i) => {
                corner.style.display = 'block';
                corner.style.left = positions[i].x + 'px';
                corner.style.top = positions[i].y + 'px';
            });

            // Position harvest bar at bottom of targeting rectangle
            const barWidth = screenSize;
            harvestBar.style.left = (screenPos.x - barWidth / 2) + 'px';
            harvestBar.style.top = (screenPos.y + halfSize + 8) + 'px';
            harvestBar.style.width = barWidth + 'px';
            harvestBar.style.transform = 'none';

            // Hide planet info - richness shown through targeting color
            planetInfo.style.display = 'none';
        }

        // Update planets
        function updatePlanets(scrollMultiplier, deltaTime) {
            if (!playerShip) return;

            let nearPlanet = null;
            let nearestDist = Infinity;

            for (let i = gameState.planets.length - 1; i >= 0; i--) {
                const planet = gameState.planets[i];

                // Move planet down
                planet.position.y -= 0.015 * settings.scrollSpeed * (0.5 + scrollMultiplier);

                // Update orbit center if planet is orbiting
                if (planet.orbitCenterX !== undefined) {
                    // Find matching sun and update orbit center
                    planet.orbitAngle += planet.orbitSpeed * deltaTime;
                    // The orbit center also moves down with the solar system
                }

                // Slow rotation
                planet.rotation.z += 0.001;

                // Check distance to player - only if planet is fully visible on screen
                const planetFullyVisible = planet.position.y < (orthoHeight - planet.size / 2);

                if (planetFullyVisible) {
                    const dx = planet.position.x - playerShip.position.x;
                    const dy = planet.position.y - playerShip.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < planet.harvestRadius && planet.harvestsRemaining > 0) {
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearPlanet = planet;
                        }
                    }
                }

                // Remove if off screen
                if (planet.position.y < -orthoHeight - planet.size) {
                    planet.dispose();
                    gameState.planets.splice(i, 1);
                }
            }

            // Handle harvesting UI
            const harvestBar = document.getElementById('harvestBar');
            const harvestBarFill = document.getElementById('harvestBarFill');

            if (nearPlanet && nearPlanet.harvestsRemaining > 0) {
                if (gameState.harvestingPlanet !== nearPlanet) {
                    gameState.harvestingPlanet = nearPlanet;
                    gameState.harvestProgress = 0;
                }

                // Harvest time based on hazardousness
                gameState.harvestProgress += deltaTime / nearPlanet.harvestTime;

                harvestBar.style.display = 'block';
                harvestBarFill.style.width = `${Math.min(100, gameState.harvestProgress * 100)}%`;

                // Show targeting corners and planet info
                updateTargetingOverlay(nearPlanet);

                if (gameState.harvestProgress >= 1) {
                    // Harvest complete!
                    nearPlanet.harvestsRemaining--;
                    gameState.harvestProgress = 0;

                    // Give resources - multiply by richness
                    const resources = nearPlanet.planetData.resources;
                    const richnessMultiplier = 0.5 + nearPlanet.richness * 0.3; // 0.8x to 2x
                    Object.keys(resources).forEach(resName => {
                        const [min, max] = resources[resName];
                        const baseAmount = Math.floor(Math.random() * (max - min + 1)) + min;
                        const amount = Math.floor(baseAmount * richnessMultiplier);
                        gameState.resources[resName] += amount;
                        gameState.score += amount * 2;
                        showResourceCollection(resName, amount);
                    });

                    updateHUD();

                    createExplosion(nearPlanet.position.x, nearPlanet.position.y, 'large', 'green');

                    // Flash the planet
                    if (nearPlanet.material) {
                        const origEmissive = nearPlanet.material.emissiveColor.clone();
                        nearPlanet.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
                        setTimeout(() => {
                            if (nearPlanet.material) nearPlanet.material.emissiveColor = origEmissive;
                        }, 200);
                    }

                    if (nearPlanet.harvestsRemaining <= 0) {
                        // Planet depleted - fade it
                        if (nearPlanet.material) {
                            nearPlanet.material.alpha = 0.5;
                            nearPlanet.material.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                        }
                    }
                }
            } else {
                // Only reset if we're also not docking at a starbase
                const nearStarbase = isNearStarbase();
                if (!nearStarbase) {
                    gameState.harvestingPlanet = null;
                    gameState.harvestProgress = 0;
                    harvestBar.style.display = 'none';
                }
                updateTargetingOverlay(null);
            }
        }

        // Check if player is near a dockable starbase
        function isNearStarbase() {
            if (!gameState.starbase || !playerShip) return false;
            const starbase = gameState.starbase;
            const dx = starbase.position.x - playerShip.position.x;
            const dy = starbase.position.y - playerShip.position.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const fullyVisible = starbase.position.y < (orthoHeight - starbase.size / 2);
            return fullyVisible && dist < starbase.dockRadius;
        }

        // Load a ship model for gameplay
        async function loadShipModel(shipName, colorVariant, targetScene, faceDirection = 'up') {
            const basePath = `assets/Ultimate Spaceships/${shipName}/`;

            try {
                const result = await BABYLON.SceneLoader.ImportMeshAsync('', basePath + 'glTF/', `${shipName}.gltf`, targetScene);
                const rootMesh = result.meshes[0];

                const texturePath = `${basePath}Textures/${shipName}_${colorVariant}.png`;
                const texture = new BABYLON.Texture(texturePath, targetScene, false, true, BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
                texture.anisotropicFilteringLevel = 16;

                result.meshes.forEach(mesh => {
                    if (mesh.material) mesh.material.dispose();
                    const mat = new BABYLON.StandardMaterial(`${shipName}${colorVariant}Mat`, targetScene);
                    mat.diffuseTexture = texture;
                    mat.emissiveTexture = texture;
                    mat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                    mesh.material = mat;
                });

                const boundingInfo = rootMesh.getHierarchyBoundingVectors(true);
                const size = boundingInfo.max.subtract(boundingInfo.min);
                const maxDim = Math.max(size.x, size.y, size.z);
                const gameScale = 1.5 / maxDim;
                rootMesh.scaling = new BABYLON.Vector3(gameScale, gameScale, gameScale);

                if (faceDirection === 'up') {
                    rootMesh.rotationQuaternion = null;
                    rootMesh.rotation.set(-Math.PI / 2, 0, 0);
                } else {
                    rootMesh.rotationQuaternion = null;
                    rootMesh.rotation.set(Math.PI / 2, 0, 0);
                }

                return rootMesh;
            } catch (e) {
                console.error(`Failed to load ship ${shipName}:`, e);
                const placeholder = BABYLON.MeshBuilder.CreateBox('placeholder', {width: 0.8, height: 1.2, depth: 0.3}, targetScene);
                const mat = new BABYLON.StandardMaterial('placeholderMat', targetScene);
                mat.diffuseColor = colorVariant === 'Blue' ? new BABYLON.Color3(0.2, 0.4, 1) : new BABYLON.Color3(1, 0.2, 0.2);
                mat.emissiveColor = mat.diffuseColor.scale(0.3);
                placeholder.material = mat;
                return placeholder;
            }
        }

        // Create player ship
        // Create engine exhaust glow
        function createEngineExhaust(parent, color, offsetY, isEnemy = false) {
            const exhausts = [];
            // Create multiple exhaust points for better effect
            const exhaustPositions = isEnemy ?
                [{ x: -0.12, y: offsetY }, { x: 0.12, y: offsetY }] :
                [{ x: -0.15, y: offsetY }, { x: 0.15, y: offsetY }];

            exhaustPositions.forEach((pos, i) => {
                // Outer glow - smaller and more subtle
                const glow = BABYLON.MeshBuilder.CreateSphere('exhaust_glow_' + i, { diameter: 0.25 }, scene);
                glow.parent = parent;
                glow.position.x = pos.x;
                glow.position.y = pos.y;
                glow.position.z = 0.1; // Slightly behind ship

                const glowMat = new BABYLON.StandardMaterial('exhaustGlowMat_' + i, scene);
                glowMat.emissiveColor = color;
                glowMat.alpha = 0.3;
                glowMat.disableLighting = true;
                glowMat.backFaceCulling = false;
                glow.material = glowMat;

                // Inner core
                const core = BABYLON.MeshBuilder.CreateSphere('exhaust_core_' + i, { diameter: 0.08 }, scene);
                core.parent = parent;
                core.position.x = pos.x;
                core.position.y = pos.y;
                core.position.z = 0.1;

                const coreMat = new BABYLON.StandardMaterial('exhaustCoreMat_' + i, scene);
                coreMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
                coreMat.disableLighting = true;
                core.material = coreMat;

                // Add to glow layer
                if (sunGlowLayer) {
                    sunGlowLayer.addIncludedOnlyMesh(glow);
                    sunGlowLayer.addIncludedOnlyMesh(core);
                }

                // Render on top of suns/planets
                glow.renderingGroupId = 2;
                core.renderingGroupId = 2;

                exhausts.push({ glow, core });
            });

            return exhausts;
        }

        async function createPlayerShip() {
            playerShip = new BABYLON.TransformNode('playerShip', scene);

            playerShipMesh = await loadShipModel(settings.playerShip, settings.playerColor, scene, 'up');
            playerShipMesh.parent = playerShip;

            // Exclude ship from GlowLayer to prevent bloom washout
            // Set rendering group to render on top of suns/planets
            if (sunGlowLayer) {
                const shipMeshes = playerShipMesh.getChildMeshes(false) || [];
                shipMeshes.push(playerShipMesh);
                shipMeshes.forEach(mesh => {
                    sunGlowLayer.addExcludedMesh(mesh);
                    mesh.renderingGroupId = 2;
                });
            }

            // Add blue engine exhaust - positioned at rear of ship
            const blueColor = new BABYLON.Color3(0.3, 0.6, 1);
            playerShip.exhausts = createEngineExhaust(playerShip, blueColor, -0.5, false);

            playerShip.position = new BABYLON.Vector3(0, -7, 0);
            playerShip.targetX = 0;
            playerShip.targetY = -7;
            playerShip.velocityX = 0;
            playerShip.currentTilt = 0;

            return playerShip;
        }

        // Create stars
        function createStars(count = 150) {
            updateGameDimensions();

            for (let i = 0; i < count; i++) {
                const size = Math.random() * 0.08 + 0.02;
                const star = BABYLON.MeshBuilder.CreateSphere('star' + i, { diameter: size }, scene);

                star.position.x = (Math.random() - 0.5) * orthoWidth * 2.5;
                star.position.y = (Math.random() - 0.5) * orthoHeight * 2.5;
                star.position.z = 1 + Math.random() * 2;

                const starMat = new BABYLON.StandardMaterial('starMat' + i, scene);
                const brightness = Math.random() * 0.5 + 0.5;
                starMat.emissiveColor = new BABYLON.Color3(brightness, brightness, brightness * 0.9);
                star.material = starMat;

                star.speed = (Math.random() * 0.3 + 0.1) * (0.5 + size * 5);
                gameState.stars.push(star);
            }
        }

        // Create enemy
        async function createEnemy(type = 'basic', x, y) {
            const enemy = new BABYLON.TransformNode('enemy', scene);

            // Determine ship model and color based on enemy type
            let shipModel, shipColor, exhaustColor, exhaustScale;
            switch (type) {
                case 'light':
                    shipModel = 'Dispatcher';
                    shipColor = 'Purple';
                    exhaustColor = new BABYLON.Color3(0.8, 0.3, 1.0); // Purple exhaust
                    exhaustScale = 0.35;
                    break;
                case 'heavy':
                    shipModel = 'Imperial';
                    shipColor = 'Orange';
                    exhaustColor = new BABYLON.Color3(1.0, 0.6, 0.2); // Orange exhaust
                    exhaustScale = 0.6;
                    break;
                default:
                    shipModel = settings.enemyShip;
                    shipColor = settings.enemyColor;
                    exhaustColor = new BABYLON.Color3(1, 0.4, 0.2); // Red exhaust
                    exhaustScale = 0.45;
            }

            const enemyMesh = await loadShipModel(shipModel, shipColor, scene, 'down');
            enemyMesh.parent = enemy;

            // Exclude enemy ship from GlowLayer to prevent bloom washout
            // Set rendering group to render on top of suns/planets
            if (sunGlowLayer) {
                const shipMeshes = enemyMesh.getChildMeshes(false) || [];
                shipMeshes.push(enemyMesh);
                shipMeshes.forEach(mesh => {
                    sunGlowLayer.addExcludedMesh(mesh);
                    mesh.renderingGroupId = 2;
                });
            }

            // Add engine exhaust (facing up since enemy is rotated down)
            enemy.exhausts = createEngineExhaust(enemy, exhaustColor, exhaustScale, true);

            enemy.position.x = x;
            enemy.position.y = y;
            enemy.position.z = 0;
            enemy.type = type;

            // Health scaling based on game level
            const levelHealthMult = 1 + (gameState.level - 1) * 0.15;

            // Set stats based on enemy type
            switch (type) {
                case 'light':
                    // Light attacker: fast, agile, low health, rapid fire
                    enemy.maxHealth = Math.round(20 * levelHealthMult);
                    enemy.health = enemy.maxHealth;
                    enemy.speed = 0.1;
                    enemy.hitboxWidth = 0.7;
                    enemy.hitboxHeight = 0.5;
                    enemy.fireRate = 2000;
                    enemy.damage = 5;
                    break;
                case 'heavy':
                    // Heavy attacker: slow, tanky, high damage
                    enemy.maxHealth = Math.round(100 * levelHealthMult);
                    enemy.health = enemy.maxHealth;
                    enemy.speed = 0.02;
                    enemy.hitboxWidth = 1.2;
                    enemy.hitboxHeight = 0.8;
                    enemy.fireRate = 2500;
                    enemy.damage = 15;
                    break;
                case 'shooter':
                    enemy.maxHealth = Math.round(50 * levelHealthMult);
                    enemy.health = enemy.maxHealth;
                    enemy.speed = 0.03;
                    enemy.hitboxWidth = 0.9;
                    enemy.hitboxHeight = 0.6;
                    enemy.fireRate = 1500;
                    enemy.damage = 8;
                    break;
                case 'fast':
                    enemy.maxHealth = Math.round(15 * levelHealthMult);
                    enemy.health = enemy.maxHealth;
                    enemy.speed = 0.08;
                    enemy.hitboxWidth = 0.9;
                    enemy.hitboxHeight = 0.6;
                    enemy.fireRate = 3000;
                    enemy.damage = 5;
                    break;
                default: // basic
                    enemy.maxHealth = Math.round(30 * levelHealthMult);
                    enemy.health = enemy.maxHealth;
                    enemy.speed = 0.03;
                    enemy.hitboxWidth = 0.9;
                    enemy.hitboxHeight = 0.6;
                    enemy.fireRate = 3000;
                    enemy.damage = 8;
            }

            enemy.lastFireTime = 0;
            enemy.movementPattern = type === 'light' ? 'sine' : (Math.random() > 0.5 ? 'sine' : 'straight');
            enemy.startX = x;
            enemy.time = Math.random() * Math.PI * 2;
            enemy.mesh = enemyMesh;
            enemy.prevX = x;
            enemy.currentTilt = 0;

            return enemy;
        }

        // Create bullet
        function createBullet(isPlayer, x, y, velocityX = 0, velocityY = 0.2, damage = 10) {
            let bullet;

            if (isPlayer) {
                // Player bullet: subtle glow aura + defined solid core
                bullet = BABYLON.MeshBuilder.CreateSphere('bullet', { diameter: 0.22 }, scene);
                const glowMat = new BABYLON.StandardMaterial('bulletGlowMat', scene);
                glowMat.emissiveColor = new BABYLON.Color3(0.2, 0.8, 0.4);
                glowMat.alpha = 0.25;
                glowMat.disableLighting = true;
                glowMat.backFaceCulling = false;
                bullet.material = glowMat;

                // Add glow aura to GlowLayer
                if (sunGlowLayer) {
                    sunGlowLayer.addIncludedOnlyMesh(bullet);
                }

                // Solid defined core on top
                const core = BABYLON.MeshBuilder.CreateSphere('bulletCore', { diameter: 0.12 }, scene);
                core.parent = bullet;
                core.position.z = -0.05; // Slightly in front
                const coreMat = new BABYLON.StandardMaterial('coreMat', scene);
                coreMat.emissiveColor = new BABYLON.Color3(0.4, 1, 0.6);
                coreMat.diffuseColor = new BABYLON.Color3(0.2, 0.7, 0.4);
                coreMat.disableLighting = true;
                core.material = coreMat;
            } else {
                // Enemy bullet: subtle glow capsule + bright core
                bullet = BABYLON.MeshBuilder.CreateCapsule('bullet', { height: 0.4, radius: 0.08 }, scene);
                bullet.rotation.z = Math.atan2(velocityX, -velocityY);

                const glowMat = new BABYLON.StandardMaterial('enemyBulletGlowMat', scene);
                glowMat.emissiveColor = new BABYLON.Color3(1, 0.3, 0.5);
                glowMat.alpha = 0.3;
                glowMat.disableLighting = true;
                glowMat.backFaceCulling = false;
                bullet.material = glowMat;

                // Add to glow layer
                if (sunGlowLayer) {
                    sunGlowLayer.addIncludedOnlyMesh(bullet);
                }

                // Solid core
                const core = BABYLON.MeshBuilder.CreateSphere('bulletCore', { diameter: 0.08 }, scene);
                core.parent = bullet;
                core.position.y = 0;
                core.position.z = -0.05;
                const coreMat = new BABYLON.StandardMaterial('coreMat', scene);
                coreMat.emissiveColor = new BABYLON.Color3(1, 0.7, 0.85);
                coreMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
                coreMat.disableLighting = true;
                core.material = coreMat;
            }

            bullet.position.x = x;
            bullet.position.y = y;
            bullet.position.z = -0.1;
            bullet.velocityX = velocityX;
            bullet.velocityY = velocityY;
            bullet.isPlayer = isPlayer;
            bullet.damage = damage;

            // Render on top of suns/planets
            bullet.renderingGroupId = 2;
            bullet.getChildMeshes().forEach(m => m.renderingGroupId = 2);

            return bullet;
        }

        // Input handling
        let inputState = {
            isPressed: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0
        };

        // Keyboard state
        let keyState = {
            left: false,
            right: false,
            up: false,
            down: false
        };

        function handleInputStart(x, y) {
            inputState.isPressed = true;
            inputState.startX = x;
            inputState.startY = y;
            inputState.currentX = x;
            inputState.currentY = y;
        }

        function handleInputMove(x, y) {
            if (inputState.isPressed) {
                inputState.currentX = x;
                inputState.currentY = y;
            }
        }

        function handleInputEnd() {
            inputState.isPressed = false;
        }

        document.addEventListener('touchstart', (e) => {
            // Allow buttons, inputs, and station interior to work normally
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' ||
                e.target.closest('button') || e.target.closest('#systemMenu') ||
                e.target.closest('#settingsPanel') || e.target.closest('#confirmDialog') ||
                e.target.closest('#stationInterior')) return;
            if (gameState.isPlaying && !gameState.isPaused && e.touches.length > 0) {
                e.preventDefault();
                const touch = e.touches[0];
                handleInputStart(touch.clientX, touch.clientY);
            }
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            // Allow station interior scrolling
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' ||
                e.target.closest('#stationInterior')) return;
            if (gameState.isPlaying && !gameState.isPaused && e.touches.length > 0) {
                e.preventDefault();
                const touch = e.touches[0];
                handleInputMove(touch.clientX, touch.clientY);
            }
        }, { passive: false });

        document.addEventListener('touchend', (e) => {
            handleInputEnd();
        }, { passive: false });

        document.addEventListener('mousedown', (e) => {
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
            if (gameState.isPlaying && !gameState.isPaused) {
                e.preventDefault();
                handleInputStart(e.clientX, e.clientY);
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (inputState.isPressed && gameState.isPlaying && !gameState.isPaused) {
                handleInputMove(e.clientX, e.clientY);
            }
        });

        document.addEventListener('mouseup', (e) => {
            handleInputEnd();
        });

        document.addEventListener('mouseleave', (e) => {
            handleInputEnd();
        });

        // Keyboard input
        document.addEventListener('keydown', (e) => {
            if (!gameState.isPlaying || gameState.isPaused) return;

            switch(e.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    keyState.left = true;
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    keyState.right = true;
                    e.preventDefault();
                    break;
                case 'ArrowUp':
                case 'w':
                case 'W':
                    keyState.up = true;
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    keyState.down = true;
                    e.preventDefault();
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    keyState.left = false;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    keyState.right = false;
                    break;
                case 'ArrowUp':
                case 'w':
                case 'W':
                    keyState.up = false;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    keyState.down = false;
                    break;
            }
        });

        // Update player position
        function updatePlayerPosition(deltaTime) {
            if (!playerShip) return 0.3;

            // Keyboard movement
            const keySpeed = 0.015 * settings.shipSpeed * deltaTime;
            if (keyState.left) playerShip.targetX -= keySpeed;
            if (keyState.right) playerShip.targetX += keySpeed;
            if (keyState.up) playerShip.targetY += keySpeed;
            if (keyState.down) playerShip.targetY -= keySpeed;

            // Touch/mouse movement
            if (inputState.isPressed) {
                const deltaX = (inputState.currentX - inputState.startX) * settings.xSensitivity;
                const deltaY = (inputState.currentY - inputState.startY) * settings.ySensitivity;

                inputState.startX = inputState.currentX;
                inputState.startY = inputState.currentY;

                // Use CSS pixel dimensions (not render pixels) for input conversion
                const cssWidth = canvas.clientWidth;
                const cssHeight = canvas.clientHeight;
                const worldDeltaX = (deltaX / cssWidth) * orthoWidth * 2;
                const worldDeltaY = -(deltaY / cssHeight) * orthoHeight * 2;

                playerShip.targetX += worldDeltaX;
                playerShip.targetY += worldDeltaY;
            }

            // Allow wider movement when gates are showing so player can commit to a side
            const maxX = gameState.showingGates ? orthoWidth + 2 : orthoWidth - 1;
            playerShip.targetX = Math.max(-maxX, Math.min(maxX, playerShip.targetX));

            const minY = -orthoHeight + 1;
            let maxY = -orthoHeight + (orthoHeight * 2 * settings.maxHeight);

            // Clamp Y to stay below gates - player must go through one
            if (gameState.showingGates && gameState.warpGates.length > 0) {
                const gate = gameState.warpGates[0];
                const gateBlockY = gate.position.y - gate.enterRadius * 0.8;
                maxY = Math.min(maxY, gateBlockY);
            }

            playerShip.targetY = Math.max(minY, Math.min(maxY, playerShip.targetY));

            const lerpFactor = 0.15 * settings.shipSpeed;
            const prevX = playerShip.position.x;
            playerShip.position.x += (playerShip.targetX - playerShip.position.x) * lerpFactor;
            playerShip.position.y += (playerShip.targetY - playerShip.position.y) * lerpFactor;

            playerShip.velocityX = playerShip.position.x - prevX;

            const targetTilt = -playerShip.velocityX * 8;
            const maxTilt = Math.PI / 6;
            const clampedTilt = Math.max(-maxTilt, Math.min(maxTilt, targetTilt));

            playerShip.currentTilt += (clampedTilt - playerShip.currentTilt) * 0.15;

            if (playerShipMesh) {
                playerShipMesh.rotation.y = playerShip.currentTilt;
            }

            const normalizedY = (playerShip.position.y + orthoHeight) / (orthoHeight * 2);
            return Math.max(0.1, normalizedY + 0.2);
        }

        // Fire weapons from all equipped hardpoints
        function firePlayerWeapons(currentTime) {
            if (!playerShip) return;
            if (gameState.enemies.length === 0) return;

            // Get equipped weapons from fleet (or use default starter weapon)
            const equippedWeapons = gameState.equippedWeapons.length > 0
                ? gameState.equippedWeapons
                : [WEAPONS.basic];

            equippedWeapons.forEach((weapon, idx) => {
                if (!weapon) return;

                // Track fire time per weapon slot
                if (!gameState.weaponFireTimes) gameState.weaponFireTimes = {};
                const lastFire = gameState.weaponFireTimes[idx] || 0;
                const fireInterval = weapon.fireRate / settings.fireRate;

                if (currentTime - lastFire > fireInterval) {
                    // Calculate hardpoint position offset
                    const hardpointOffset = gameState.fleet.length > 0 && gameState.fleet[0].hardpoints[idx]
                        ? gameState.fleet[0].hardpoints[idx].position
                        : { x: (idx === 0 ? -0.3 : 0.3), y: 0.3 };

                    const px = playerShip.position.x + hardpointOffset.x;
                    const py = playerShip.position.y + hardpointOffset.y + 0.2;

                    // Get weapon speed (default 0.35 for backward compatibility)
                    const weaponSpeed = weapon.speed || 0.35;

                    // Fire based on weapon type
                    if (weapon.type === 'beam') {
                        fireBeamLaser(px, py, weapon);
                    } else if (weapon.type === 'spread' || weapon.projectiles > 1) {
                        // Spread/multi-projectile weapon
                        const count = weapon.projectiles || 3;
                        const spreadAngle = weapon.spread || 0.3;
                        const angleStep = count > 1 ? (spreadAngle * 2) / (count - 1) : 0;
                        const startAngle = -spreadAngle;

                        for (let i = 0; i < count; i++) {
                            const angle = count > 1 ? startAngle + (angleStep * i) : 0;
                            const vx = Math.sin(angle) * weaponSpeed;
                            const vy = Math.cos(angle) * weaponSpeed;
                            const bullet = createBullet(true, px + (vx * 0.3), py, vx * 0.3, vy, weapon.damage);
                            gameState.playerBullets.push(bullet);
                        }
                    } else {
                        // Single projectile bullet weapon
                        const bullet = createBullet(true, px, py, 0, weaponSpeed, weapon.damage);
                        gameState.playerBullets.push(bullet);
                    }

                    gameState.weaponFireTimes[idx] = currentTime;
                }
            });

            // Update beam visuals if active
            updateBeamVisuals();
        }

        // Update beam visual effects
        function updateBeamVisuals() {
            if (gameState.beamMeshes) {
                for (let i = gameState.beamMeshes.length - 1; i >= 0; i--) {
                    const beam = gameState.beamMeshes[i];
                    if (beam && beam.material) {
                        beam.material.alpha -= 0.05;
                        if (beam.material.alpha <= 0) {
                            if (sunGlowLayer) {
                                sunGlowLayer.removeIncludedOnlyMesh(beam);
                            }
                            beam.dispose();
                            gameState.beamMeshes.splice(i, 1);
                        }
                    }
                }
            }
            // Legacy single beam support
            if (gameState.beamMesh) {
                gameState.beamMesh.material.alpha -= 0.05;
                if (gameState.beamMesh.material.alpha <= 0) {
                    if (sunGlowLayer) {
                        sunGlowLayer.removeIncludedOnlyMesh(gameState.beamMesh);
                    }
                    gameState.beamMesh.dispose();
                    gameState.beamMesh = null;
                }
            }
        }

        // Fire beam laser
        function fireBeamLaser(px, py, weapon = null) {
            if (!gameState.beamMeshes) gameState.beamMeshes = [];

            const beamDamage = weapon ? weapon.damage : 20;
            const beamWidth = weapon ? (0.3 + weapon.spread * 0.5) : 0.5;

            const beamHeight = orthoHeight * 2;
            const beam = BABYLON.MeshBuilder.CreatePlane('beam', { width: beamWidth * 0.6, height: beamHeight }, scene);
            beam.position.x = px;
            beam.position.y = py + beamHeight / 2;
            beam.position.z = -0.1;

            const beamMat = new BABYLON.StandardMaterial('beamMat', scene);
            beamMat.emissiveColor = new BABYLON.Color3(0, 1, 0.8);
            beamMat.alpha = 0.8;
            beamMat.backFaceCulling = false;
            beam.material = beamMat;
            beam.renderingGroupId = 2;

            // Add beam to glow layer for dramatic effect
            if (sunGlowLayer) {
                sunGlowLayer.addIncludedOnlyMesh(beam);
            }

            gameState.beamMeshes.push(beam);

            // Damage all enemies in the beam's path
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                if (Math.abs(enemy.position.x - px) < beamWidth) {
                    enemy.health -= beamDamage;
                    flashShip(enemy.mesh || enemy);

                    if (enemy.health <= 0) {
                        createExplosion(enemy.position.x, enemy.position.y, 'large', 'orange');
                        createLoot(enemy.position.x, enemy.position.y, enemy.type);
                        gameState.score += 50;
                        gameState.credits += 10 + Math.floor(Math.random() * 15);
                        updateHUD();

                        enemy.getChildMeshes().forEach(m => m.dispose());
                        enemy.dispose();
                        gameState.enemies.splice(i, 1);
                    }
                }
            }
        }

        // Spawn wave
        function spawnWave() {
            const waveConfig = {
                1: { count: 5 },
                2: { count: 7 },
                3: { count: 8 },
                4: { count: 10 },
                5: { count: 12 }
            };

            // Use levelWave for difficulty within level, apply enemy multiplier from level config
            const waveNum = Math.min(gameState.levelWave + 1, 5);
            const config = waveConfig[waveNum] || waveConfig[5];
            let enemyCount = config.count + Math.floor(Math.max(0, gameState.level - 1) * 2);

            // Apply level threat multiplier
            if (gameState.levelConfig) {
                enemyCount = Math.floor(enemyCount * gameState.levelConfig.enemyMultiplier);
            }

            gameState.enemiesInWave = enemyCount;
            gameState.enemiesSpawned = 0;
        }

        // Spawn enemy
        async function spawnEnemy() {
            if (gameState.enemiesSpawned >= gameState.enemiesInWave) return;

            // Enemy types with weighted spawning based on wave progression
            // Light (Dispatcher) and Heavy (Imperial) unlock at higher waves
            const baseTypes = ['basic', 'basic', 'fast', 'shooter'];
            const advancedTypes = ['basic', 'fast', 'shooter', 'light', 'light', 'heavy'];

            // Use advanced types after wave 2, mixing in light and heavy attackers
            const types = gameState.wave >= 3 ? advancedTypes : baseTypes;
            const type = types[Math.floor(Math.random() * Math.min(types.length, 1 + gameState.wave))];

            const maxX = orthoWidth - 1;
            const x = (Math.random() - 0.5) * maxX * 1.5;
            const y = orthoHeight + 2;

            const enemy = await createEnemy(type, x, y);
            gameState.enemies.push(enemy);
            gameState.enemiesSpawned++;
        }

        // Update enemies
        function updateEnemies(deltaTime, currentTime, scrollMultiplier) {
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];

                enemy.time += deltaTime * 0.003;

                const prevX = enemy.position.x;

                if (enemy.movementPattern === 'sine') {
                    // Light enemies weave more aggressively, heavy enemies barely weave
                    const waveAmplitude = enemy.type === 'light' ? 3 : enemy.type === 'heavy' ? 1 : 2;
                    enemy.position.x = enemy.startX + Math.sin(enemy.time) * waveAmplitude;
                }

                enemy.position.y -= enemy.speed * settings.scrollSpeed * (0.5 + scrollMultiplier);

                const velocityX = enemy.position.x - prevX;
                const targetTilt = -velocityX * 8;
                const maxTilt = Math.PI / 6;
                const clampedTilt = Math.max(-maxTilt, Math.min(maxTilt, targetTilt));
                enemy.currentTilt += (clampedTilt - enemy.currentTilt) * 0.15;

                if (enemy.mesh) {
                    enemy.mesh.rotation.y = enemy.currentTilt;
                }

                // All enemy types except 'fast' can shoot
                if (enemy.type !== 'fast' &&
                    currentTime - enemy.lastFireTime > enemy.fireRate && playerShip) {

                    const dx = playerShip.position.x - enemy.position.x;
                    const dy = playerShip.position.y - enemy.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 0) {
                        // Heavy enemies fire slower but with spread pattern
                        if (enemy.type === 'heavy') {
                            // Heavy fires a 3-shot spread
                            const spreadAngles = [-0.2, 0, 0.2];
                            spreadAngles.forEach(angle => {
                                const cos = Math.cos(angle);
                                const sin = Math.sin(angle);
                                const vx = (dx / dist) * 0.08;
                                const vy = (dy / dist) * 0.08;
                                const rotatedVx = vx * cos - vy * sin;
                                const rotatedVy = vx * sin + vy * cos;
                                const bullet = createBullet(false, enemy.position.x, enemy.position.y - 0.3,
                                    rotatedVx, rotatedVy, enemy.damage);
                                gameState.enemyBullets.push(bullet);
                            });
                        } else {
                            // Normal single shot for other types
                            const bulletSpeed = enemy.type === 'light' ? 0.12 : 0.1;
                            const bullet = createBullet(false, enemy.position.x, enemy.position.y - 0.3,
                                (dx / dist) * bulletSpeed, (dy / dist) * bulletSpeed, enemy.damage);
                            gameState.enemyBullets.push(bullet);
                        }
                    }

                    enemy.lastFireTime = currentTime;
                }

                if (enemy.position.y < -orthoHeight - 2) {
                    // Enemy escaped - damage base shields
                    gameState.escapedEnemies++;
                    gameState.baseShields -= 10;
                    updateHUD();

                    // Show warning flash
                    const shieldsBar = document.getElementById('shieldsBarFill');
                    shieldsBar.style.background = '#ff4444';
                    setTimeout(() => {
                        shieldsBar.style.background = 'linear-gradient(90deg, #44aaff, #88ddff)';
                    }, 200);

                    if (gameState.baseShields <= 0) {
                        gameOver();
                    }

                    enemy.getChildMeshes().forEach(m => m.dispose());
                    enemy.dispose();
                    gameState.enemies.splice(i, 1);
                }
            }
        }

        // Update bullets
        function updateBullets() {
            for (let i = gameState.playerBullets.length - 1; i >= 0; i--) {
                const bullet = gameState.playerBullets[i];
                bullet.position.x += bullet.velocityX;
                bullet.position.y += bullet.velocityY;

                let bulletHit = false;
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    const dx = bullet.position.x - enemy.position.x;
                    const dy = bullet.position.y - enemy.position.y;
                    // Use elliptical hitbox - wider for wings
                    const hitX = dx / (enemy.hitboxWidth || 0.9);
                    const hitY = dy / (enemy.hitboxHeight || 0.6);
                    const dist = Math.sqrt(hitX * hitX + hitY * hitY);

                    if (dist < 1.0) {
                        enemy.health -= bullet.damage;

                        createExplosion(bullet.position.x, bullet.position.y, 'small', 'yellow');

                        bullet.dispose();
                        gameState.playerBullets.splice(i, 1);
                        bulletHit = true;

                        if (enemy.health <= 0) {
                            createExplosion(enemy.position.x, enemy.position.y, 'large', 'orange');
                            createLoot(enemy.position.x, enemy.position.y, enemy.type);

                            const points = enemy.type === 'shooter' ? 30 : enemy.type === 'fast' ? 20 : 10;
                            gameState.score += points * gameState.wave;
                            gameState.credits += 10 + Math.floor(Math.random() * 15);
                            updateHUD();

                            enemy.getChildMeshes().forEach(m => m.dispose());
                            enemy.dispose();
                            gameState.enemies.splice(j, 1);
                        } else {
                            flashShip(enemy.mesh);
                        }
                        break;
                    }
                }

                if (!bulletHit && bullet.position.y > orthoHeight + 2) {
                    bullet.dispose();
                    gameState.playerBullets.splice(i, 1);
                }
            }

            for (let i = gameState.enemyBullets.length - 1; i >= 0; i--) {
                const bullet = gameState.enemyBullets[i];
                bullet.position.x += bullet.velocityX;
                bullet.position.y += bullet.velocityY;

                if (playerShip) {
                    const dx = bullet.position.x - playerShip.position.x;
                    const dy = bullet.position.y - playerShip.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 0.5) {
                        createExplosion(bullet.position.x, bullet.position.y, 'small', 'orange');
                        flashShip(playerShipMesh);

                        gameState.health -= (bullet.damage || 10);
                        updateHUD();
                        bullet.dispose();
                        gameState.enemyBullets.splice(i, 1);

                        if (gameState.health <= 0) {
                            createExplosion(playerShip.position.x, playerShip.position.y, 'large', 'blue');
                            gameOver();
                        }
                        continue;
                    }
                }

                if (bullet.position.y < -orthoHeight - 2 || bullet.position.y > orthoHeight + 2 ||
                    bullet.position.x < -orthoWidth - 2 || bullet.position.x > orthoWidth + 2) {
                    bullet.dispose();
                    gameState.enemyBullets.splice(i, 1);
                }
            }
        }

        // Update stars
        function updateStars(scrollMultiplier) {
            const baseSpeed = 0.05 * settings.scrollSpeed;
            const adjustedSpeed = baseSpeed * (0.5 + scrollMultiplier);

            gameState.stars.forEach(star => {
                star.position.y -= star.speed * adjustedSpeed;

                if (star.position.y < -orthoHeight - 5) {
                    star.position.y = orthoHeight + 5;
                    star.position.x = (Math.random() - 0.5) * orthoWidth * 2.5;
                }
            });
        }

        // Check collisions
        function checkPlayerCollision() {
            if (!playerShip) return;

            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                const dx = playerShip.position.x - enemy.position.x;
                const dy = playerShip.position.y - enemy.position.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 0.7) {
                    const midX = (playerShip.position.x + enemy.position.x) / 2;
                    const midY = (playerShip.position.y + enemy.position.y) / 2;
                    createExplosion(midX, midY, 'large', 'orange');

                    createLoot(enemy.position.x, enemy.position.y, enemy.type);

                    flashShip(playerShipMesh);

                    gameState.health -= 25;
                    updateHUD();

                    enemy.getChildMeshes().forEach(m => m.dispose());
                    enemy.dispose();
                    gameState.enemies.splice(i, 1);

                    if (gameState.health <= 0) {
                        createExplosion(playerShip.position.x, playerShip.position.y, 'large', 'blue');
                        gameOver();
                    }
                }
            }
        }

        // Update HUD
        function updateHUD() {
            document.getElementById('creditsHud').textContent = gameState.credits;
            document.getElementById('health').textContent = Math.max(0, gameState.health);
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('wave').textContent = gameState.levelWave;
            document.getElementById('totalWaves').textContent = gameState.levelConfig ? gameState.levelConfig.waveCount : 3;

            // Update base shields
            const shieldsPercent = Math.max(0, gameState.baseShields);
            document.getElementById('shieldsBarFill').style.width = `${shieldsPercent}%`;
            document.getElementById('shieldsValue').textContent = Math.max(0, gameState.baseShields);
        }

        // Game over
        function gameOver() {
            gameState.isPlaying = false;
            document.getElementById('finalCredits').textContent = gameState.credits;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('harvestBar').style.display = 'none';
            document.getElementById('planetInfo').style.display = 'none';
            updateTargetingOverlay(null);
        }

        // Reset game
        async function resetGame() {
            gameState.enemies.forEach(enemy => {
                enemy.getChildMeshes().forEach(m => m.dispose());
                enemy.dispose();
            });
            gameState.enemies = [];

            gameState.playerBullets.forEach(b => b.dispose());
            gameState.playerBullets = [];
            gameState.enemyBullets.forEach(b => b.dispose());
            gameState.enemyBullets = [];

            gameState.loot.forEach(l => {
                l.getChildMeshes().forEach(m => m.dispose());
                l.dispose();
            });
            gameState.loot = [];

            gameState.planets.forEach(p => p.dispose());
            gameState.planets = [];

            gameState.suns.forEach(s => {
                if (s.coronas) {
                    s.coronas.forEach(c => c.dispose());
                }
                if (s.sunMesh) {
                    s.sunMesh.dispose();
                }
                s.dispose();
            });
            gameState.suns = [];

            gameState.score = 0;
            gameState.health = 100;
            gameState.wave = 1;
            gameState.lastFireTime = 0;
            gameState.waveTimer = 0;
            gameState.enemiesInWave = 0;
            gameState.enemiesSpawned = 0;
            gameState.nextSolarSystemY = orthoHeight + 15;
            gameState.harvestingPlanet = null;
            gameState.harvestProgress = 0;
            gameState.baseShields = 100;
            gameState.escapedEnemies = 0;
            gameState.pendingNotifications = {};
            gameState.lastFrameTime = performance.now();
            gameState.spawnTimer = 0;

            // Reset zone state
            gameState.currentZone = 0;
            gameState.distanceTraveled = 0;
            gameState.backgroundTransition = 0;
            gameState.transitionPhase = 0;

            // Reset background to first zone
            if (backgroundMaterialA && backgroundMaterialA.diffuseTexture) {
                backgroundMaterialA.diffuseTexture.dispose();
                const bgSize = Math.max(orthoWidth, orthoHeight) * 3;
                const textureA = new BABYLON.Texture(getBackgroundPath(0), scene);
                textureA.uScale = bgSize / 20;
                textureA.vScale = bgSize * 2 / 20;
                textureA.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;
                textureA.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;
                textureA.vOffset = 0;
                backgroundMaterialA.diffuseTexture = textureA;
                backgroundMaterialA.emissiveTexture = textureA;
            }
            if (backgroundMaterialB) {
                backgroundMaterialB.alpha = 0;
            }

            // Reset starbase and weapons
            if (gameState.starbase) {
                gameState.starbase.dispose();
                gameState.starbase = null;
            }
            if (gameState.beamMesh) {
                gameState.beamMesh.dispose();
                gameState.beamMesh = null;
            }
            gameState.isDocked = false;
            gameState.credits = settings.debugMode ? 1000 : 0;

            // Initialize fleet with starter ship and basic weapon
            const starterWeapon = { ...WEAPONS.basic };
            gameState.fleet = [{
                name: SHIP_DEFINITIONS.starter.name,
                model: SHIP_DEFINITIONS.starter.model,
                hardpoints: SHIP_DEFINITIONS.starter.hardpoints.map((hp, idx) => ({
                    ...hp,
                    equipped: idx === 0 ? starterWeapon : null  // Basic weapon on first hardpoint
                }))
            }];
            gameState.ownedWeapons = [starterWeapon];
            gameState.equippedWeapons = [starterWeapon, null];  // First hardpoint has weapon, second empty
            gameState.stationWeapons = [];
            gameState.weaponFireTimes = {};
            if (gameState.beamMeshes) {
                gameState.beamMeshes.forEach(b => b.dispose());
            }
            gameState.beamMeshes = [];

            // Reset level/river navigation state
            gameState.level = 1;
            gameState.levelWave = 0;
            gameState.stationsVisited = 0;
            gameState.levelEndSpawned = false;
            // Generate initial level config
            gameState.levelConfig = generateLevelConfig(1);
            // Clean up any existing warp gates
            gameState.warpGates.forEach(gate => {
                if (sunGlowLayer) sunGlowLayer.removeIncludedOnlyMesh(gate);
                gate.dispose();
            });
            gameState.warpGates = [];
            gameState.gateChoices = null;
            gameState.showingGates = false;
            document.getElementById('warpGatePanel').style.display = 'none';
            document.getElementById('stationInterior').style.display = 'none';

            initResources();

            if (playerShip) {
                playerShip.position.x = 0;
                playerShip.position.y = -7;
                playerShip.targetX = 0;
                playerShip.targetY = -7;
            }

            updateHUD();
            spawnWave();
        }

        // =====================
        // SAVE/LOAD SYSTEM
        // =====================
        const SAVE_KEY = 'spacerun_save';

        function getSaveableState() {
            return {
                score: gameState.score,
                health: gameState.health,
                wave: gameState.wave,
                level: gameState.level,
                levelWave: gameState.levelWave,
                levelConfig: gameState.levelConfig,
                stationsVisited: gameState.stationsVisited,
                currentZone: gameState.currentZone,
                levelEndSpawned: gameState.levelEndSpawned,
                credits: gameState.credits,
                ownedWeapons: gameState.ownedWeapons,
                equippedWeapon: gameState.equippedWeapon,
                fleet: gameState.fleet,
                baseShields: gameState.baseShields,
                resources: gameState.resources,
                distanceTraveled: gameState.distanceTraveled,
                wavesUntilStarbase: gameState.wavesUntilStarbase,
                savedAt: Date.now()
            };
        }

        function saveGame() {
            try {
                const saveData = getSaveableState();
                localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
                return true;
            } catch (e) {
                console.error('Failed to save game:', e);
                return false;
            }
        }

        function loadGame() {
            try {
                const saveStr = localStorage.getItem(SAVE_KEY);
                if (!saveStr) return null;
                return JSON.parse(saveStr);
            } catch (e) {
                console.error('Failed to load game:', e);
                return null;
            }
        }

        function hasSavedGame() {
            return localStorage.getItem(SAVE_KEY) !== null;
        }

        // Check if game should remain paused (used to prevent accidental unpause)
        // Add new conditions here as features are added (tutorials, planet landing, etc.)
        function shouldRemainPaused() {
            // Check if docked at station
            if (gameState.isDocked) return true;
            // Check if any modal dialogs are open
            if (document.getElementById('settingsPanel').style.display === 'block') return true;
            if (document.getElementById('confirmDialog').style.display === 'block') return true;
            // Check if station interior is visible
            if (document.getElementById('stationInterior').style.display !== 'none') return true;
            // Future: add checks for tutorials, planet landing screens, etc.
            return false;
        }

        function deleteSave() {
            localStorage.removeItem(SAVE_KEY);
        }

        function applySavedState(saveData) {
            if (!saveData) return;

            gameState.score = saveData.score || 0;
            gameState.health = saveData.health || 100;
            gameState.wave = saveData.wave || 1;
            gameState.level = saveData.level || 1;
            gameState.levelWave = saveData.levelWave || 0;
            gameState.levelConfig = saveData.levelConfig || generateLevelConfig(1);
            gameState.stationsVisited = saveData.stationsVisited || 0;
            gameState.currentZone = saveData.currentZone || 0;
            gameState.levelEndSpawned = saveData.levelEndSpawned || false;
            gameState.credits = saveData.credits || 0;
            gameState.ownedWeapons = saveData.ownedWeapons || ['basic'];
            gameState.equippedWeapon = saveData.equippedWeapon || 'basic';

            // Restore fleet, or create default if not present (backward compatibility)
            if (saveData.fleet && saveData.fleet.length > 0) {
                gameState.fleet = saveData.fleet;
            } else {
                // Create default fleet for old saves
                const starterWeapon = { ...WEAPONS.basic, id: 'basic_' + Date.now() };
                gameState.fleet = [{
                    name: SHIP_DEFINITIONS.starter.name,
                    model: SHIP_DEFINITIONS.starter.model,
                    hardpoints: SHIP_DEFINITIONS.starter.hardpoints.map((hp, idx) => ({
                        ...hp,
                        equipped: idx === 0 ? starterWeapon : null
                    }))
                }];
                // Also ensure ownedWeapons has the starter weapon
                if (!gameState.ownedWeapons || gameState.ownedWeapons.length === 0) {
                    gameState.ownedWeapons = [starterWeapon];
                }
            }

            gameState.baseShields = saveData.baseShields || 100;
            gameState.resources = saveData.resources || {};
            gameState.distanceTraveled = saveData.distanceTraveled || 0;
            gameState.wavesUntilStarbase = saveData.wavesUntilStarbase || 1;

            // Update zone background
            if (backgroundMaterialA && backgroundMaterialA.diffuseTexture) {
                backgroundMaterialA.diffuseTexture.dispose();
                const bgSize = Math.max(orthoWidth, orthoHeight) * 3;
                const textureA = new BABYLON.Texture(getBackgroundPath(gameState.currentZone), scene);
                textureA.uScale = bgSize / 20;
                textureA.vScale = bgSize * 2 / 20;
                textureA.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;
                textureA.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;
                textureA.vOffset = 0;
                backgroundMaterialA.diffuseTexture = textureA;
                backgroundMaterialA.emissiveTexture = textureA;
            }

            updateHUD();
        }

        function showSavedNotification() {
            const notification = document.getElementById('savedNotification');
            notification.style.display = 'block';
            // Reset animation
            notification.style.animation = 'none';
            notification.offsetHeight; // Trigger reflow
            notification.style.animation = 'fadeInOut 2s ease-in-out';
            setTimeout(() => {
                notification.style.display = 'none';
            }, 2000);
        }

        // Auto-save on visibility change (tab hidden/app paused)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && gameState.isPlaying && !gameState.isDocked) {
                saveGame();
                console.log('Auto-saved on pause');
            }
        });

        // =====================
        // SYSTEM MENU UI
        // =====================
        const systemBtn = document.getElementById('systemBtn');
        const systemMenu = document.getElementById('systemMenu');
        const settingsPanel = document.getElementById('settingsPanel');
        const closeSettings = document.getElementById('closeSettings');
        const confirmDialog = document.getElementById('confirmDialog');

        systemBtn.addEventListener('click', () => {
            const isVisible = systemMenu.style.display === 'block';
            systemMenu.style.display = isVisible ? 'none' : 'block';
            if (!isVisible) {
                gameState.isPaused = true;
            }
        });

        // Close system menu when clicking elsewhere
        document.addEventListener('click', (e) => {
            if (!systemBtn.contains(e.target) && !systemMenu.contains(e.target) &&
                !settingsPanel.contains(e.target) && !confirmDialog.contains(e.target)) {
                systemMenu.style.display = 'none';
                // Only unpause if nothing else requires pause
                if (!shouldRemainPaused()) {
                    gameState.isPaused = false;
                }
            }
        });

        // Settings menu item
        document.getElementById('menuSettings').addEventListener('click', () => {
            systemMenu.style.display = 'none';
            settingsPanel.style.display = 'block';
            gameState.isPaused = true;
        });

        closeSettings.addEventListener('click', () => {
            settingsPanel.style.display = 'none';
            // Only unpause if nothing else requires pause
            if (!shouldRemainPaused()) {
                gameState.isPaused = false;
            }
        });

        // Save & Quit menu item
        document.getElementById('menuSaveQuit').addEventListener('click', () => {
            systemMenu.style.display = 'none';
            saveGame();
            showSavedNotification();

            // Return to start screen after delay
            setTimeout(() => {
                gameState.isPlaying = false;
                gameState.isPaused = false;
                document.getElementById('hud').style.display = 'none';
                document.getElementById('shieldsDisplay').style.display = 'none';
                systemBtn.style.display = 'none';
                document.getElementById('startScreen').style.display = 'flex';
                document.getElementById('titleButtons').style.display = 'flex';
                document.getElementById('loadingScreen').style.display = 'none';
                document.getElementById('continueBtn').style.display = 'block';
            }, 500);
        });

        // New Game menu item
        document.getElementById('menuNewGame').addEventListener('click', () => {
            systemMenu.style.display = 'none';
            confirmDialog.style.display = 'block';
            gameState.isPaused = true;
        });

        // Confirm New Game
        document.getElementById('confirmNewGame').addEventListener('click', async () => {
            confirmDialog.style.display = 'none';
            deleteSave();
            await resetGame();
            gameState.isPaused = false;
            gameState.isPlaying = true;
        });

        // Cancel New Game
        document.getElementById('cancelNewGame').addEventListener('click', () => {
            confirmDialog.style.display = 'none';
            // Only unpause if nothing else requires pause
            if (!shouldRemainPaused()) {
                gameState.isPaused = false;
            }
        });

        function setupSlider(id, settingKey, suffix = '', multiplier = 1) {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(id + 'Value');

            slider.addEventListener('input', () => {
                const value = parseFloat(slider.value);
                settings[settingKey] = value * multiplier;
                valueDisplay.textContent = value + suffix;
            });
        }

        setupSlider('xSensitivity', 'xSensitivity');
        setupSlider('ySensitivity', 'ySensitivity');
        setupSlider('maxHeight', 'maxHeight', '%', 0.01);
        setupSlider('shipSpeed', 'shipSpeed', 'x');
        setupSlider('fireRate', 'fireRate', 'x');
        setupSlider('scrollSpeed', 'scrollSpeed', 'x');

        // Debug mode checkbox
        const debugModeCheckbox = document.getElementById('debugMode');
        debugModeCheckbox.checked = settings.debugMode;
        debugModeCheckbox.addEventListener('change', () => {
            settings.debugMode = debugModeCheckbox.checked;
            localStorage.setItem('debugMode', settings.debugMode);
        });

        // Start game
        const startScreen = document.getElementById('startScreen');
        const newGameBtn = document.getElementById('newGameBtn');
        const continueBtn = document.getElementById('continueBtn');
        const restartBtn = document.getElementById('restartBtn');
        const gameOverPanel = document.getElementById('gameOver');
        const titleButtons = document.getElementById('titleButtons');
        const loadingScreen = document.getElementById('loadingScreen');

        // Show continue button if there's a saved game
        if (hasSavedGame()) {
            continueBtn.style.display = 'block';
        }

        async function startGame(loadSave) {
            // Show loading screen
            titleButtons.style.display = 'none';
            loadingScreen.style.display = 'flex';

            // Small delay to show loading screen before heavy work
            await new Promise(resolve => setTimeout(resolve, 50));

            // Create main scene first
            createMainScene();
            await createPlayerShip();
            initResources();

            // Load complete, hide start screen
            startScreen.style.display = 'none';
            document.getElementById('systemBtn').style.display = 'flex';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('shieldsDisplay').style.display = 'flex';

            if (loadSave) {
                const savedGame = loadGame();
                if (savedGame) {
                    applySavedState(savedGame);
                }
            } else {
                // New game - clear any existing save
                deleteSave();

                // Debug mode: start with 1000 credits
                if (settings.debugMode) {
                    gameState.credits = 1000;
                }

                // Initialize fleet with starter ship and basic weapon
                const starterWeapon = { ...WEAPONS.basic, id: 'basic_' + Date.now() };
                gameState.fleet = [{
                    name: SHIP_DEFINITIONS.starter.name,
                    model: SHIP_DEFINITIONS.starter.model,
                    hardpoints: SHIP_DEFINITIONS.starter.hardpoints.map((hp, idx) => ({
                        ...hp,
                        equipped: idx === 0 ? starterWeapon : null
                    }))
                }];
                gameState.ownedWeapons = [starterWeapon];

                // Initialize first level
                gameState.level = 1;
                gameState.levelWave = 0;
                gameState.levelConfig = generateLevelConfig(1);
                gameState.wavesUntilStarbase = gameState.levelConfig.waveCount;
            }

            spawnWave();

            // Initialize solar system spawning
            gameState.nextSolarSystemY = orthoHeight + 15;
            gameState.baseShields = 100;

            gameState.isPlaying = true;
            gameState.lastFrameTime = performance.now();
            gameState.spawnTimer = 0;

            scene.registerBeforeRender(() => {
                if (!gameState.isPlaying || gameState.isPaused) return;

                const currentTime = performance.now();
                let deltaTime = Math.min(currentTime - gameState.lastFrameTime, 50);
                gameState.lastFrameTime = currentTime;

                // Apply speed-up multiplier when button is pressed
                const speedMultiplier = gameState.speedUp ? 8 : 1;
                deltaTime *= speedMultiplier;

                // Update speed-up button visibility
                updateSpeedUpButton();

                const scrollMultiplier = updatePlayerPosition(deltaTime) * speedMultiplier;
                updateBackgrounds(scrollMultiplier, deltaTime);
                firePlayerWeapons(currentTime);

                gameState.spawnTimer += deltaTime;
                if (gameState.spawnTimer > 800 && gameState.enemiesSpawned < gameState.enemiesInWave) {
                    spawnEnemy();
                    gameState.spawnTimer = 0;
                }

                // Spawn solar systems with spacing - only during active waves
                // Stop spawning once level end content (reward + gates) has been generated
                const shouldSpawnSolarSystems = !gameState.levelEndSpawned && !gameState.showingGates;

                gameState.nextSolarSystemY -= 0.015 * settings.scrollSpeed * (0.5 + scrollMultiplier);
                if (gameState.nextSolarSystemY < orthoHeight + 10 && shouldSpawnSolarSystems) {
                    createSolarSystem();
                }

                // Update suns and apply lighting
                updateSuns(scrollMultiplier);
                applySunLighting();

                if (gameState.enemiesSpawned >= gameState.enemiesInWave && gameState.enemies.length === 0 && !gameState.starbase && !gameState.showingGates && !gameState.levelEndSpawned) {
                    gameState.wave++;
                    gameState.levelWave++;
                    updateHUD();

                    const config = gameState.levelConfig;

                    // Check if level complete (all waves done)
                    if (gameState.levelWave >= config.waveCount) {
                        // Level complete - generate reward zone and gates
                        // Both are spawned at specific Y positions, scrolling reveals them naturally
                        generateLevelEndContent();
                    } else {
                        // Check if a station should appear after this wave
                        const shouldSpawnStation = config.stationWaves &&
                            config.stationWaves.includes(gameState.levelWave) &&
                            gameState.stationsVisited < config.stations.length;

                        if (shouldSpawnStation) {
                            createStarbase();
                            gameState.stationsVisited++;
                        } else {
                            spawnWave();
                        }
                    }
                }

                // Update warp gates
                updateWarpGates(scrollMultiplier, deltaTime);

                updateEnemies(deltaTime, currentTime, scrollMultiplier);
                updateBullets();
                updateLoot(scrollMultiplier);
                updatePlanets(scrollMultiplier, deltaTime);
                updateStarbase(scrollMultiplier, deltaTime);
                checkPlayerCollision();
            });

            engine.runRenderLoop(() => {
                scene.render();
            });
        }

        // Button event handlers
        newGameBtn.addEventListener('click', () => startGame(false));
        continueBtn.addEventListener('click', () => startGame(true));

        restartBtn.addEventListener('click', async () => {
            gameOverPanel.style.display = 'none';
            await resetGame();
            spawnWave();
            gameState.isPlaying = true;
        });

        // Initialize station interior navigation
        initStationNav();

        // Speed-up button handlers
        const speedUpBtn = document.getElementById('speedUpBtn');
        speedUpBtn.addEventListener('mousedown', () => {
            if (!speedUpBtn.disabled) {
                gameState.speedUp = true;
                speedUpBtn.classList.add('active');
            }
        });
        speedUpBtn.addEventListener('mouseup', () => {
            gameState.speedUp = false;
            speedUpBtn.classList.remove('active');
        });
        speedUpBtn.addEventListener('mouseleave', () => {
            gameState.speedUp = false;
            speedUpBtn.classList.remove('active');
        });
        speedUpBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!speedUpBtn.disabled) {
                gameState.speedUp = true;
                speedUpBtn.classList.add('active');
            }
        });
        speedUpBtn.addEventListener('touchend', () => {
            gameState.speedUp = false;
            speedUpBtn.classList.remove('active');
        });

        // Update speed-up button visibility
        function updateSpeedUpButton() {
            const btn = document.getElementById('speedUpBtn');
            if (!gameState.isPlaying || gameState.isPaused || gameState.isDocked) {
                btn.style.display = 'none';
                return;
            }

            // Hide when enemies are on screen
            const hasEnemies = gameState.enemies.length > 0;

            if (hasEnemies) {
                btn.style.display = 'none';
                gameState.speedUp = false;
            } else {
                btn.style.display = 'block';
            }
        }

        window.addEventListener('resize', () => {
            engine.resize();
            updateGameDimensions();
        });
    </script>
</body>
</html>
