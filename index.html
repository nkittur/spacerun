<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Run - Bullet Hell Shooter</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #gameContainer {
            width: 100%;
            height: 100%;
            max-width: 500px;
            margin: 0 auto;
            position: relative;
            background: #000;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        #settingsBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #settingsBtn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        #settingsPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #4488ff;
            border-radius: 15px;
            padding: 25px;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            z-index: 200;
            display: none;
            min-width: 300px;
            max-width: 90%;
            box-shadow: 0 0 30px rgba(68, 136, 255, 0.5);
        }

        #settingsPanel h2 {
            text-align: center;
            margin-bottom: 20px;
            color: #4488ff;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .setting-group {
            margin-bottom: 15px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #aaccff;
        }

        .setting-group input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: #223355;
            border-radius: 4px;
            outline: none;
        }

        .setting-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #4488ff;
            border-radius: 50%;
            cursor: pointer;
        }

        .setting-value {
            text-align: right;
            font-size: 12px;
            color: #88aadd;
            margin-top: 3px;
        }

        #closeSettings {
            width: 100%;
            padding: 12px;
            margin-top: 15px;
            background: #4488ff;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #closeSettings:hover {
            background: #5599ff;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 14px;
            z-index: 50;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
        }

        #hud div {
            margin-bottom: 3px;
        }

        #shieldsDisplay {
            position: absolute;
            top: 10px;
            right: 60px;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 14px;
            z-index: 50;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #shieldsBar {
            width: 100px;
            height: 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #44aaff;
            border-radius: 6px;
            overflow: hidden;
        }

        #shieldsBarFill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #44aaff, #88ddff);
            transition: width 0.3s ease;
        }

        /* Resource collection notifications below top UI */
        #collectNotifications {
            position: absolute;
            top: 45px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 70;
            pointer-events: none;
        }

        .collect-notif {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 6px;
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 14px;
            font-weight: bold;
            animation: collectPop 2s forwards;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .collect-notif .symbol {
            width: 22px;
            height: 22px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: #000;
        }

        .collect-notif .amount {
            color: #fff;
        }

        @keyframes collectPop {
            0% { opacity: 0; transform: translateY(10px) scale(0.8); }
            10% { opacity: 1; transform: translateY(0) scale(1.1); }
            20% { transform: translateY(0) scale(1); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-10px); }
        }

        /* Harvest progress bar - positioned on planet */
        #harvestBar {
            position: absolute;
            height: 6px;
            background: rgba(0, 0, 0, 0.6);
            overflow: hidden;
            display: none;
            z-index: 60;
            border-radius: 3px;
        }

        #harvestBarFill {
            height: 100%;
            width: 0%;
            background: #44ffaa;
            transition: width 0.1s linear;
        }

        /* Targeting corners overlay */
        #targetingOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 55;
        }

        .targeting-corner {
            position: absolute;
            width: 20px;
            height: 20px;
            border-color: #44ffaa;
            border-style: solid;
            border-width: 0;
        }

        .targeting-corner.top-left {
            border-top-width: 3px;
            border-left-width: 3px;
        }

        .targeting-corner.top-right {
            border-top-width: 3px;
            border-right-width: 3px;
        }

        .targeting-corner.bottom-left {
            border-bottom-width: 3px;
            border-left-width: 3px;
        }

        .targeting-corner.bottom-right {
            border-bottom-width: 3px;
            border-right-width: 3px;
        }

        /* Planet info indicators - subtle and translucent */
        #planetInfo {
            position: absolute;
            display: none;
            flex-direction: row;
            gap: 12px;
            z-index: 56;
            pointer-events: none;
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 12px;
        }

        .planet-stat {
            display: flex;
            align-items: center;
            gap: 2px;
            opacity: 0.6;
        }

        .planet-stat.richness {
            color: #ffdd44;
            text-shadow: 0 0 4px rgba(255, 221, 68, 0.5);
        }

        .planet-stat.hazard {
            color: #ff6644;
            text-shadow: 0 0 4px rgba(255, 102, 68, 0.5);
        }

        /* Docking/Starbase screen */
        #dockingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 10, 20, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            z-index: 200;
            font-family: 'Segoe UI', Arial, sans-serif;
            color: white;
            overflow-y: auto;
        }

        #dockingScreen h2 {
            color: #44aaff;
            font-size: 24px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #dockingCredits {
            color: #ffdd44;
            font-size: 18px;
            margin-bottom: 20px;
        }

        .upgrade-section {
            width: 100%;
            max-width: 350px;
            margin-bottom: 20px;
        }

        .upgrade-section h3 {
            color: #88aadd;
            font-size: 14px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid #334;
            padding-bottom: 5px;
        }

        .upgrade-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(30, 40, 60, 0.8);
            border: 1px solid #335;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
        }

        .upgrade-item.owned {
            border-color: #44aa44;
            background: rgba(40, 60, 40, 0.5);
        }

        .upgrade-item.equipped {
            border-color: #44aaff;
            background: rgba(40, 60, 80, 0.5);
        }

        .upgrade-info {
            flex: 1;
        }

        .upgrade-name {
            font-size: 14px;
            font-weight: bold;
            color: #fff;
        }

        .upgrade-desc {
            font-size: 11px;
            color: #88aacc;
            margin-top: 3px;
        }

        .upgrade-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
        }

        .upgrade-btn.buy {
            background: #44aa44;
            color: white;
        }

        .upgrade-btn.buy:disabled {
            background: #444;
            color: #666;
            cursor: not-allowed;
        }

        .upgrade-btn.equip {
            background: #4488ff;
            color: white;
        }

        .upgrade-btn.equipped {
            background: #335;
            color: #88aacc;
        }

        #departBtn {
            padding: 15px 50px;
            background: #ff8844;
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 20px;
        }

        #departBtn:hover {
            background: #ffaa66;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #ff4444;
            border-radius: 15px;
            padding: 30px 50px;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            z-index: 150;
            display: none;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 68, 68, 0.5);
        }

        #gameOver h2 {
            color: #ff4444;
            font-size: 32px;
            margin-bottom: 15px;
        }

        #gameOver p {
            font-size: 18px;
            margin-bottom: 20px;
        }

        #restartBtn {
            padding: 12px 30px;
            background: #ff4444;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            text-transform: uppercase;
        }

        #restartBtn:hover {
            background: #ff5555;
        }

        /* Warp Gate Selection UI */
        #warpGatePanel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 20px;
            z-index: 80;
            font-family: 'Segoe UI', Arial, sans-serif;
        }

        .warp-gate-card {
            background: rgba(10, 15, 30, 0.9);
            border: 2px solid #4488ff;
            border-radius: 12px;
            padding: 15px;
            width: 150px;
            color: white;
            text-align: center;
            box-shadow: 0 0 20px rgba(68, 136, 255, 0.3);
            transition: all 0.2s ease;
        }

        .warp-gate-card:hover {
            border-color: #66aaff;
            box-shadow: 0 0 30px rgba(68, 136, 255, 0.5);
        }

        .warp-gate-card.left {
            border-color: #ff8844;
            box-shadow: 0 0 20px rgba(255, 136, 68, 0.3);
        }

        .warp-gate-card.left:hover {
            border-color: #ffaa66;
            box-shadow: 0 0 30px rgba(255, 136, 68, 0.5);
        }

        .warp-gate-card.right {
            border-color: #44ff88;
            box-shadow: 0 0 20px rgba(68, 255, 136, 0.3);
        }

        .warp-gate-card.right:hover {
            border-color: #66ffaa;
            box-shadow: 0 0 30px rgba(68, 255, 136, 0.5);
        }

        .gate-title {
            font-size: 12px;
            color: #88aadd;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .gate-signature {
            font-size: 11px;
            line-height: 1.6;
        }

        .gate-stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .gate-stat-label {
            color: #88aacc;
        }

        .gate-stat-value {
            font-weight: bold;
        }

        .gate-stat-value.danger {
            color: #ff6644;
        }

        .gate-stat-value.medium {
            color: #ffaa44;
        }

        .gate-stat-value.safe {
            color: #44ff88;
        }

        .gate-instruction {
            margin-top: 10px;
            font-size: 10px;
            color: #668899;
            font-style: italic;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #0a0a20 0%, #1a1a40 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            z-index: 300;
            font-family: 'Segoe UI', Arial, sans-serif;
            color: white;
            padding-top: 20px;
            overflow-y: auto;
        }

        #startScreen h1 {
            font-size: 36px;
            color: #4488ff;
            text-shadow: 0 0 20px rgba(68, 136, 255, 0.8);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        #startScreen p {
            font-size: 14px;
            color: #aaccff;
            margin-bottom: 15px;
            text-align: center;
            max-width: 80%;
            line-height: 1.4;
        }

        #modelGrid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            padding: 10px;
            max-width: 100%;
            width: 100%;
        }

        .model-card {
            background: rgba(30, 30, 60, 0.8);
            border: 1px solid #334;
            border-radius: 8px;
            padding: 5px;
            text-align: center;
        }

        .model-card canvas {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 4px;
            background: #111;
        }

        .model-card .model-name {
            font-size: 11px;
            color: #88aadd;
            margin-top: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #startBtn {
            padding: 15px 50px;
            background: #4488ff;
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 20px rgba(68, 136, 255, 0.5);
            margin: 20px 0;
        }

        #startBtn:hover {
            background: #5599ff;
            box-shadow: 0 0 30px rgba(68, 136, 255, 0.8);
        }

        #loadingText {
            color: #4488ff;
            font-size: 18px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
    <canvas id="renderCanvas"></canvas>

    <div id="startScreen">
        <h1>Space Run</h1>
        <p>Drag or use Arrow Keys/WASD to move ship.<br>Weapons fire automatically! Harvest planets for resources!</p>
        <button id="startBtn" style="display: none;">Start Game</button>
        <div id="loadingText">Loading models...</div>
        <div id="modelGrid"></div>
    </div>

    <button id="settingsBtn" style="display: none;">âš™</button>

    <div id="settingsPanel">
        <h2>Settings</h2>
        <div class="setting-group">
            <label>X Sensitivity (Horizontal)</label>
            <input type="range" id="xSensitivity" min="0.5" max="3" step="0.1" value="1.5">
            <div class="setting-value" id="xSensitivityValue">1.5</div>
        </div>
        <div class="setting-group">
            <label>Y Sensitivity (Vertical)</label>
            <input type="range" id="ySensitivity" min="0.5" max="3" step="0.1" value="1.2">
            <div class="setting-value" id="ySensitivityValue">1.2</div>
        </div>
        <div class="setting-group">
            <label>Max Ship Height (% of screen)</label>
            <input type="range" id="maxHeight" min="30" max="70" step="5" value="50">
            <div class="setting-value" id="maxHeightValue">50%</div>
        </div>
        <div class="setting-group">
            <label>Ship Speed</label>
            <input type="range" id="shipSpeed" min="0.5" max="2" step="0.1" value="1">
            <div class="setting-value" id="shipSpeedValue">1.0x</div>
        </div>
        <div class="setting-group">
            <label>Fire Rate</label>
            <input type="range" id="fireRate" min="0.5" max="3" step="0.1" value="1">
            <div class="setting-value" id="fireRateValue">1.0x</div>
        </div>
        <div class="setting-group">
            <label>Scroll Speed</label>
            <input type="range" id="scrollSpeed" min="0.5" max="2" step="0.1" value="1">
            <div class="setting-value" id="scrollSpeedValue">1.0x</div>
        </div>
        <button id="closeSettings">Close</button>
    </div>

    <div id="hud" style="display: none;">
        <div>Score: <span id="score">0</span></div>
        <div>Health: <span id="health">100</span></div>
        <div>Level: <span id="level">1</span> | Wave: <span id="wave">1</span>/<span id="totalWaves">3</span></div>
    </div>

    <div id="shieldsDisplay" style="display: none;">
        <span>Base:</span>
        <div id="shieldsBar"><div id="shieldsBarFill"></div></div>
        <span id="shieldsValue">100</span>
    </div>

    <div id="collectNotifications"></div>

    <div id="harvestBar"><div id="harvestBarFill"></div></div>
    <div id="targetingOverlay">
        <div class="targeting-corner top-left"></div>
        <div class="targeting-corner top-right"></div>
        <div class="targeting-corner bottom-left"></div>
        <div class="targeting-corner bottom-right"></div>
    </div>
    <div id="planetInfo">
        <div class="planet-stat richness"><span id="richnessIcon">ðŸ’Ž</span><span id="richnessValue"></span></div>
        <div class="planet-stat hazard"><span id="hazardIcon">âš </span><span id="hazardValue"></span></div>
    </div>

    <div id="dockingScreen">
        <h2>âš“ Starbase</h2>
        <div id="dockingCredits">Credits: <span id="creditsDisplay">0</span></div>

        <div class="upgrade-section">
            <h3>Weapons</h3>
            <div id="weaponsList"></div>
        </div>

        <button id="departBtn">Depart</button>
    </div>

    <div id="warpGatePanel">
        <div class="warp-gate-card left" id="gateLeft">
            <div class="gate-title">Gate Alpha</div>
            <div class="gate-signature">
                <div class="gate-stat">
                    <span class="gate-stat-label">Threat:</span>
                    <span class="gate-stat-value" id="gateLeftThreat">Medium</span>
                </div>
                <div class="gate-stat">
                    <span class="gate-stat-label">Waves:</span>
                    <span class="gate-stat-value" id="gateLeftWaves">3</span>
                </div>
                <div class="gate-stat">
                    <span class="gate-stat-label">Stations:</span>
                    <span class="gate-stat-value" id="gateLeftStations">1 Trade</span>
                </div>
            </div>
            <div class="gate-instruction">Fly into gate</div>
        </div>
        <div class="warp-gate-card right" id="gateRight">
            <div class="gate-title">Gate Beta</div>
            <div class="gate-signature">
                <div class="gate-stat">
                    <span class="gate-stat-label">Threat:</span>
                    <span class="gate-stat-value" id="gateRightThreat">High</span>
                </div>
                <div class="gate-stat">
                    <span class="gate-stat-label">Waves:</span>
                    <span class="gate-stat-value" id="gateRightWaves">5</span>
                </div>
                <div class="gate-stat">
                    <span class="gate-stat-label">Stations:</span>
                    <span class="gate-stat-value" id="gateRightStations">2 Armory</span>
                </div>
            </div>
            <div class="gate-instruction">Fly into gate</div>
        </div>
    </div>

    <div id="gameOver">
        <h2>Game Over</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button id="restartBtn">Play Again</button>
    </div>
    </div><!-- end gameContainer -->

    <script>
        // Ship model names
        const shipNames = ['Bob', 'Challenger', 'Dispatcher', 'Executioner', 'Imperial',
                          'Insurgent', 'Omen', 'Pancake', 'Spitfire', 'Striker', 'Zenith'];
        const colorVariants = ['Blue', 'Green', 'Orange', 'Purple', 'Red'];

        // Resource types with colors for display
        const RESOURCES = {
            Iron: { color: '#aaaaaa', symbol: 'Fe' },
            Copper: { color: '#dd8844', symbol: 'Cu' },
            Silicon: { color: '#88aacc', symbol: 'Si' },
            Titanium: { color: '#ccccee', symbol: 'Ti' },
            Hydrogen: { color: '#aaddff', symbol: 'H' },
            Helium: { color: '#ffddaa', symbol: 'He' },
            Water: { color: '#4488ff', symbol: 'H2O' },
            Carbon: { color: '#444444', symbol: 'C' },
            Oxygen: { color: '#aaffaa', symbol: 'O' },
            Sulfur: { color: '#dddd44', symbol: 'S' },
            Nitrogen: { color: '#aaaaff', symbol: 'N' },
            Gold: { color: '#ffdd00', symbol: 'Au' }
        };

        // Planet types with their resources and image paths
        const PLANET_TYPES = {
            // Gaseous planets - yield gases
            BlueGiant: {
                category: 'Gaseous', folder: 'Blue Giant', prefix: 'BlueGiant',
                resources: { Hydrogen: [30, 50], Helium: [20, 40] }, harvests: 2, tint: [0.7, 0.8, 1.0]
            },
            GreenGiant: {
                category: 'Gaseous', folder: 'Green Giant', prefix: 'GreenGiant',
                resources: { Hydrogen: [25, 45], Nitrogen: [15, 30] }, harvests: 2, tint: [0.7, 1.0, 0.8]
            },
            OrangeGiant: {
                category: 'Gaseous', folder: 'Orange Giant', prefix: 'OrgangeGiant',
                resources: { Helium: [35, 55], Hydrogen: [20, 35] }, harvests: 2, tint: [1.0, 0.8, 0.6]
            },
            RedGiant: {
                category: 'Gaseous', folder: 'Red Giant', prefix: 'RedGiant',
                resources: { Hydrogen: [40, 60], Helium: [25, 40] }, harvests: 3, tint: [1.0, 0.7, 0.7]
            },
            YellowGiant: {
                category: 'Gaseous', folder: 'Yellow Giant', prefix: 'YellowGiant',
                resources: { Helium: [30, 50], Hydrogen: [25, 40] }, harvests: 2, tint: [1.0, 1.0, 0.8]
            },
            // Rocky planets - yield metals
            Rocky: {
                category: 'Solid', folder: 'Rocky', prefix: 'Rocky',
                resources: { Iron: [15, 30], Silicon: [10, 20] }, harvests: 2, tint: [0.9, 0.8, 0.7]
            },
            Cratered: {
                category: 'Solid', folder: 'Cratered', prefix: 'Cratered',
                resources: { Iron: [20, 35], Titanium: [10, 20] }, harvests: 2, tint: [0.8, 0.8, 0.8]
            },
            Barren: {
                category: 'Solid', folder: 'Barren', prefix: 'Barren',
                resources: { Silicon: [15, 25], Copper: [10, 20] }, harvests: 1, tint: [0.9, 0.85, 0.8]
            },
            Lunar: {
                category: 'Solid', folder: 'Lunar', prefix: 'Lunar',
                resources: { Titanium: [15, 30], Iron: [10, 20] }, harvests: 1, tint: [0.85, 0.85, 0.9]
            },
            // Ice planets - yield water and gases
            Frozen: {
                category: 'Solid', folder: 'Frozen', prefix: 'Frozen',
                resources: { Water: [25, 45], Nitrogen: [15, 25] }, harvests: 2, tint: [0.8, 0.9, 1.0]
            },
            Icy: {
                category: 'Solid', folder: 'Icy', prefix: 'Icy',
                resources: { Water: [30, 50], Oxygen: [10, 20] }, harvests: 2, tint: [0.85, 0.95, 1.0]
            },
            Glacial: {
                category: 'Solid', folder: 'Glacial', prefix: 'Glacial',
                resources: { Water: [35, 55], Nitrogen: [15, 30] }, harvests: 3, tint: [0.75, 0.9, 1.0]
            },
            // Volcanic - yield rare metals
            Magma: {
                category: 'Solid', folder: 'Magma', prefix: 'Magma',
                resources: { Iron: [25, 45], Sulfur: [20, 35], Gold: [5, 15] }, harvests: 2, tint: [1.0, 0.7, 0.5]
            },
            // Life planets - yield organics
            Lush: {
                category: 'Solid', folder: 'Lush', prefix: 'Lush',
                resources: { Carbon: [20, 40], Oxygen: [25, 45], Water: [15, 25] }, harvests: 3, tint: [0.8, 1.0, 0.8]
            },
            Tropical: {
                category: 'Solid', folder: 'Tropical', prefix: 'Tropical',
                resources: { Carbon: [25, 45], Oxygen: [20, 35], Water: [20, 35] }, harvests: 3, tint: [0.85, 1.0, 0.85]
            },
            Ocean: {
                category: 'Solid', folder: 'Ocean', prefix: 'Ocean',
                resources: { Water: [50, 80], Oxygen: [15, 30] }, harvests: 4, tint: [0.7, 0.85, 1.0]
            },
            // Arid planets
            Arid: {
                category: 'Solid', folder: 'Arid', prefix: 'Arid',
                resources: { Silicon: [20, 35], Copper: [15, 25] }, harvests: 1, tint: [1.0, 0.9, 0.7]
            },
            Dry: {
                category: 'Solid', folder: 'Dry', prefix: 'Dry',
                resources: { Silicon: [15, 30], Iron: [10, 20] }, harvests: 1, tint: [0.95, 0.85, 0.7]
            }
        };

        // Game Settings
        const settings = {
            xSensitivity: 1.5,
            ySensitivity: 1.2,
            maxHeight: 0.5,
            shipSpeed: 1.0,
            fireRate: 1.0,
            scrollSpeed: 1.0,
            playerShip: 'Bob',
            playerColor: 'Blue',
            enemyShip: 'Spitfire',
            enemyColor: 'Red'
        };

        // Loaded model templates
        const modelTemplates = {};
        const previewScenes = [];

        // Sun types
        const SUN_TYPES = {
            YellowSun: { folder: 'Yellow Sun', prefix: 'Sun_Yellow', tint: [1.0, 1.0, 0.8] },
            RedSun: { folder: 'Red Sun', prefix: 'Sun_Red', tint: [1.0, 0.7, 0.6] },
            BlueSun: { folder: 'Blue Sun', prefix: 'Sun_Blue', tint: [0.7, 0.8, 1.0] }
        };

        // Game State
        let gameState = {
            score: 0,
            health: 100,
            wave: 1,
            isPlaying: false,
            isPaused: false,
            enemies: [],
            playerBullets: [],
            enemyBullets: [],
            loot: [],
            planets: [],
            suns: [],
            solarSystems: [],
            stars: [],
            lastFireTime: 0,
            waveTimer: 0,
            enemiesInWave: 0,
            enemiesSpawned: 0,
            nextSolarSystemY: 0,
            harvestingPlanet: null,
            harvestProgress: 0,
            resources: {},
            baseShields: 100,
            escapedEnemies: 0,
            pendingNotifications: {},
            // Zone/background tracking
            currentZone: 0,
            distanceTraveled: 0,
            transitionPhase: 0, // 0=none, 1=fading to starfield, 2=fading to next zone
            backgroundTransition: 0,
            // Starbase and weapons
            starbase: null,
            isDocked: false,
            wavesUntilStarbase: 1,
            credits: 0,
            ownedWeapons: ['basic'],
            equippedWeapon: 'basic',
            beamActive: false,
            beamMesh: null,
            // River navigation - level system
            level: 1,
            levelWave: 0,           // Current wave within level (0 = not started)
            levelConfig: null,      // Config for current level
            stationsVisited: 0,     // How many stations visited this level
            warpGates: [],          // Active warp gates
            gateChoices: null,      // The two gate options
            showingGates: false     // Whether gates are currently displayed
        };

        // Space zones - different areas with unique backgrounds (Starfield is transition zone)
        const SPACE_ZONES = [
            { name: 'Blue Nebula', folder: 'Blue Nebula', prefix: 'Blue_Nebula', variants: 8 },
            { name: 'Purple Nebula', folder: 'Purple Nebula', prefix: 'Purple_Nebula', variants: 8 },
            { name: 'Green Nebula', folder: 'Green Nebula', prefix: 'Green_Nebula', variants: 8 }
        ];

        // Starfield is used as neutral transition between zones
        const STARFIELD_ZONE = { name: 'Starfield', folder: 'Starfields', prefix: 'Starfield', variants: 8 };

        const ZONE_DISTANCE = 500; // Distance units per zone before transitioning

        // Weapon definitions
        const WEAPONS = {
            basic: {
                name: 'Pulse Cannon',
                desc: 'Standard single-shot weapon',
                cost: 0,
                fireRate: 300,
                damage: 1
            },
            trishot: {
                name: 'Tri-Shot',
                desc: 'Fires 3 bullets in a spread',
                cost: 500,
                fireRate: 400,
                damage: 1
            },
            rapid: {
                name: 'Rapid Fire',
                desc: 'Very fast firing rate',
                cost: 750,
                fireRate: 100,
                damage: 1
            },
            beam: {
                name: 'Beam Laser',
                desc: 'Hits all enemies in a line, fires slowly',
                cost: 1000,
                fireRate: 1500,
                damage: 2
            }
        };

        // Station types for level signatures
        const STATION_TYPES = ['Trade', 'Armory', 'Repair', 'Fuel'];

        // Generate a random level configuration
        function generateLevelConfig(levelNum) {
            // Difficulty scales with level
            const baseDifficulty = Math.min(levelNum, 10);

            // Random number of waves (2-6, scaling with level)
            const minWaves = Math.min(2 + Math.floor(levelNum / 3), 4);
            const maxWaves = Math.min(3 + Math.floor(levelNum / 2), 7);
            const waveCount = minWaves + Math.floor(Math.random() * (maxWaves - minWaves + 1));

            // Enemy strength: Low, Medium, High, Extreme
            const strengthRoll = Math.random() + (levelNum * 0.05);
            let threatLevel, threatClass;
            if (strengthRoll < 0.3) {
                threatLevel = 'Low';
                threatClass = 'safe';
            } else if (strengthRoll < 0.6) {
                threatLevel = 'Medium';
                threatClass = 'medium';
            } else if (strengthRoll < 0.85) {
                threatLevel = 'High';
                threatClass = 'danger';
            } else {
                threatLevel = 'Extreme';
                threatClass = 'danger';
            }

            // Enemy multiplier based on threat
            const enemyMultiplier = { 'Low': 0.7, 'Medium': 1.0, 'High': 1.3, 'Extreme': 1.6 }[threatLevel];

            // Stations (0-2, random types)
            const stationCount = Math.floor(Math.random() * 3);
            const stations = [];
            for (let i = 0; i < stationCount; i++) {
                stations.push(STATION_TYPES[Math.floor(Math.random() * STATION_TYPES.length)]);
            }

            // Format stations for display
            let stationDisplay = 'None';
            if (stations.length > 0) {
                const stationCounts = {};
                stations.forEach(s => stationCounts[s] = (stationCounts[s] || 0) + 1);
                stationDisplay = Object.entries(stationCounts)
                    .map(([type, count]) => count > 1 ? `${count} ${type}` : type)
                    .join(', ');
            }

            // Calculate which waves should have stations after them
            // Distribute stations evenly through the level
            const stationWaves = [];
            if (stations.length > 0) {
                const interval = Math.floor(waveCount / (stations.length + 1));
                for (let i = 0; i < stations.length; i++) {
                    stationWaves.push(interval * (i + 1));
                }
            }

            return {
                waveCount,
                threatLevel,
                threatClass,
                enemyMultiplier,
                stations,
                stationWaves,  // Which wave numbers trigger station spawns
                stationDisplay,
                levelNum
            };
        }

        // Background meshes for crossfade (A=current, B=transition target, C=next zone)
        let backgroundMeshA = null;
        let backgroundMeshB = null;
        let backgroundMaterialA = null;
        let backgroundMaterialB = null;

        // Initialize resources
        function initResources() {
            gameState.resources = {};
            Object.keys(RESOURCES).forEach(r => gameState.resources[r] = 0);
        }

        // Main game canvas and engine
        const canvas = document.getElementById('renderCanvas');

        // Enable high DPI rendering for crisp visuals on retina displays
        const devicePixelRatio = window.devicePixelRatio || 1;
        const engine = new BABYLON.Engine(canvas, true, {
            preserveDrawingBuffer: true,
            stencil: true,
            antialias: true,
            premultipliedAlpha: false // Fix alpha blending artifacts on mobile
        });

        // Set hardware scaling to match device pixel ratio for crisp rendering
        engine.setHardwareScalingLevel(1 / devicePixelRatio);

        // Game dimensions
        let gameWidth, gameHeight, orthoHeight = 10, orthoWidth;

        function updateGameDimensions() {
            gameWidth = engine.getRenderWidth();
            gameHeight = engine.getRenderHeight();
            const aspect = gameWidth / gameHeight;
            orthoWidth = orthoHeight * aspect;
        }

        // Create preview cards for each ship
        async function createModelPreviews() {
            const modelGrid = document.getElementById('modelGrid');
            const loadingText = document.getElementById('loadingText');

            let loadedCount = 0;
            const totalModels = shipNames.length;

            for (const shipName of shipNames) {
                const card = document.createElement('div');
                card.className = 'model-card';

                const previewCanvas = document.createElement('canvas');
                previewCanvas.id = `preview-${shipName}`;
                card.appendChild(previewCanvas);

                const nameLabel = document.createElement('div');
                nameLabel.className = 'model-name';
                nameLabel.textContent = shipName;
                card.appendChild(nameLabel);

                modelGrid.appendChild(card);

                const previewEngine = new BABYLON.Engine(previewCanvas, true, {
                    preserveDrawingBuffer: true,
                    antialias: true
                });
                previewEngine.setHardwareScalingLevel(1 / devicePixelRatio);
                const previewScene = new BABYLON.Scene(previewEngine);
                previewScene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.15, 1);

                const camera = new BABYLON.ArcRotateCamera('camera', 0, Math.PI / 3, 5, BABYLON.Vector3.Zero(), previewScene);

                const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), previewScene);
                light.intensity = 1.0;
                const light2 = new BABYLON.DirectionalLight('light2', new BABYLON.Vector3(1, -1, 1), previewScene);
                light2.intensity = 0.5;

                try {
                    const basePath = `assets/Ultimate Spaceships/${shipName}/`;
                    const result = await BABYLON.SceneLoader.ImportMeshAsync('', basePath + 'glTF/', `${shipName}.gltf`, previewScene);

                    const rootMesh = result.meshes[0];

                    const texturePath = `${basePath}Textures/${shipName}_Blue.png`;
                    const texture = new BABYLON.Texture(texturePath, previewScene, false, true, BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
                    texture.anisotropicFilteringLevel = 16;

                    result.meshes.forEach(mesh => {
                        if (mesh.material) mesh.material.dispose();
                        const mat = new BABYLON.StandardMaterial(`${shipName}Mat`, previewScene);
                        mat.diffuseTexture = texture;
                        mat.emissiveTexture = texture;
                        mat.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                        mat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                        mesh.material = mat;
                    });

                    const boundingInfo = rootMesh.getHierarchyBoundingVectors(true);
                    const size = boundingInfo.max.subtract(boundingInfo.min);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 2 / maxDim;
                    rootMesh.scaling = new BABYLON.Vector3(scale, scale, scale);

                    const center = boundingInfo.min.add(boundingInfo.max).scale(0.5 * scale);
                    rootMesh.position = center.negate();

                    previewScene.shipMesh = rootMesh;

                    modelTemplates[shipName] = { path: basePath, scale: scale };

                } catch (e) {
                    console.error(`Failed to load ${shipName}:`, e);
                    const placeholder = BABYLON.MeshBuilder.CreateBox('placeholder', {size: 1}, previewScene);
                    const mat = new BABYLON.StandardMaterial('placeholderMat', previewScene);
                    mat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                    placeholder.material = mat;
                    previewScene.shipMesh = placeholder;
                }

                previewEngine.runRenderLoop(() => {
                    if (previewScene.shipMesh) previewScene.shipMesh.rotation.y += 0.02;
                    previewScene.render();
                });

                previewScenes.push({ engine: previewEngine, scene: previewScene });

                loadedCount++;
                loadingText.textContent = `Loading models... ${loadedCount}/${totalModels}`;
            }

            loadingText.style.display = 'none';
            document.getElementById('startBtn').style.display = 'block';
        }

        // Main game scene
        let scene, playerShip, playerShipMesh;
        let materials = {};

        function createMainScene() {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.02, 0.02, 0.08, 1);

            const camera = new BABYLON.FreeCamera('camera', new BABYLON.Vector3(0, 0, -10), scene);
            camera.setTarget(new BABYLON.Vector3(0, 0, 0));
            camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;

            function updateCamera() {
                updateGameDimensions();
                const aspect = gameWidth / gameHeight;
                camera.orthoTop = orthoHeight;
                camera.orthoBottom = -orthoHeight;
                camera.orthoLeft = -orthoHeight * aspect;
                camera.orthoRight = orthoHeight * aspect;
            }
            updateCamera();
            window.addEventListener('resize', updateCamera);

            const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, -1), scene);
            light.intensity = 1.0;
            const light2 = new BABYLON.DirectionalLight('light2', new BABYLON.Vector3(0, 0, -1), scene);
            light2.intensity = 0.8;

            // GlowLayer for suns, bullets, and explosions - whitelisted meshes
            sunGlowLayer = new BABYLON.GlowLayer('sunGlow', scene, {
                mainTextureFixedSize: 512,
                blurKernelSize: 24 // Tighter glow
            });
            sunGlowLayer.intensity = 0.7; // Reduced intensity

            // DefaultRenderingPipeline for global bloom
            renderPipeline = new BABYLON.DefaultRenderingPipeline(
                'defaultPipeline',
                true,
                scene,
                [camera]
            );
            renderPipeline.bloomEnabled = true;
            renderPipeline.bloomKernel = 24; // Tighter bloom
            renderPipeline.bloomWeight = 0.25; // Subtle bloom
            renderPipeline.bloomThreshold = 0.7; // Higher threshold
            renderPipeline.bloomScale = 0.5;
            renderPipeline.imageProcessingEnabled = true;
            renderPipeline.imageProcessing.contrast = 1.1;
            renderPipeline.imageProcessing.exposure = 1.0;

            // Dynamic sun light - will be updated based on nearest sun
            const sunLight = new BABYLON.DirectionalLight('sunLight', new BABYLON.Vector3(0, -1, 0.5), scene);
            sunLight.intensity = 0;
            sunLight.diffuse = new BABYLON.Color3(1, 1, 1);
            sunLight.specular = new BABYLON.Color3(0.5, 0.5, 0.5);
            gameState.sunLight = sunLight;

            materials.playerBullet = new BABYLON.StandardMaterial('playerBulletMat', scene);
            materials.playerBullet.emissiveColor = new BABYLON.Color3(0, 1, 0.5);

            materials.enemyBullet = new BABYLON.StandardMaterial('enemyBulletMat', scene);
            materials.enemyBullet.emissiveColor = new BABYLON.Color3(1, 0.5, 0);

            // Create scrolling backgrounds for zone transitions
            createBackgrounds();

            return scene;
        }

        // Get background texture path for a zone
        function getBackgroundPath(zoneIndex) {
            const zone = SPACE_ZONES[zoneIndex % SPACE_ZONES.length];
            const variant = Math.floor(Math.random() * zone.variants) + 1;
            const variantStr = variant.toString().padStart(2, '0');
            return `assets/SBS - Seamless Space Backgrounds - Small 512x512/Small 512x512/${zone.folder}/${zone.prefix}_${variantStr}-512x512.png`;
        }

        // Create background meshes
        function createBackgrounds() {
            const bgSize = Math.max(orthoWidth, orthoHeight) * 3;

            // Background A (current)
            backgroundMeshA = BABYLON.MeshBuilder.CreatePlane('backgroundA', { width: bgSize, height: bgSize * 2 }, scene);
            backgroundMeshA.position.z = 5; // Far behind everything
            backgroundMeshA.position.y = 0;

            backgroundMaterialA = new BABYLON.StandardMaterial('bgMatA', scene);
            const textureA = new BABYLON.Texture(getBackgroundPath(0), scene);
            textureA.uScale = bgSize / 20;
            textureA.vScale = bgSize * 2 / 20;
            textureA.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;
            textureA.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;
            backgroundMaterialA.diffuseTexture = textureA;
            backgroundMaterialA.emissiveTexture = textureA;
            backgroundMaterialA.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            backgroundMaterialA.disableLighting = true;
            backgroundMaterialA.backFaceCulling = false;
            backgroundMeshA.material = backgroundMaterialA;

            // Background B (for transitions)
            backgroundMeshB = BABYLON.MeshBuilder.CreatePlane('backgroundB', { width: bgSize, height: bgSize * 2 }, scene);
            backgroundMeshB.position.z = 4.9; // Slightly in front of A
            backgroundMeshB.position.y = 0;

            backgroundMaterialB = new BABYLON.StandardMaterial('bgMatB', scene);
            backgroundMaterialB.diffuseColor = new BABYLON.Color3(0, 0, 0);
            backgroundMaterialB.emissiveColor = new BABYLON.Color3(0, 0, 0);
            backgroundMaterialB.disableLighting = true;
            backgroundMaterialB.backFaceCulling = false;
            backgroundMaterialB.alpha = 0;
            backgroundMeshB.material = backgroundMaterialB;
        }

        // Get starfield texture path
        function getStarfieldPath() {
            const variant = Math.floor(Math.random() * STARFIELD_ZONE.variants) + 1;
            const variantStr = variant.toString().padStart(2, '0');
            return `assets/SBS - Seamless Space Backgrounds - Small 512x512/Small 512x512/${STARFIELD_ZONE.folder}/${STARFIELD_ZONE.prefix}_${variantStr}-512x512.png`;
        }

        // Load texture into background B for transition
        function loadTransitionTexture(path) {
            const bgSize = Math.max(orthoWidth, orthoHeight) * 3;
            const texture = new BABYLON.Texture(path, scene);
            texture.uScale = bgSize / 20;
            texture.vScale = bgSize * 2 / 20;
            texture.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;
            texture.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;
            // Match current scroll offset
            if (backgroundMaterialA.diffuseTexture) {
                texture.vOffset = backgroundMaterialA.diffuseTexture.vOffset;
            }

            if (backgroundMaterialB.diffuseTexture) {
                backgroundMaterialB.diffuseTexture.dispose();
            }
            backgroundMaterialB.diffuseTexture = texture;
            backgroundMaterialB.emissiveTexture = texture;
            backgroundMaterialB.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
        }

        // Start transition to next zone (via starfield)
        function startZoneTransition() {
            if (gameState.transitionPhase !== 0) return;

            // Phase 1: Fade to starfield
            gameState.transitionPhase = 1;
            gameState.backgroundTransition = 0;
            loadTransitionTexture(getStarfieldPath());
        }

        // Update backgrounds (scrolling and transitions)
        function updateBackgrounds(scrollMultiplier, deltaTime) {
            if (!backgroundMeshA || !backgroundMeshB) return;

            // Track distance traveled based on scroll
            const scrollAmount = 0.015 * settings.scrollSpeed * (0.5 + scrollMultiplier);
            gameState.distanceTraveled += scrollAmount * deltaTime * 0.1;

            // Scroll both backgrounds
            // Very slow background scroll for ambient effect
            const scrollSpeed = 0.00005 * settings.scrollSpeed;
            if (backgroundMaterialA.diffuseTexture) {
                backgroundMaterialA.diffuseTexture.vOffset += scrollSpeed * deltaTime;
            }
            if (backgroundMaterialB.diffuseTexture && backgroundMaterialB.alpha > 0) {
                backgroundMaterialB.diffuseTexture.vOffset += scrollSpeed * deltaTime;
            }

            // Start transition when zone distance is reached
            if (gameState.distanceTraveled >= ZONE_DISTANCE && gameState.transitionPhase === 0) {
                startZoneTransition();
            }

            // Handle transition animation
            if (gameState.transitionPhase > 0) {
                gameState.backgroundTransition += deltaTime / 2000; // 2 second per phase

                backgroundMaterialB.alpha = Math.min(1, gameState.backgroundTransition);

                if (gameState.backgroundTransition >= 1) {
                    // Phase complete - swap backgrounds
                    const tempTexture = backgroundMaterialA.diffuseTexture;
                    backgroundMaterialA.diffuseTexture = backgroundMaterialB.diffuseTexture;
                    backgroundMaterialA.emissiveTexture = backgroundMaterialB.diffuseTexture;
                    backgroundMaterialB.diffuseTexture = null;
                    backgroundMaterialB.emissiveTexture = null;
                    backgroundMaterialB.alpha = 0;
                    if (tempTexture) tempTexture.dispose();

                    gameState.backgroundTransition = 0;

                    if (gameState.transitionPhase === 1) {
                        // Phase 1 complete (now showing starfield), start phase 2
                        gameState.transitionPhase = 2;
                        const nextZone = (gameState.currentZone + 1) % SPACE_ZONES.length;
                        loadTransitionTexture(getBackgroundPath(nextZone));
                    } else {
                        // Phase 2 complete (now showing next zone)
                        gameState.currentZone = (gameState.currentZone + 1) % SPACE_ZONES.length;
                        gameState.distanceTraveled = 0;
                        gameState.transitionPhase = 0;
                    }
                }
            }
        }

        // Show collection notification as icon at top
        function showResourceCollection(resourceType, amount) {
            // Batch notifications for the same resource
            if (!gameState.pendingNotifications[resourceType]) {
                gameState.pendingNotifications[resourceType] = {
                    amount: 0,
                    timeout: null
                };
            }

            gameState.pendingNotifications[resourceType].amount += amount;

            // Clear existing timeout and set a new one
            if (gameState.pendingNotifications[resourceType].timeout) {
                clearTimeout(gameState.pendingNotifications[resourceType].timeout);
            }

            // Show notification after small delay to batch rapid collections
            gameState.pendingNotifications[resourceType].timeout = setTimeout(() => {
                const totalAmount = gameState.pendingNotifications[resourceType].amount;
                delete gameState.pendingNotifications[resourceType];

                const container = document.getElementById('collectNotifications');
                const resourceInfo = RESOURCES[resourceType];

                const notif = document.createElement('div');
                notif.className = 'collect-notif';
                notif.innerHTML = `
                    <div class="symbol" style="background: ${resourceInfo.color}">${resourceInfo.symbol}</div>
                    <span class="amount">x${totalAmount}</span>
                `;
                container.appendChild(notif);

                setTimeout(() => notif.remove(), 2000);
            }, 100);
        }

        // Create explosion effect
        function createExplosion(x, y, size = 'small', color = 'orange') {
            if (!scene) return;

            const isLarge = size === 'large';
            const particleCount = isLarge ? 30 : 12;
            const explosionSize = isLarge ? 0.8 : 0.3;
            const duration = isLarge ? 600 : 300;

            const particles = [];
            const colors = {
                orange: { r: 1, g: 0.5, b: 0 },
                red: { r: 1, g: 0.2, b: 0.1 },
                blue: { r: 0.3, g: 0.5, b: 1 },
                yellow: { r: 1, g: 0.8, b: 0.2 },
                green: { r: 0.3, g: 1, b: 0.5 }
            };
            const baseColor = colors[color] || colors.orange;

            for (let i = 0; i < particleCount; i++) {
                const particle = BABYLON.MeshBuilder.CreateSphere('explosionParticle', {
                    diameter: explosionSize * (0.3 + Math.random() * 0.7)
                }, scene);

                particle.position.x = x;
                particle.position.y = y;
                particle.position.z = -0.1;

                const angle = Math.random() * Math.PI * 2;
                const speed = (isLarge ? 0.15 : 0.08) * (0.5 + Math.random());
                particle.velocityX = Math.cos(angle) * speed;
                particle.velocityY = Math.sin(angle) * speed;

                const mat = new BABYLON.StandardMaterial('explosionMat' + i, scene);
                const colorVariation = 0.8 + Math.random() * 0.4;
                mat.emissiveColor = new BABYLON.Color3(
                    baseColor.r * colorVariation,
                    baseColor.g * colorVariation,
                    baseColor.b * colorVariation
                );
                mat.disableLighting = true;
                particle.material = mat;

                // Add explosion particles to GlowLayer for dramatic glow effect
                if (sunGlowLayer) {
                    sunGlowLayer.addIncludedOnlyMesh(particle);
                }

                particle.startTime = performance.now();
                particle.duration = duration * (0.7 + Math.random() * 0.6);
                particles.push(particle);
            }

            const animateExplosion = () => {
                const now = performance.now();
                let allDone = true;

                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    const elapsed = now - p.startTime;
                    const progress = elapsed / p.duration;

                    if (progress >= 1) {
                        p.dispose();
                        particles.splice(i, 1);
                    } else {
                        allDone = false;
                        p.position.x += p.velocityX;
                        p.position.y += p.velocityY;
                        p.velocityX *= 0.95;
                        p.velocityY *= 0.95;
                        const scale = 1 - progress * 0.5;
                        p.scaling.setAll(scale);
                        if (p.material) p.material.alpha = 1 - progress;
                    }
                }

                if (!allDone) requestAnimationFrame(animateExplosion);
            };

            requestAnimationFrame(animateExplosion);
        }

        // Flash effect for ships when hit
        function flashShip(meshOrNode, duration = 150) {
            if (!meshOrNode) return;

            const meshes = meshOrNode.getChildMeshes ? meshOrNode.getChildMeshes() : [meshOrNode];
            const originalColors = [];

            meshes.forEach((mesh, i) => {
                if (mesh.material) {
                    originalColors[i] = mesh.material.emissiveColor.clone();
                    mesh.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
                }
            });

            setTimeout(() => {
                meshes.forEach((mesh, i) => {
                    if (mesh.material && originalColors[i]) {
                        mesh.material.emissiveColor = originalColors[i];
                    }
                });
            }, duration);
        }

        // Create loot drop when enemy dies (now gives resources)
        function createLoot(x, y, enemyType) {
            if (!scene) return;

            // Enemies drop ship materials
            const enemyResources = ['Iron', 'Copper', 'Titanium', 'Silicon'];
            const pieceCount = enemyType === 'shooter' ? 3 : enemyType === 'fast' ? 1 : 2;

            for (let i = 0; i < pieceCount; i++) {
                const shapes = ['box', 'octahedron', 'icosphere'];
                const shapeType = shapes[Math.floor(Math.random() * shapes.length)];

                let lootMesh;
                // BIGGER LOOT SIZE
                const size = 0.35 + Math.random() * 0.15;

                if (shapeType === 'box') {
                    lootMesh = BABYLON.MeshBuilder.CreateBox('loot', { size: size }, scene);
                } else if (shapeType === 'octahedron') {
                    lootMesh = BABYLON.MeshBuilder.CreatePolyhedron('loot', { type: 1, size: size * 0.5 }, scene);
                } else {
                    lootMesh = BABYLON.MeshBuilder.CreateIcoSphere('loot', { radius: size * 0.5, subdivisions: 1 }, scene);
                }

                const offsetX = (Math.random() - 0.5) * 1.5;
                const offsetY = (Math.random() - 0.5) * 1.5;
                lootMesh.position.x = x + offsetX;
                lootMesh.position.y = y + offsetY;
                lootMesh.position.z = -0.2;

                lootMesh.rotation.x = Math.random() * Math.PI * 2;
                lootMesh.rotation.y = Math.random() * Math.PI * 2;
                lootMesh.rotation.z = Math.random() * Math.PI * 2;

                // Assign a resource type
                const resourceType = enemyResources[Math.floor(Math.random() * enemyResources.length)];
                const resourceInfo = RESOURCES[resourceType];

                const lootMat = new BABYLON.StandardMaterial('lootMat', scene);
                // Parse hex color
                const hex = resourceInfo.color;
                const r = parseInt(hex.slice(1,3), 16) / 255;
                const g = parseInt(hex.slice(3,5), 16) / 255;
                const b = parseInt(hex.slice(5,7), 16) / 255;

                lootMat.emissiveColor = new BABYLON.Color3(r, g, b);
                lootMat.diffuseColor = new BABYLON.Color3(r * 0.5, g * 0.5, b * 0.5);
                lootMat.specularColor = new BABYLON.Color3(1, 1, 1);
                lootMesh.material = lootMat;

                // Bigger glow core
                const core = BABYLON.MeshBuilder.CreateSphere('lootCore', { diameter: size * 0.7 }, scene);
                core.parent = lootMesh;
                const coreMat = new BABYLON.StandardMaterial('lootCoreMat', scene);
                coreMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
                coreMat.disableLighting = true;
                coreMat.alpha = 0.7;
                core.material = coreMat;

                lootMesh.velocityX = offsetX * 0.02;
                lootMesh.velocityY = offsetY * 0.02;
                lootMesh.rotSpeed = (Math.random() - 0.5) * 0.1;
                lootMesh.pulsePhase = Math.random() * Math.PI * 2;
                lootMesh.baseColor = { r, g, b };
                lootMesh.resourceType = resourceType;
                lootMesh.resourceAmount = Math.floor(Math.random() * 3) + 1; // 1-3 per piece
                lootMesh.spawnTime = performance.now();

                gameState.loot.push(lootMesh);
            }
        }

        // Update loot
        function updateLoot(scrollMultiplier) {
            if (!playerShip) return;

            const now = performance.now();

            for (let i = gameState.loot.length - 1; i >= 0; i--) {
                const loot = gameState.loot[i];

                loot.velocityX *= 0.98;
                loot.velocityY *= 0.98;

                loot.position.x += loot.velocityX;
                loot.position.y += loot.velocityY - 0.02 * settings.scrollSpeed * (0.5 + scrollMultiplier);

                loot.rotation.x += loot.rotSpeed;
                loot.rotation.y += loot.rotSpeed * 1.3;
                loot.rotation.z += loot.rotSpeed * 0.7;

                const age = (now - loot.spawnTime) / 1000;
                const pulse = 0.7 + 0.3 * Math.sin(age * 5 + loot.pulsePhase);
                if (loot.material) {
                    loot.material.emissiveColor = new BABYLON.Color3(
                        loot.baseColor.r * pulse,
                        loot.baseColor.g * pulse,
                        loot.baseColor.b * pulse
                    );
                }

                const dx = loot.position.x - playerShip.position.x;
                const dy = loot.position.y - playerShip.position.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 1.2) {
                    // Collect resource (no notification for enemy loot, only planets)
                    gameState.resources[loot.resourceType] += loot.resourceAmount;
                    gameState.score += loot.resourceAmount * 5;
                    updateHUD();

                    createExplosion(loot.position.x, loot.position.y, 'small', 'blue');

                    loot.getChildMeshes().forEach(m => m.dispose());
                    loot.dispose();
                    gameState.loot.splice(i, 1);
                    continue;
                }

                if (loot.position.y < -orthoHeight - 2) {
                    loot.getChildMeshes().forEach(m => m.dispose());
                    loot.dispose();
                    gameState.loot.splice(i, 1);
                }
            }
        }

        // Global glow layer for suns (initialized in setupScene)
        let sunGlowLayer = null;
        let renderPipeline = null;

        // Create a sun
        function createSun(x, y) {
            if (!scene) return null;

            const sunTypeKeys = Object.keys(SUN_TYPES);
            const sunTypeKey = sunTypeKeys[Math.floor(Math.random() * sunTypeKeys.length)];
            const sunType = SUN_TYPES[sunTypeKey];

            const variant = Math.floor(Math.random() * 5) + 1;
            const variantStr = variant.toString().padStart(2, '0');
            const imagePath = `assets/Medium Planets 256x256/Suns/${sunType.folder}/${sunType.prefix}_${variantStr}-256x256.png`;

            const sunSize = 4 + Math.random() * 2; // 4-6 units

            // Create the sun mesh
            const sun = BABYLON.MeshBuilder.CreatePlane('sun', { size: sunSize }, scene);
            sun.position.x = x;
            sun.position.y = y;
            sun.position.z = 3; // Far behind everything except background

            const texture = new BABYLON.Texture(imagePath, scene);
            texture.hasAlpha = true;

            const mat = new BABYLON.StandardMaterial('sunMat', scene);
            mat.diffuseTexture = texture;
            mat.emissiveTexture = texture;
            // Strong emissive for GlowLayer to pick up
            mat.emissiveColor = new BABYLON.Color3(
                sunType.tint[0],
                sunType.tint[1],
                sunType.tint[2]
            );
            mat.useAlphaFromDiffuseTexture = true;
            mat.backFaceCulling = false;
            mat.disableLighting = true;
            sun.material = mat;

            // Add sun to GlowLayer for bloom effect
            if (sunGlowLayer) {
                sunGlowLayer.addIncludedOnlyMesh(sun);
            }

            // No PointLight - sun lighting is handled via material changes in applySunLighting()
            // This prevents washout of ships and starbases

            sun.size = sunSize;
            sun.glowSize = sunSize * 4; // Used for cleanup distance check
            sun.isSun = true;
            sun.tint = sunType.tint;

            return sun;
        }

        // Create a planet at specific position
        function createPlanetAt(x, y) {
            if (!scene) return null;

            const typeKeys = Object.keys(PLANET_TYPES);
            const typeKey = typeKeys[Math.floor(Math.random() * typeKeys.length)];
            const planetType = PLANET_TYPES[typeKey];

            const variant = Math.floor(Math.random() * 5) + 1;
            const variantStr = variant.toString().padStart(2, '0');
            const imagePath = `assets/Medium Planets 256x256/${planetType.category}/${planetType.folder}/${planetType.prefix}_${variantStr}-256x256.png`;

            const planetSize = 2 + Math.random() * 1.5; // 2-3.5 units

            const planet = BABYLON.MeshBuilder.CreatePlane('planet', { size: planetSize }, scene);
            planet.position.x = x;
            planet.position.y = y;
            planet.position.z = 0.5;

            const texture = new BABYLON.Texture(imagePath, scene);
            texture.hasAlpha = true;

            const mat = new BABYLON.StandardMaterial('planetMat', scene);
            mat.diffuseTexture = texture;
            mat.emissiveTexture = texture;
            mat.emissiveColor = new BABYLON.Color3(
                planetType.tint[0] * 0.3,
                planetType.tint[1] * 0.3,
                planetType.tint[2] * 0.3
            );
            mat.useAlphaFromDiffuseTexture = true;
            mat.backFaceCulling = false;
            planet.material = mat;

            planet.planetType = typeKey;
            planet.planetData = planetType;
            planet.harvestsRemaining = planetType.harvests;
            planet.size = planetSize;
            planet.harvestRadius = planetSize * 0.8;

            // Richness affects loot multiplier (1-5 scale)
            planet.richness = Math.floor(Math.random() * 5) + 1;
            // Hazardousness affects harvest time (1-5 scale, higher = longer)
            planet.hazard = Math.floor(Math.random() * 5) + 1;
            // Base harvest time is 2 seconds, hazard adds 0.5s per level
            planet.harvestTime = 1500 + planet.hazard * 500; // 2s to 4s

            return planet;
        }

        // Create a solar system (sun with orbiting planets)
        function createSolarSystem() {
            if (!scene) return;

            // Center of solar system
            const centerX = (Math.random() - 0.5) * (orthoWidth * 1.2);
            const centerY = orthoHeight + 8; // Start above screen

            // Create sun at center
            const sun = createSun(centerX, centerY);
            if (sun) {
                gameState.suns.push(sun);
            }

            // Create 2-5 planets orbiting the sun
            const planetCount = 2 + Math.floor(Math.random() * 4);
            const minOrbitRadius = sun ? sun.size * 0.8 : 3;

            for (let i = 0; i < planetCount; i++) {
                const orbitRadius = minOrbitRadius + 2 + i * 2 + Math.random() * 1.5;
                const angle = Math.random() * Math.PI * 2;

                const px = centerX + Math.cos(angle) * orbitRadius;
                const py = centerY + Math.sin(angle) * orbitRadius * 0.4; // Flatten orbits

                const planet = createPlanetAt(px, py);
                if (planet) {
                    planet.orbitCenterX = centerX;
                    planet.orbitRadius = orbitRadius;
                    planet.orbitAngle = angle;
                    planet.orbitSpeed = 0.0003 + Math.random() * 0.0002;
                    gameState.planets.push(planet);
                }
            }

            // Schedule next solar system with spacing (screen's worth on average)
            const spacing = orthoHeight * 2 * (0.7 + Math.random() * 0.6); // 0.7-1.3 screens
            gameState.nextSolarSystemY = centerY + spacing;
        }

        // Create starbase
        function createStarbase() {
            if (!scene || gameState.starbase) return;

            const starbaseSize = 2.5; // Smaller than planets
            const starbase = BABYLON.MeshBuilder.CreatePlane('starbase', { size: starbaseSize }, scene);

            starbase.position.x = (Math.random() - 0.5) * orthoWidth;
            starbase.position.y = orthoHeight + starbaseSize;
            starbase.position.z = 0.2; // In front of planets and suns

            const texture = new BABYLON.Texture('assets/stellar objects/starbase.png', scene);
            texture.hasAlpha = true;

            const mat = new BABYLON.StandardMaterial('starbaseMat', scene);
            mat.diffuseTexture = texture;
            mat.emissiveTexture = texture;
            mat.emissiveColor = new BABYLON.Color3(0.4, 0.4, 0.5);
            mat.useAlphaFromDiffuseTexture = true;
            mat.backFaceCulling = false;
            starbase.material = mat;

            // Exclude starbase from GlowLayer to prevent bloom washout
            if (sunGlowLayer) {
                sunGlowLayer.addExcludedMesh(starbase);
            }

            starbase.size = starbaseSize;
            starbase.dockRadius = starbaseSize * 0.8;

            gameState.starbase = starbase;
        }

        // Update starbase
        function updateStarbase(scrollMultiplier, deltaTime) {
            if (!gameState.starbase || !playerShip) return;

            const starbase = gameState.starbase;

            // Move starbase down
            starbase.position.y -= 0.015 * settings.scrollSpeed * (0.5 + scrollMultiplier);

            // Slow rotation
            starbase.rotation.z += 0.002;

            // Check distance to player for docking
            const dx = starbase.position.x - playerShip.position.x;
            const dy = starbase.position.y - playerShip.position.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Check if starbase is fully visible
            const fullyVisible = starbase.position.y < (orthoHeight - starbase.size / 2);

            if (fullyVisible && dist < starbase.dockRadius) {
                // Show docking progress using harvest bar
                if (!gameState.harvestingPlanet) {
                    gameState.harvestProgress += deltaTime / 1500; // 1.5 seconds to dock

                    const harvestBar = document.getElementById('harvestBar');
                    const harvestBarFill = document.getElementById('harvestBarFill');
                    harvestBar.style.display = 'block';
                    harvestBarFill.style.width = `${Math.min(100, gameState.harvestProgress * 100)}%`;

                    // Position bar at starbase
                    const screenPos = worldToScreen(starbase.position.x, starbase.position.y);
                    const screenSize = (starbase.size / (orthoHeight * 2)) * canvas.clientHeight;
                    const halfSize = screenSize / 2;
                    const barWidth = screenSize;
                    harvestBar.style.left = (screenPos.x - barWidth / 2) + 'px';
                    harvestBar.style.top = (screenPos.y + halfSize + 8) + 'px';
                    harvestBar.style.width = barWidth + 'px';
                    harvestBar.style.transform = 'none';

                    if (gameState.harvestProgress >= 1) {
                        // Docked!
                        openDockingScreen();
                    }
                }
            } else {
                if (!gameState.harvestingPlanet && gameState.harvestProgress > 0 && !gameState.isDocked) {
                    gameState.harvestProgress = 0;
                    document.getElementById('harvestBar').style.display = 'none';
                }
            }

            // Remove if off screen - spawn next wave
            if (starbase.position.y < -orthoHeight - starbase.size) {
                starbase.dispose();
                gameState.starbase = null;
                spawnWave(); // Spawn next wave
            }
        }

        // Open docking screen
        function openDockingScreen() {
            gameState.isDocked = true;
            gameState.isPaused = true;
            gameState.harvestProgress = 0;
            document.getElementById('harvestBar').style.display = 'none';

            updateDockingScreen();
            document.getElementById('dockingScreen').style.display = 'flex';
        }

        // Update docking screen with current state
        function updateDockingScreen() {
            document.getElementById('creditsDisplay').textContent = gameState.credits;

            const weaponsList = document.getElementById('weaponsList');
            weaponsList.innerHTML = '';

            Object.keys(WEAPONS).forEach(weaponId => {
                const weapon = WEAPONS[weaponId];
                const owned = gameState.ownedWeapons.includes(weaponId);
                const equipped = gameState.equippedWeapon === weaponId;
                const canAfford = gameState.credits >= weapon.cost;

                const item = document.createElement('div');
                item.className = 'upgrade-item' + (owned ? ' owned' : '') + (equipped ? ' equipped' : '');

                let btnHtml = '';
                if (equipped) {
                    btnHtml = '<button class="upgrade-btn equipped" disabled>Equipped</button>';
                } else if (owned) {
                    btnHtml = `<button class="upgrade-btn equip" onclick="equipWeapon('${weaponId}')">Equip</button>`;
                } else {
                    btnHtml = `<button class="upgrade-btn buy" ${canAfford ? '' : 'disabled'} onclick="buyWeapon('${weaponId}')">${weapon.cost} cr</button>`;
                }

                item.innerHTML = `
                    <div class="upgrade-info">
                        <div class="upgrade-name">${weapon.name}</div>
                        <div class="upgrade-desc">${weapon.desc}</div>
                    </div>
                    ${btnHtml}
                `;

                weaponsList.appendChild(item);
            });
        }

        // Buy weapon
        function buyWeapon(weaponId) {
            const weapon = WEAPONS[weaponId];
            if (gameState.credits >= weapon.cost && !gameState.ownedWeapons.includes(weaponId)) {
                gameState.credits -= weapon.cost;
                gameState.ownedWeapons.push(weaponId);
                gameState.equippedWeapon = weaponId;
                updateDockingScreen();
            }
        }

        // Equip weapon
        function equipWeapon(weaponId) {
            if (gameState.ownedWeapons.includes(weaponId)) {
                gameState.equippedWeapon = weaponId;
                updateDockingScreen();
            }
        }

        // Close docking screen and depart
        function departStarbase() {
            gameState.isDocked = false;
            gameState.isPaused = false;
            document.getElementById('dockingScreen').style.display = 'none';

            // Remove starbase
            if (gameState.starbase) {
                gameState.starbase.dispose();
                gameState.starbase = null;
            }
        }

        // Make functions available globally for onclick
        window.buyWeapon = buyWeapon;
        window.equipWeapon = equipWeapon;

        // ========== RIVER NAVIGATION - WARP GATES ==========

        // Create warp gates at end of level
        function createWarpGates() {
            if (!scene || gameState.showingGates) return;

            // Generate two different level options
            const nextLevel = gameState.level + 1;
            gameState.gateChoices = {
                left: generateLevelConfig(nextLevel),
                right: generateLevelConfig(nextLevel)
            };

            // Update UI with gate signatures
            updateGateUI();

            // Create the gate meshes
            const gateSize = 2.5;
            const gateY = orthoHeight + gateSize;
            const gateSpacing = 4;

            // Left gate (orange)
            const leftGate = createGateMesh('warpGateLeft', -gateSpacing / 2, gateY, gateSize, [1, 0.5, 0.2]);
            leftGate.gateId = 'left';
            gameState.warpGates.push(leftGate);

            // Right gate (green)
            const rightGate = createGateMesh('warpGateRight', gateSpacing / 2, gateY, gateSize, [0.2, 1, 0.5]);
            rightGate.gateId = 'right';
            gameState.warpGates.push(rightGate);

            gameState.showingGates = true;
            document.getElementById('warpGatePanel').style.display = 'flex';
        }

        // Create a single warp gate mesh using the warpgate.png texture
        function createGateMesh(name, x, y, size, color) {
            const gate = BABYLON.MeshBuilder.CreatePlane(name, { size: size }, scene);

            gate.position.x = x;
            gate.position.y = y;
            gate.position.z = 0.1;

            const texture = new BABYLON.Texture('assets/stellar objects/warpgate.png', scene);
            texture.hasAlpha = true;

            const mat = new BABYLON.StandardMaterial(name + 'Mat', scene);
            mat.diffuseTexture = texture;
            mat.emissiveTexture = texture;
            // Tint with the gate color
            mat.emissiveColor = new BABYLON.Color3(color[0] * 0.6, color[1] * 0.6, color[2] * 0.6);
            mat.useAlphaFromDiffuseTexture = true;
            mat.backFaceCulling = false;
            mat.disableLighting = true;
            gate.material = mat;

            // Add to glow layer for the glowing effect
            if (sunGlowLayer) {
                sunGlowLayer.addIncludedOnlyMesh(gate);
            }

            gate.size = size;
            gate.enterRadius = size * 0.4;

            return gate;
        }

        // Update the gate UI panels
        function updateGateUI() {
            if (!gameState.gateChoices) return;

            const left = gameState.gateChoices.left;
            const right = gameState.gateChoices.right;

            // Left gate
            document.getElementById('gateLeftThreat').textContent = left.threatLevel;
            document.getElementById('gateLeftThreat').className = 'gate-stat-value ' + left.threatClass;
            document.getElementById('gateLeftWaves').textContent = left.waveCount;
            document.getElementById('gateLeftStations').textContent = left.stationDisplay;

            // Right gate
            document.getElementById('gateRightThreat').textContent = right.threatLevel;
            document.getElementById('gateRightThreat').className = 'gate-stat-value ' + right.threatClass;
            document.getElementById('gateRightWaves').textContent = right.waveCount;
            document.getElementById('gateRightStations').textContent = right.stationDisplay;
        }

        // Update warp gates (movement and collision)
        function updateWarpGates(scrollMultiplier, deltaTime) {
            if (!gameState.showingGates || gameState.warpGates.length === 0) return;

            for (let i = gameState.warpGates.length - 1; i >= 0; i--) {
                const gate = gameState.warpGates[i];

                // Move gate down
                gate.position.y -= 0.01 * settings.scrollSpeed * (0.5 + scrollMultiplier);

                // Slow rotation
                gate.rotation.z += 0.005;

                // Check collision with player
                if (playerShip) {
                    const dx = gate.position.x - playerShip.position.x;
                    const dy = gate.position.y - playerShip.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < gate.enterRadius) {
                        // Player entered this gate!
                        enterWarpGate(gate.gateId);
                        return;
                    }
                }

                // Remove if off screen (player missed both gates - shouldn't happen normally)
                if (gate.position.y < -orthoHeight - gate.size) {
                    // Force player into a random gate
                    enterWarpGate(Math.random() < 0.5 ? 'left' : 'right');
                    return;
                }
            }
        }

        // Handle entering a warp gate
        function enterWarpGate(gateId) {
            const chosenConfig = gameState.gateChoices[gateId];

            // Clean up gates
            gameState.warpGates.forEach(gate => {
                if (sunGlowLayer) {
                    sunGlowLayer.removeIncludedOnlyMesh(gate);
                }
                gate.dispose();
            });
            gameState.warpGates = [];
            gameState.showingGates = false;
            gameState.gateChoices = null;
            document.getElementById('warpGatePanel').style.display = 'none';

            // Start the new level
            startNewLevel(chosenConfig);
        }

        // Start a new level with the given config
        function startNewLevel(config) {
            gameState.level = config.levelNum;
            gameState.levelConfig = config;
            gameState.levelWave = 0;
            gameState.stationsVisited = 0;
            gameState.wave = (gameState.level - 1) * 5 + 1; // Global wave number for difficulty

            // Update HUD to show level
            updateHUD();

            // Start first wave
            spawnWave();
        }

        // ========== END RIVER NAVIGATION ==========

        // Update suns
        function updateSuns(scrollMultiplier) {
            for (let i = gameState.suns.length - 1; i >= 0; i--) {
                const sun = gameState.suns[i];

                const moveAmount = 0.015 * settings.scrollSpeed * (0.5 + scrollMultiplier);
                sun.position.y -= moveAmount;
                sun.rotation.z += 0.0005;

                if (sun.position.y < -orthoHeight - sun.glowSize) {
                    // Remove from GlowLayer
                    if (sunGlowLayer) {
                        sunGlowLayer.removeIncludedOnlyMesh(sun);
                    }
                    sun.dispose();
                    gameState.suns.splice(i, 1);
                }
            }
        }

        // Apply subtle sun color tinting to ships when near a sun
        // Ships are excluded from GlowLayer so they won't be washed out
        // The silhouette effect happens naturally when ship is in front of the bright sun
        function applySunLighting() {
            // Simplified: no complex calculations needed since ships are excluded from bloom
            // Just apply subtle color tinting based on nearest sun
            if (gameState.suns.length === 0) return;

            const applyTintToMesh = (mesh, dist, tint) => {
                if (!mesh.material || mesh.name.indexOf('exhaust') !== -1) return;

                const tintRange = 15; // How close before sun tint applies
                if (dist < tintRange) {
                    const intensity = 1 - dist / tintRange;
                    // Subtle sun color tint on the ship
                    mesh.material.emissiveColor = new BABYLON.Color3(
                        0.25 + tint[0] * intensity * 0.15,
                        0.25 + tint[1] * intensity * 0.15,
                        0.25 + tint[2] * intensity * 0.15
                    );
                } else {
                    // Normal lighting
                    mesh.material.emissiveColor = new BABYLON.Color3(0.25, 0.25, 0.25);
                }
            };

            const applyToObject = (objX, objY, meshes) => {
                let nearestDist = Infinity;
                let nearestTint = [1, 1, 1];

                for (const sun of gameState.suns) {
                    const dx = sun.position.x - objX;
                    const dy = sun.position.y - objY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestTint = sun.tint;
                    }
                }

                meshes.forEach(mesh => applyTintToMesh(mesh, nearestDist, nearestTint));
            };

            // Apply to player ship
            if (playerShipMesh) {
                const playerMeshes = playerShipMesh.getChildMeshes(false) || [];
                if (playerShipMesh.material) playerMeshes.push(playerShipMesh);
                applyToObject(playerShip.position.x, playerShip.position.y, playerMeshes);
            }

            // Apply to enemies
            for (const enemy of gameState.enemies) {
                if (enemy.mesh) {
                    const enemyMeshes = enemy.mesh.getChildMeshes(false) || [];
                    if (enemy.mesh.material) enemyMeshes.push(enemy.mesh);
                    applyToObject(enemy.position.x, enemy.position.y, enemyMeshes);
                }
            }

            // Apply to starbase
            if (gameState.starbase) {
                const starbaseMeshes = gameState.starbase.getChildMeshes ? gameState.starbase.getChildMeshes(false) || [] : [];
                if (gameState.starbase.material) starbaseMeshes.push(gameState.starbase);
                applyToObject(gameState.starbase.position.x, gameState.starbase.position.y, starbaseMeshes);
            }

            // Update DirectionalLight for dramatic sun lighting from above
            if (gameState.sunLight && playerShip) {
                let nearestSun = null;
                let nearestDist = Infinity;

                for (const sun of gameState.suns) {
                    const dx = sun.position.x - playerShip.position.x;
                    const dy = sun.position.y - playerShip.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestSun = sun;
                    }
                }

                if (nearestSun) {
                    // Direction from sun (above) pointing down at player
                    const dx = playerShip.position.x - nearestSun.position.x;
                    const dy = playerShip.position.y - nearestSun.position.y;
                    // Light comes from high above (strong Y component) with slight XY offset toward player
                    gameState.sunLight.direction = new BABYLON.Vector3(
                        dx * 0.1,
                        -1,
                        0.3
                    ).normalize();

                    // Intensity based on distance - stronger when closer
                    const maxRange = 20;
                    const intensity = Math.max(0, 1 - nearestDist / maxRange) * 1.5;
                    gameState.sunLight.intensity = intensity;

                    // Use sun's color for the light
                    gameState.sunLight.diffuse = new BABYLON.Color3(
                        nearestSun.tint[0],
                        nearestSun.tint[1],
                        nearestSun.tint[2]
                    );
                    gameState.sunLight.specular = new BABYLON.Color3(
                        nearestSun.tint[0] * 0.5,
                        nearestSun.tint[1] * 0.5,
                        nearestSun.tint[2] * 0.5
                    );
                } else {
                    gameState.sunLight.intensity = 0;
                }
            }
        }

        // Convert world position to screen position
        function worldToScreen(worldX, worldY) {
            // Use CSS pixel dimensions for DOM element positioning
            const cssWidth = canvas.clientWidth;
            const cssHeight = canvas.clientHeight;
            const screenX = ((worldX + orthoWidth) / (orthoWidth * 2)) * cssWidth;
            const screenY = ((orthoHeight - worldY) / (orthoHeight * 2)) * cssHeight;
            return { x: screenX, y: screenY };
        }

        // Update targeting overlay
        function updateTargetingOverlay(planet) {
            const overlay = document.getElementById('targetingOverlay');
            const corners = overlay.querySelectorAll('.targeting-corner');
            const harvestBar = document.getElementById('harvestBar');
            const planetInfo = document.getElementById('planetInfo');

            if (!planet) {
                corners.forEach(c => c.style.display = 'none');
                harvestBar.style.display = 'none';
                planetInfo.style.display = 'none';
                return;
            }

            const screenPos = worldToScreen(planet.position.x, planet.position.y);
            // Use CSS pixels for proper sizing - tight on planet
            const screenSize = (planet.size / (orthoHeight * 2)) * canvas.clientHeight;
            const halfSize = screenSize / 2;

            // Richness determines targeting color
            const richnessColors = {
                1: '#888888', // Grey - common
                2: '#44aa44', // Green - uncommon
                3: '#4488ff', // Blue - rare
                4: '#aa44ff', // Purple - epic
                5: '#ffaa00'  // Gold - legendary
            };
            const targetColor = richnessColors[planet.richness] || '#888888';
            corners.forEach(c => c.style.borderColor = targetColor);

            const positions = [
                { x: screenPos.x - halfSize - 10, y: screenPos.y - halfSize - 10 }, // top-left
                { x: screenPos.x + halfSize - 10, y: screenPos.y - halfSize - 10 }, // top-right
                { x: screenPos.x - halfSize - 10, y: screenPos.y + halfSize - 10 }, // bottom-left
                { x: screenPos.x + halfSize - 10, y: screenPos.y + halfSize - 10 }  // bottom-right
            ];

            corners.forEach((corner, i) => {
                corner.style.display = 'block';
                corner.style.left = positions[i].x + 'px';
                corner.style.top = positions[i].y + 'px';
            });

            // Position harvest bar at bottom of targeting rectangle
            const barWidth = screenSize;
            harvestBar.style.left = (screenPos.x - barWidth / 2) + 'px';
            harvestBar.style.top = (screenPos.y + halfSize + 8) + 'px';
            harvestBar.style.width = barWidth + 'px';
            harvestBar.style.transform = 'none';

            // Hide planet info - richness shown through targeting color
            planetInfo.style.display = 'none';
        }

        // Update planets
        function updatePlanets(scrollMultiplier, deltaTime) {
            if (!playerShip) return;

            let nearPlanet = null;
            let nearestDist = Infinity;

            for (let i = gameState.planets.length - 1; i >= 0; i--) {
                const planet = gameState.planets[i];

                // Move planet down
                planet.position.y -= 0.015 * settings.scrollSpeed * (0.5 + scrollMultiplier);

                // Update orbit center if planet is orbiting
                if (planet.orbitCenterX !== undefined) {
                    // Find matching sun and update orbit center
                    planet.orbitAngle += planet.orbitSpeed * deltaTime;
                    // The orbit center also moves down with the solar system
                }

                // Slow rotation
                planet.rotation.z += 0.001;

                // Check distance to player - only if planet is fully visible on screen
                const planetFullyVisible = planet.position.y < (orthoHeight - planet.size / 2);

                if (planetFullyVisible) {
                    const dx = planet.position.x - playerShip.position.x;
                    const dy = planet.position.y - playerShip.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < planet.harvestRadius && planet.harvestsRemaining > 0) {
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearPlanet = planet;
                        }
                    }
                }

                // Remove if off screen
                if (planet.position.y < -orthoHeight - planet.size) {
                    planet.dispose();
                    gameState.planets.splice(i, 1);
                }
            }

            // Handle harvesting UI
            const harvestBar = document.getElementById('harvestBar');
            const harvestBarFill = document.getElementById('harvestBarFill');

            if (nearPlanet && nearPlanet.harvestsRemaining > 0) {
                if (gameState.harvestingPlanet !== nearPlanet) {
                    gameState.harvestingPlanet = nearPlanet;
                    gameState.harvestProgress = 0;
                }

                // Harvest time based on hazardousness
                gameState.harvestProgress += deltaTime / nearPlanet.harvestTime;

                harvestBar.style.display = 'block';
                harvestBarFill.style.width = `${Math.min(100, gameState.harvestProgress * 100)}%`;

                // Show targeting corners and planet info
                updateTargetingOverlay(nearPlanet);

                if (gameState.harvestProgress >= 1) {
                    // Harvest complete!
                    nearPlanet.harvestsRemaining--;
                    gameState.harvestProgress = 0;

                    // Give resources - multiply by richness
                    const resources = nearPlanet.planetData.resources;
                    const richnessMultiplier = 0.5 + nearPlanet.richness * 0.3; // 0.8x to 2x
                    Object.keys(resources).forEach(resName => {
                        const [min, max] = resources[resName];
                        const baseAmount = Math.floor(Math.random() * (max - min + 1)) + min;
                        const amount = Math.floor(baseAmount * richnessMultiplier);
                        gameState.resources[resName] += amount;
                        gameState.score += amount * 2;
                        showResourceCollection(resName, amount);
                    });

                    updateHUD();

                    createExplosion(nearPlanet.position.x, nearPlanet.position.y, 'large', 'green');

                    // Flash the planet
                    if (nearPlanet.material) {
                        const origEmissive = nearPlanet.material.emissiveColor.clone();
                        nearPlanet.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
                        setTimeout(() => {
                            if (nearPlanet.material) nearPlanet.material.emissiveColor = origEmissive;
                        }, 200);
                    }

                    if (nearPlanet.harvestsRemaining <= 0) {
                        // Planet depleted - fade it
                        if (nearPlanet.material) {
                            nearPlanet.material.alpha = 0.5;
                            nearPlanet.material.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                        }
                    }
                }
            } else {
                // Only reset if we're also not docking at a starbase
                const nearStarbase = isNearStarbase();
                if (!nearStarbase) {
                    gameState.harvestingPlanet = null;
                    gameState.harvestProgress = 0;
                    harvestBar.style.display = 'none';
                }
                updateTargetingOverlay(null);
            }
        }

        // Check if player is near a dockable starbase
        function isNearStarbase() {
            if (!gameState.starbase || !playerShip) return false;
            const starbase = gameState.starbase;
            const dx = starbase.position.x - playerShip.position.x;
            const dy = starbase.position.y - playerShip.position.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const fullyVisible = starbase.position.y < (orthoHeight - starbase.size / 2);
            return fullyVisible && dist < starbase.dockRadius;
        }

        // Load a ship model for gameplay
        async function loadShipModel(shipName, colorVariant, targetScene, faceDirection = 'up') {
            const basePath = `assets/Ultimate Spaceships/${shipName}/`;

            try {
                const result = await BABYLON.SceneLoader.ImportMeshAsync('', basePath + 'glTF/', `${shipName}.gltf`, targetScene);
                const rootMesh = result.meshes[0];

                const texturePath = `${basePath}Textures/${shipName}_${colorVariant}.png`;
                const texture = new BABYLON.Texture(texturePath, targetScene, false, true, BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
                texture.anisotropicFilteringLevel = 16;

                result.meshes.forEach(mesh => {
                    if (mesh.material) mesh.material.dispose();
                    const mat = new BABYLON.StandardMaterial(`${shipName}${colorVariant}Mat`, targetScene);
                    mat.diffuseTexture = texture;
                    mat.emissiveTexture = texture;
                    mat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                    mesh.material = mat;
                });

                const boundingInfo = rootMesh.getHierarchyBoundingVectors(true);
                const size = boundingInfo.max.subtract(boundingInfo.min);
                const maxDim = Math.max(size.x, size.y, size.z);
                const gameScale = 1.5 / maxDim;
                rootMesh.scaling = new BABYLON.Vector3(gameScale, gameScale, gameScale);

                if (faceDirection === 'up') {
                    rootMesh.rotationQuaternion = null;
                    rootMesh.rotation.set(-Math.PI / 2, 0, 0);
                } else {
                    rootMesh.rotationQuaternion = null;
                    rootMesh.rotation.set(Math.PI / 2, 0, 0);
                }

                return rootMesh;
            } catch (e) {
                console.error(`Failed to load ship ${shipName}:`, e);
                const placeholder = BABYLON.MeshBuilder.CreateBox('placeholder', {width: 0.8, height: 1.2, depth: 0.3}, targetScene);
                const mat = new BABYLON.StandardMaterial('placeholderMat', targetScene);
                mat.diffuseColor = colorVariant === 'Blue' ? new BABYLON.Color3(0.2, 0.4, 1) : new BABYLON.Color3(1, 0.2, 0.2);
                mat.emissiveColor = mat.diffuseColor.scale(0.3);
                placeholder.material = mat;
                return placeholder;
            }
        }

        // Create player ship
        // Create engine exhaust glow
        function createEngineExhaust(parent, color, offsetY, isEnemy = false) {
            const exhausts = [];
            // Create multiple exhaust points for better effect
            const exhaustPositions = isEnemy ?
                [{ x: -0.12, y: offsetY }, { x: 0.12, y: offsetY }] :
                [{ x: -0.15, y: offsetY }, { x: 0.15, y: offsetY }];

            exhaustPositions.forEach((pos, i) => {
                // Outer glow - smaller and more subtle
                const glow = BABYLON.MeshBuilder.CreateSphere('exhaust_glow_' + i, { diameter: 0.25 }, scene);
                glow.parent = parent;
                glow.position.x = pos.x;
                glow.position.y = pos.y;
                glow.position.z = 0.1; // Slightly behind ship

                const glowMat = new BABYLON.StandardMaterial('exhaustGlowMat_' + i, scene);
                glowMat.emissiveColor = color;
                glowMat.alpha = 0.3;
                glowMat.disableLighting = true;
                glowMat.backFaceCulling = false;
                glow.material = glowMat;

                // Inner core
                const core = BABYLON.MeshBuilder.CreateSphere('exhaust_core_' + i, { diameter: 0.08 }, scene);
                core.parent = parent;
                core.position.x = pos.x;
                core.position.y = pos.y;
                core.position.z = 0.1;

                const coreMat = new BABYLON.StandardMaterial('exhaustCoreMat_' + i, scene);
                coreMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
                coreMat.disableLighting = true;
                core.material = coreMat;

                // Add to glow layer
                if (sunGlowLayer) {
                    sunGlowLayer.addIncludedOnlyMesh(glow);
                    sunGlowLayer.addIncludedOnlyMesh(core);
                }

                exhausts.push({ glow, core });
            });

            return exhausts;
        }

        async function createPlayerShip() {
            playerShip = new BABYLON.TransformNode('playerShip', scene);

            playerShipMesh = await loadShipModel(settings.playerShip, settings.playerColor, scene, 'up');
            playerShipMesh.parent = playerShip;

            // Exclude ship from GlowLayer to prevent bloom washout
            if (sunGlowLayer) {
                const shipMeshes = playerShipMesh.getChildMeshes(false) || [];
                shipMeshes.push(playerShipMesh);
                shipMeshes.forEach(mesh => sunGlowLayer.addExcludedMesh(mesh));
            }

            // Add blue engine exhaust - positioned at rear of ship
            const blueColor = new BABYLON.Color3(0.3, 0.6, 1);
            playerShip.exhausts = createEngineExhaust(playerShip, blueColor, -0.5, false);

            playerShip.position = new BABYLON.Vector3(0, -7, 0);
            playerShip.targetX = 0;
            playerShip.targetY = -7;
            playerShip.velocityX = 0;
            playerShip.currentTilt = 0;

            return playerShip;
        }

        // Create stars
        function createStars(count = 150) {
            updateGameDimensions();

            for (let i = 0; i < count; i++) {
                const size = Math.random() * 0.08 + 0.02;
                const star = BABYLON.MeshBuilder.CreateSphere('star' + i, { diameter: size }, scene);

                star.position.x = (Math.random() - 0.5) * orthoWidth * 2.5;
                star.position.y = (Math.random() - 0.5) * orthoHeight * 2.5;
                star.position.z = 1 + Math.random() * 2;

                const starMat = new BABYLON.StandardMaterial('starMat' + i, scene);
                const brightness = Math.random() * 0.5 + 0.5;
                starMat.emissiveColor = new BABYLON.Color3(brightness, brightness, brightness * 0.9);
                star.material = starMat;

                star.speed = (Math.random() * 0.3 + 0.1) * (0.5 + size * 5);
                gameState.stars.push(star);
            }
        }

        // Create enemy
        async function createEnemy(type = 'basic', x, y) {
            const enemy = new BABYLON.TransformNode('enemy', scene);

            const enemyMesh = await loadShipModel(settings.enemyShip, settings.enemyColor, scene, 'down');
            enemyMesh.parent = enemy;

            // Exclude enemy ship from GlowLayer to prevent bloom washout
            if (sunGlowLayer) {
                const shipMeshes = enemyMesh.getChildMeshes(false) || [];
                shipMeshes.push(enemyMesh);
                shipMeshes.forEach(mesh => sunGlowLayer.addExcludedMesh(mesh));
            }

            // Add red engine exhaust (facing up since enemy is rotated down)
            const redColor = new BABYLON.Color3(1, 0.4, 0.2);
            enemy.exhausts = createEngineExhaust(enemy, redColor, 0.45, true);

            enemy.position.x = x;
            enemy.position.y = y;
            enemy.position.z = 0;
            enemy.type = type;
            enemy.health = type === 'shooter' ? 5 : type === 'fast' ? 2 : 3;
            enemy.speed = type === 'fast' ? 0.08 : 0.03;
            enemy.lastFireTime = 0;
            enemy.fireRate = type === 'shooter' ? 1500 : 3000;
            enemy.movementPattern = Math.random() > 0.5 ? 'sine' : 'straight';
            enemy.startX = x;
            enemy.time = Math.random() * Math.PI * 2;
            enemy.mesh = enemyMesh;
            enemy.prevX = x;
            enemy.currentTilt = 0;

            return enemy;
        }

        // Create bullet
        function createBullet(isPlayer, x, y, velocityX = 0, velocityY = 0.2) {
            let bullet;

            if (isPlayer) {
                // Player bullet: subtle glow aura + defined solid core
                bullet = BABYLON.MeshBuilder.CreateSphere('bullet', { diameter: 0.22 }, scene);
                const glowMat = new BABYLON.StandardMaterial('bulletGlowMat', scene);
                glowMat.emissiveColor = new BABYLON.Color3(0.2, 0.8, 0.4);
                glowMat.alpha = 0.25;
                glowMat.disableLighting = true;
                glowMat.backFaceCulling = false;
                bullet.material = glowMat;

                // Add glow aura to GlowLayer
                if (sunGlowLayer) {
                    sunGlowLayer.addIncludedOnlyMesh(bullet);
                }

                // Solid defined core on top
                const core = BABYLON.MeshBuilder.CreateSphere('bulletCore', { diameter: 0.12 }, scene);
                core.parent = bullet;
                core.position.z = -0.05; // Slightly in front
                const coreMat = new BABYLON.StandardMaterial('coreMat', scene);
                coreMat.emissiveColor = new BABYLON.Color3(0.4, 1, 0.6);
                coreMat.diffuseColor = new BABYLON.Color3(0.2, 0.7, 0.4);
                coreMat.disableLighting = true;
                core.material = coreMat;
            } else {
                // Enemy bullet: subtle glow capsule + bright core
                bullet = BABYLON.MeshBuilder.CreateCapsule('bullet', { height: 0.4, radius: 0.08 }, scene);
                bullet.rotation.z = Math.atan2(velocityX, -velocityY);

                const glowMat = new BABYLON.StandardMaterial('enemyBulletGlowMat', scene);
                glowMat.emissiveColor = new BABYLON.Color3(1, 0.3, 0.5);
                glowMat.alpha = 0.3;
                glowMat.disableLighting = true;
                glowMat.backFaceCulling = false;
                bullet.material = glowMat;

                // Add to glow layer
                if (sunGlowLayer) {
                    sunGlowLayer.addIncludedOnlyMesh(bullet);
                }

                // Solid core
                const core = BABYLON.MeshBuilder.CreateSphere('bulletCore', { diameter: 0.08 }, scene);
                core.parent = bullet;
                core.position.y = 0;
                core.position.z = -0.05;
                const coreMat = new BABYLON.StandardMaterial('coreMat', scene);
                coreMat.emissiveColor = new BABYLON.Color3(1, 0.7, 0.85);
                coreMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
                coreMat.disableLighting = true;
                core.material = coreMat;
            }

            bullet.position.x = x;
            bullet.position.y = y;
            bullet.position.z = -0.1;
            bullet.velocityX = velocityX;
            bullet.velocityY = velocityY;
            bullet.isPlayer = isPlayer;

            return bullet;
        }

        // Input handling
        let inputState = {
            isPressed: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0
        };

        // Keyboard state
        let keyState = {
            left: false,
            right: false,
            up: false,
            down: false
        };

        function handleInputStart(x, y) {
            inputState.isPressed = true;
            inputState.startX = x;
            inputState.startY = y;
            inputState.currentX = x;
            inputState.currentY = y;
        }

        function handleInputMove(x, y) {
            if (inputState.isPressed) {
                inputState.currentX = x;
                inputState.currentY = y;
            }
        }

        function handleInputEnd() {
            inputState.isPressed = false;
        }

        document.addEventListener('touchstart', (e) => {
            if (gameState.isPlaying && !gameState.isPaused && e.touches.length > 0) {
                e.preventDefault();
                const touch = e.touches[0];
                handleInputStart(touch.clientX, touch.clientY);
            }
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            if (gameState.isPlaying && !gameState.isPaused && e.touches.length > 0) {
                e.preventDefault();
                const touch = e.touches[0];
                handleInputMove(touch.clientX, touch.clientY);
            }
        }, { passive: false });

        document.addEventListener('touchend', (e) => {
            handleInputEnd();
        }, { passive: false });

        document.addEventListener('mousedown', (e) => {
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
            if (gameState.isPlaying && !gameState.isPaused) {
                e.preventDefault();
                handleInputStart(e.clientX, e.clientY);
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (inputState.isPressed && gameState.isPlaying && !gameState.isPaused) {
                handleInputMove(e.clientX, e.clientY);
            }
        });

        document.addEventListener('mouseup', (e) => {
            handleInputEnd();
        });

        document.addEventListener('mouseleave', (e) => {
            handleInputEnd();
        });

        // Keyboard input
        document.addEventListener('keydown', (e) => {
            if (!gameState.isPlaying || gameState.isPaused) return;

            switch(e.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    keyState.left = true;
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    keyState.right = true;
                    e.preventDefault();
                    break;
                case 'ArrowUp':
                case 'w':
                case 'W':
                    keyState.up = true;
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    keyState.down = true;
                    e.preventDefault();
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    keyState.left = false;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    keyState.right = false;
                    break;
                case 'ArrowUp':
                case 'w':
                case 'W':
                    keyState.up = false;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    keyState.down = false;
                    break;
            }
        });

        // Update player position
        function updatePlayerPosition(deltaTime) {
            if (!playerShip) return 0.3;

            // Keyboard movement
            const keySpeed = 0.015 * settings.shipSpeed * deltaTime;
            if (keyState.left) playerShip.targetX -= keySpeed;
            if (keyState.right) playerShip.targetX += keySpeed;
            if (keyState.up) playerShip.targetY += keySpeed;
            if (keyState.down) playerShip.targetY -= keySpeed;

            // Touch/mouse movement
            if (inputState.isPressed) {
                const deltaX = (inputState.currentX - inputState.startX) * settings.xSensitivity;
                const deltaY = (inputState.currentY - inputState.startY) * settings.ySensitivity;

                inputState.startX = inputState.currentX;
                inputState.startY = inputState.currentY;

                // Use CSS pixel dimensions (not render pixels) for input conversion
                const cssWidth = canvas.clientWidth;
                const cssHeight = canvas.clientHeight;
                const worldDeltaX = (deltaX / cssWidth) * orthoWidth * 2;
                const worldDeltaY = -(deltaY / cssHeight) * orthoHeight * 2;

                playerShip.targetX += worldDeltaX;
                playerShip.targetY += worldDeltaY;
            }

            const maxX = orthoWidth - 1;
            playerShip.targetX = Math.max(-maxX, Math.min(maxX, playerShip.targetX));

            const minY = -orthoHeight + 1;
            const maxY = -orthoHeight + (orthoHeight * 2 * settings.maxHeight);
            playerShip.targetY = Math.max(minY, Math.min(maxY, playerShip.targetY));

            const lerpFactor = 0.15 * settings.shipSpeed;
            const prevX = playerShip.position.x;
            playerShip.position.x += (playerShip.targetX - playerShip.position.x) * lerpFactor;
            playerShip.position.y += (playerShip.targetY - playerShip.position.y) * lerpFactor;

            playerShip.velocityX = playerShip.position.x - prevX;

            const targetTilt = -playerShip.velocityX * 8;
            const maxTilt = Math.PI / 6;
            const clampedTilt = Math.max(-maxTilt, Math.min(maxTilt, targetTilt));

            playerShip.currentTilt += (clampedTilt - playerShip.currentTilt) * 0.15;

            if (playerShipMesh) {
                playerShipMesh.rotation.y = playerShip.currentTilt;
            }

            const normalizedY = (playerShip.position.y + orthoHeight) / (orthoHeight * 2);
            return Math.max(0.1, normalizedY + 0.2);
        }

        // Fire weapons
        function firePlayerWeapons(currentTime) {
            if (!playerShip) return;

            const weapon = WEAPONS[gameState.equippedWeapon];
            const fireInterval = weapon.fireRate / settings.fireRate;

            if (currentTime - gameState.lastFireTime > fireInterval && gameState.enemies.length > 0) {
                const px = playerShip.position.x;
                const py = playerShip.position.y + 0.5;

                if (gameState.equippedWeapon === 'basic') {
                    const bullet = createBullet(true, px, py, 0, 0.35);
                    gameState.playerBullets.push(bullet);
                } else if (gameState.equippedWeapon === 'trishot') {
                    // 3-way spread
                    const bullet1 = createBullet(true, px, py, 0, 0.35);
                    const bullet2 = createBullet(true, px - 0.3, py, -0.08, 0.33);
                    const bullet3 = createBullet(true, px + 0.3, py, 0.08, 0.33);
                    gameState.playerBullets.push(bullet1, bullet2, bullet3);
                } else if (gameState.equippedWeapon === 'rapid') {
                    const bullet = createBullet(true, px, py, 0, 0.4);
                    gameState.playerBullets.push(bullet);
                } else if (gameState.equippedWeapon === 'beam') {
                    // Beam laser - create visual beam and damage all enemies in line
                    fireBeamLaser(px, py);
                }

                gameState.lastFireTime = currentTime;
            }

            // Update beam visual if active
            if (gameState.beamMesh) {
                gameState.beamMesh.alpha -= 0.05;
                if (gameState.beamMesh.alpha <= 0) {
                    gameState.beamMesh.dispose();
                    gameState.beamMesh = null;
                }
            }
        }

        // Fire beam laser
        function fireBeamLaser(px, py) {
            // Create beam visual
            if (gameState.beamMesh) {
                gameState.beamMesh.dispose();
            }

            const beamHeight = orthoHeight * 2;
            const beam = BABYLON.MeshBuilder.CreatePlane('beam', { width: 0.3, height: beamHeight }, scene);
            beam.position.x = px;
            beam.position.y = py + beamHeight / 2;
            beam.position.z = -0.1;

            const beamMat = new BABYLON.StandardMaterial('beamMat', scene);
            beamMat.emissiveColor = new BABYLON.Color3(0, 1, 0.8);
            beamMat.alpha = 0.8;
            beamMat.backFaceCulling = false;
            beam.material = beamMat;

            gameState.beamMesh = beam;
            beam.alpha = 0.8;

            // Damage all enemies in the beam's path
            const beamWidth = 0.5;
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                if (Math.abs(enemy.position.x - px) < beamWidth) {
                    enemy.health -= WEAPONS.beam.damage;
                    flashShip(enemy.mesh || enemy);

                    if (enemy.health <= 0) {
                        createExplosion(enemy.position.x, enemy.position.y, 'large', 'orange');
                        createLoot(enemy.position.x, enemy.position.y);
                        gameState.score += 50;
                        gameState.credits += 10 + Math.floor(Math.random() * 15);
                        updateHUD();

                        enemy.getChildMeshes().forEach(m => m.dispose());
                        enemy.dispose();
                        gameState.enemies.splice(i, 1);
                    }
                }
            }
        }

        // Spawn wave
        function spawnWave() {
            const waveConfig = {
                1: { count: 5 },
                2: { count: 7 },
                3: { count: 8 },
                4: { count: 10 },
                5: { count: 12 }
            };

            // Use levelWave for difficulty within level, apply enemy multiplier from level config
            const waveNum = Math.min(gameState.levelWave + 1, 5);
            const config = waveConfig[waveNum] || waveConfig[5];
            let enemyCount = config.count + Math.floor(Math.max(0, gameState.level - 1) * 2);

            // Apply level threat multiplier
            if (gameState.levelConfig) {
                enemyCount = Math.floor(enemyCount * gameState.levelConfig.enemyMultiplier);
            }

            gameState.enemiesInWave = enemyCount;
            gameState.enemiesSpawned = 0;
        }

        // Spawn enemy
        async function spawnEnemy() {
            if (gameState.enemiesSpawned >= gameState.enemiesInWave) return;

            const types = ['basic', 'basic', 'fast', 'shooter'];
            const type = types[Math.floor(Math.random() * Math.min(types.length, 1 + gameState.wave))];

            const maxX = orthoWidth - 1;
            const x = (Math.random() - 0.5) * maxX * 1.5;
            const y = orthoHeight + 2;

            const enemy = await createEnemy(type, x, y);
            gameState.enemies.push(enemy);
            gameState.enemiesSpawned++;
        }

        // Update enemies
        function updateEnemies(deltaTime, currentTime, scrollMultiplier) {
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];

                enemy.time += deltaTime * 0.003;

                const prevX = enemy.position.x;

                if (enemy.movementPattern === 'sine') {
                    enemy.position.x = enemy.startX + Math.sin(enemy.time) * 2;
                }

                enemy.position.y -= enemy.speed * settings.scrollSpeed * (0.5 + scrollMultiplier);

                const velocityX = enemy.position.x - prevX;
                const targetTilt = -velocityX * 8;
                const maxTilt = Math.PI / 6;
                const clampedTilt = Math.max(-maxTilt, Math.min(maxTilt, targetTilt));
                enemy.currentTilt += (clampedTilt - enemy.currentTilt) * 0.15;

                if (enemy.mesh) {
                    enemy.mesh.rotation.y = enemy.currentTilt;
                }

                if ((enemy.type === 'shooter' || enemy.type === 'basic') &&
                    currentTime - enemy.lastFireTime > enemy.fireRate && playerShip) {

                    const dx = playerShip.position.x - enemy.position.x;
                    const dy = playerShip.position.y - enemy.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 0) {
                        const bullet = createBullet(false, enemy.position.x, enemy.position.y - 0.3,
                            (dx / dist) * 0.1, (dy / dist) * 0.1);
                        gameState.enemyBullets.push(bullet);
                    }

                    enemy.lastFireTime = currentTime;
                }

                if (enemy.position.y < -orthoHeight - 2) {
                    // Enemy escaped - damage base shields
                    gameState.escapedEnemies++;
                    gameState.baseShields -= 10;
                    updateHUD();

                    // Show warning flash
                    const shieldsBar = document.getElementById('shieldsBarFill');
                    shieldsBar.style.background = '#ff4444';
                    setTimeout(() => {
                        shieldsBar.style.background = 'linear-gradient(90deg, #44aaff, #88ddff)';
                    }, 200);

                    if (gameState.baseShields <= 0) {
                        gameOver();
                    }

                    enemy.getChildMeshes().forEach(m => m.dispose());
                    enemy.dispose();
                    gameState.enemies.splice(i, 1);
                }
            }
        }

        // Update bullets
        function updateBullets() {
            for (let i = gameState.playerBullets.length - 1; i >= 0; i--) {
                const bullet = gameState.playerBullets[i];
                bullet.position.x += bullet.velocityX;
                bullet.position.y += bullet.velocityY;

                let bulletHit = false;
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    const dx = bullet.position.x - enemy.position.x;
                    const dy = bullet.position.y - enemy.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 0.5) {
                        enemy.health--;

                        createExplosion(bullet.position.x, bullet.position.y, 'small', 'yellow');

                        bullet.dispose();
                        gameState.playerBullets.splice(i, 1);
                        bulletHit = true;

                        if (enemy.health <= 0) {
                            createExplosion(enemy.position.x, enemy.position.y, 'large', 'orange');
                            createLoot(enemy.position.x, enemy.position.y, enemy.type);

                            const points = enemy.type === 'shooter' ? 30 : enemy.type === 'fast' ? 20 : 10;
                            gameState.score += points * gameState.wave;
                            gameState.credits += 10 + Math.floor(Math.random() * 15);
                            updateHUD();

                            enemy.getChildMeshes().forEach(m => m.dispose());
                            enemy.dispose();
                            gameState.enemies.splice(j, 1);
                        } else {
                            flashShip(enemy.mesh);
                        }
                        break;
                    }
                }

                if (!bulletHit && bullet.position.y > orthoHeight + 2) {
                    bullet.dispose();
                    gameState.playerBullets.splice(i, 1);
                }
            }

            for (let i = gameState.enemyBullets.length - 1; i >= 0; i--) {
                const bullet = gameState.enemyBullets[i];
                bullet.position.x += bullet.velocityX;
                bullet.position.y += bullet.velocityY;

                if (playerShip) {
                    const dx = bullet.position.x - playerShip.position.x;
                    const dy = bullet.position.y - playerShip.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 0.5) {
                        createExplosion(bullet.position.x, bullet.position.y, 'small', 'orange');
                        flashShip(playerShipMesh);

                        gameState.health -= 10;
                        updateHUD();
                        bullet.dispose();
                        gameState.enemyBullets.splice(i, 1);

                        if (gameState.health <= 0) {
                            createExplosion(playerShip.position.x, playerShip.position.y, 'large', 'blue');
                            gameOver();
                        }
                        continue;
                    }
                }

                if (bullet.position.y < -orthoHeight - 2 || bullet.position.y > orthoHeight + 2 ||
                    bullet.position.x < -orthoWidth - 2 || bullet.position.x > orthoWidth + 2) {
                    bullet.dispose();
                    gameState.enemyBullets.splice(i, 1);
                }
            }
        }

        // Update stars
        function updateStars(scrollMultiplier) {
            const baseSpeed = 0.05 * settings.scrollSpeed;
            const adjustedSpeed = baseSpeed * (0.5 + scrollMultiplier);

            gameState.stars.forEach(star => {
                star.position.y -= star.speed * adjustedSpeed;

                if (star.position.y < -orthoHeight - 5) {
                    star.position.y = orthoHeight + 5;
                    star.position.x = (Math.random() - 0.5) * orthoWidth * 2.5;
                }
            });
        }

        // Check collisions
        function checkPlayerCollision() {
            if (!playerShip) return;

            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                const dx = playerShip.position.x - enemy.position.x;
                const dy = playerShip.position.y - enemy.position.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 0.7) {
                    const midX = (playerShip.position.x + enemy.position.x) / 2;
                    const midY = (playerShip.position.y + enemy.position.y) / 2;
                    createExplosion(midX, midY, 'large', 'orange');

                    createLoot(enemy.position.x, enemy.position.y, enemy.type);

                    flashShip(playerShipMesh);

                    gameState.health -= 25;
                    updateHUD();

                    enemy.getChildMeshes().forEach(m => m.dispose());
                    enemy.dispose();
                    gameState.enemies.splice(i, 1);

                    if (gameState.health <= 0) {
                        createExplosion(playerShip.position.x, playerShip.position.y, 'large', 'blue');
                        gameOver();
                    }
                }
            }
        }

        // Update HUD
        function updateHUD() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('health').textContent = Math.max(0, gameState.health);
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('wave').textContent = gameState.levelWave;
            document.getElementById('totalWaves').textContent = gameState.levelConfig ? gameState.levelConfig.waveCount : 3;

            // Update base shields
            const shieldsPercent = Math.max(0, gameState.baseShields);
            document.getElementById('shieldsBarFill').style.width = `${shieldsPercent}%`;
            document.getElementById('shieldsValue').textContent = Math.max(0, gameState.baseShields);
        }

        // Game over
        function gameOver() {
            gameState.isPlaying = false;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('harvestBar').style.display = 'none';
            document.getElementById('planetInfo').style.display = 'none';
            updateTargetingOverlay(null);
        }

        // Reset game
        async function resetGame() {
            gameState.enemies.forEach(enemy => {
                enemy.getChildMeshes().forEach(m => m.dispose());
                enemy.dispose();
            });
            gameState.enemies = [];

            gameState.playerBullets.forEach(b => b.dispose());
            gameState.playerBullets = [];
            gameState.enemyBullets.forEach(b => b.dispose());
            gameState.enemyBullets = [];

            gameState.loot.forEach(l => {
                l.getChildMeshes().forEach(m => m.dispose());
                l.dispose();
            });
            gameState.loot = [];

            gameState.planets.forEach(p => p.dispose());
            gameState.planets = [];

            gameState.suns.forEach(s => {
                if (sunGlowLayer) {
                    sunGlowLayer.removeIncludedOnlyMesh(s);
                }
                s.dispose();
            });
            gameState.suns = [];

            gameState.score = 0;
            gameState.health = 100;
            gameState.wave = 1;
            gameState.lastFireTime = 0;
            gameState.waveTimer = 0;
            gameState.enemiesInWave = 0;
            gameState.enemiesSpawned = 0;
            gameState.nextSolarSystemY = orthoHeight + 15;
            gameState.harvestingPlanet = null;
            gameState.harvestProgress = 0;
            gameState.baseShields = 100;
            gameState.escapedEnemies = 0;
            gameState.pendingNotifications = {};
            gameState.lastFrameTime = performance.now();
            gameState.spawnTimer = 0;

            // Reset zone state
            gameState.currentZone = 0;
            gameState.distanceTraveled = 0;
            gameState.backgroundTransition = 0;
            gameState.transitionPhase = 0;

            // Reset background to first zone
            if (backgroundMaterialA && backgroundMaterialA.diffuseTexture) {
                backgroundMaterialA.diffuseTexture.dispose();
                const bgSize = Math.max(orthoWidth, orthoHeight) * 3;
                const textureA = new BABYLON.Texture(getBackgroundPath(0), scene);
                textureA.uScale = bgSize / 20;
                textureA.vScale = bgSize * 2 / 20;
                textureA.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;
                textureA.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;
                textureA.vOffset = 0;
                backgroundMaterialA.diffuseTexture = textureA;
                backgroundMaterialA.emissiveTexture = textureA;
            }
            if (backgroundMaterialB) {
                backgroundMaterialB.alpha = 0;
            }

            // Reset starbase and weapons
            if (gameState.starbase) {
                gameState.starbase.dispose();
                gameState.starbase = null;
            }
            if (gameState.beamMesh) {
                gameState.beamMesh.dispose();
                gameState.beamMesh = null;
            }
            gameState.isDocked = false;
            gameState.credits = 0;
            gameState.ownedWeapons = ['basic'];
            gameState.equippedWeapon = 'basic';

            // Reset level/river navigation state
            gameState.level = 1;
            gameState.levelWave = 0;
            gameState.stationsVisited = 0;
            // Generate initial level config
            gameState.levelConfig = generateLevelConfig(1);
            // Clean up any existing warp gates
            gameState.warpGates.forEach(gate => {
                if (sunGlowLayer) sunGlowLayer.removeIncludedOnlyMesh(gate);
                gate.dispose();
            });
            gameState.warpGates = [];
            gameState.gateChoices = null;
            gameState.showingGates = false;
            document.getElementById('warpGatePanel').style.display = 'none';
            document.getElementById('dockingScreen').style.display = 'none';

            initResources();

            if (playerShip) {
                playerShip.position.x = 0;
                playerShip.position.y = -7;
                playerShip.targetX = 0;
                playerShip.targetY = -7;
            }

            updateHUD();
            spawnWave();
        }

        // Settings UI
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsPanel = document.getElementById('settingsPanel');
        const closeSettings = document.getElementById('closeSettings');

        settingsBtn.addEventListener('click', () => {
            settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
            gameState.isPaused = settingsPanel.style.display === 'block';
        });

        closeSettings.addEventListener('click', () => {
            settingsPanel.style.display = 'none';
            gameState.isPaused = false;
        });

        function setupSlider(id, settingKey, suffix = '', multiplier = 1) {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(id + 'Value');

            slider.addEventListener('input', () => {
                const value = parseFloat(slider.value);
                settings[settingKey] = value * multiplier;
                valueDisplay.textContent = value + suffix;
            });
        }

        setupSlider('xSensitivity', 'xSensitivity');
        setupSlider('ySensitivity', 'ySensitivity');
        setupSlider('maxHeight', 'maxHeight', '%', 0.01);
        setupSlider('shipSpeed', 'shipSpeed', 'x');
        setupSlider('fireRate', 'fireRate', 'x');
        setupSlider('scrollSpeed', 'scrollSpeed', 'x');

        // Start game
        const startScreen = document.getElementById('startScreen');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const gameOverPanel = document.getElementById('gameOver');

        startBtn.addEventListener('click', async () => {
            previewScenes.forEach(p => {
                p.engine.stopRenderLoop();
                p.scene.dispose();
                p.engine.dispose();
            });

            startScreen.style.display = 'none';
            document.getElementById('settingsBtn').style.display = 'flex';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('shieldsDisplay').style.display = 'flex';

            createMainScene();
            await createPlayerShip();
            // Stars hidden - using background textures instead
            initResources();

            // Initialize first level
            gameState.level = 1;
            gameState.levelWave = 0;
            gameState.levelConfig = generateLevelConfig(1);
            gameState.wavesUntilStarbase = gameState.levelConfig.waveCount;

            spawnWave();

            // Initialize solar system spawning
            gameState.nextSolarSystemY = orthoHeight + 15;
            gameState.baseShields = 100;

            gameState.isPlaying = true;
            gameState.lastFrameTime = performance.now();
            gameState.spawnTimer = 0;

            scene.registerBeforeRender(() => {
                if (!gameState.isPlaying || gameState.isPaused) return;

                const currentTime = performance.now();
                const deltaTime = Math.min(currentTime - gameState.lastFrameTime, 50);
                gameState.lastFrameTime = currentTime;

                const scrollMultiplier = updatePlayerPosition(deltaTime);
                updateBackgrounds(scrollMultiplier, deltaTime);
                firePlayerWeapons(currentTime);

                gameState.spawnTimer += deltaTime;
                if (gameState.spawnTimer > 800 && gameState.enemiesSpawned < gameState.enemiesInWave) {
                    spawnEnemy();
                    gameState.spawnTimer = 0;
                }

                // Spawn solar systems with spacing
                // Check if we need to spawn a new solar system
                // nextSolarSystemY tracks when the next system should appear at the top
                gameState.nextSolarSystemY -= 0.015 * settings.scrollSpeed * (0.5 + scrollMultiplier);
                if (gameState.nextSolarSystemY < orthoHeight + 10) {
                    createSolarSystem();
                }

                // Update suns and apply lighting
                updateSuns(scrollMultiplier);
                applySunLighting();

                if (gameState.enemiesSpawned >= gameState.enemiesInWave && gameState.enemies.length === 0 && !gameState.starbase && !gameState.showingGates) {
                    gameState.wave++;
                    gameState.levelWave++;
                    updateHUD();

                    const config = gameState.levelConfig;

                    // Check if level complete (all waves done)
                    if (gameState.levelWave >= config.waveCount) {
                        // Level complete - spawn warp gates for next level choice
                        createWarpGates();
                    } else {
                        // Check if a station should appear after this wave
                        const shouldSpawnStation = config.stationWaves &&
                            config.stationWaves.includes(gameState.levelWave) &&
                            gameState.stationsVisited < config.stations.length;

                        if (shouldSpawnStation) {
                            createStarbase();
                            gameState.stationsVisited++;
                        } else {
                            spawnWave();
                        }
                    }
                }

                // Update warp gates
                updateWarpGates(scrollMultiplier, deltaTime);

                updateEnemies(deltaTime, currentTime, scrollMultiplier);
                updateBullets();
                updateLoot(scrollMultiplier);
                updatePlanets(scrollMultiplier, deltaTime);
                updateStarbase(scrollMultiplier, deltaTime);
                checkPlayerCollision();
            });

            engine.runRenderLoop(() => {
                scene.render();
            });
        });

        restartBtn.addEventListener('click', async () => {
            gameOverPanel.style.display = 'none';
            await resetGame();
            spawnWave();
            gameState.isPlaying = true;
        });

        document.getElementById('departBtn').addEventListener('click', () => {
            departStarbase();
            spawnWave();
        });

        window.addEventListener('resize', () => {
            engine.resize();
            updateGameDimensions();
        });

        createModelPreviews();
    </script>
</body>
</html>
