<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Run - Bullet Hell Shooter</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        #settingsBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #settingsBtn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        #settingsPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #4488ff;
            border-radius: 15px;
            padding: 25px;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            z-index: 200;
            display: none;
            min-width: 300px;
            max-width: 90%;
            box-shadow: 0 0 30px rgba(68, 136, 255, 0.5);
        }

        #settingsPanel h2 {
            text-align: center;
            margin-bottom: 20px;
            color: #4488ff;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .setting-group {
            margin-bottom: 15px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #aaccff;
        }

        .setting-group input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: #223355;
            border-radius: 4px;
            outline: none;
        }

        .setting-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #4488ff;
            border-radius: 50%;
            cursor: pointer;
        }

        .setting-value {
            text-align: right;
            font-size: 12px;
            color: #88aadd;
            margin-top: 3px;
        }

        #closeSettings {
            width: 100%;
            padding: 12px;
            margin-top: 15px;
            background: #4488ff;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #closeSettings:hover {
            background: #5599ff;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 14px;
            z-index: 50;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
        }

        #hud div {
            margin-bottom: 3px;
        }

        #shieldsDisplay {
            position: absolute;
            top: 10px;
            right: 60px;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 14px;
            z-index: 50;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #shieldsBar {
            width: 100px;
            height: 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #44aaff;
            border-radius: 6px;
            overflow: hidden;
        }

        #shieldsBarFill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #44aaff, #88ddff);
            transition: width 0.3s ease;
        }

        #resourcesHud {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 50;
            font-family: 'Segoe UI', Arial, sans-serif;
        }

        .resource-icon {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 4px;
            font-size: 13px;
            font-weight: bold;
        }

        .resource-icon .symbol {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: #000;
        }

        .resource-icon .count {
            color: #fff;
        }

        /* Resource collection notifications below top UI */
        #collectNotifications {
            position: absolute;
            top: 75px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 70;
            pointer-events: none;
        }

        .collect-notif {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 6px;
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 14px;
            font-weight: bold;
            animation: collectPop 2s forwards;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .collect-notif .symbol {
            width: 22px;
            height: 22px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: #000;
        }

        .collect-notif .amount {
            color: #fff;
        }

        @keyframes collectPop {
            0% { opacity: 0; transform: translateY(10px) scale(0.8); }
            10% { opacity: 1; transform: translateY(0) scale(1.1); }
            20% { transform: translateY(0) scale(1); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-10px); }
        }

        /* Harvest progress bar - clean flat at bottom */
        #harvestBar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 250px;
            height: 6px;
            background: rgba(0, 0, 0, 0.6);
            overflow: hidden;
            display: none;
            z-index: 60;
        }

        #harvestBarFill {
            height: 100%;
            width: 0%;
            background: #44ffaa;
            transition: width 0.1s linear;
        }

        /* Targeting corners overlay */
        #targetingOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 55;
        }

        .targeting-corner {
            position: absolute;
            width: 20px;
            height: 20px;
            border-color: #44ffaa;
            border-style: solid;
            border-width: 0;
        }

        .targeting-corner.top-left {
            border-top-width: 3px;
            border-left-width: 3px;
        }

        .targeting-corner.top-right {
            border-top-width: 3px;
            border-right-width: 3px;
        }

        .targeting-corner.bottom-left {
            border-bottom-width: 3px;
            border-left-width: 3px;
        }

        .targeting-corner.bottom-right {
            border-bottom-width: 3px;
            border-right-width: 3px;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #ff4444;
            border-radius: 15px;
            padding: 30px 50px;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            z-index: 150;
            display: none;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 68, 68, 0.5);
        }

        #gameOver h2 {
            color: #ff4444;
            font-size: 32px;
            margin-bottom: 15px;
        }

        #gameOver p {
            font-size: 18px;
            margin-bottom: 20px;
        }

        #restartBtn {
            padding: 12px 30px;
            background: #ff4444;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            text-transform: uppercase;
        }

        #restartBtn:hover {
            background: #ff5555;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #0a0a20 0%, #1a1a40 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            z-index: 300;
            font-family: 'Segoe UI', Arial, sans-serif;
            color: white;
            padding-top: 20px;
            overflow-y: auto;
        }

        #startScreen h1 {
            font-size: 36px;
            color: #4488ff;
            text-shadow: 0 0 20px rgba(68, 136, 255, 0.8);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        #startScreen p {
            font-size: 14px;
            color: #aaccff;
            margin-bottom: 15px;
            text-align: center;
            max-width: 80%;
            line-height: 1.4;
        }

        #modelGrid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            padding: 10px;
            max-width: 100%;
            width: 100%;
        }

        .model-card {
            background: rgba(30, 30, 60, 0.8);
            border: 1px solid #334;
            border-radius: 8px;
            padding: 5px;
            text-align: center;
        }

        .model-card canvas {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 4px;
            background: #111;
        }

        .model-card .model-name {
            font-size: 11px;
            color: #88aadd;
            margin-top: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #startBtn {
            padding: 15px 50px;
            background: #4488ff;
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 20px rgba(68, 136, 255, 0.5);
            margin: 20px 0;
        }

        #startBtn:hover {
            background: #5599ff;
            box-shadow: 0 0 30px rgba(68, 136, 255, 0.8);
        }

        #loadingText {
            color: #4488ff;
            font-size: 18px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>

    <div id="startScreen">
        <h1>Space Run</h1>
        <p>Drag to move ship. Up to advance, down to retreat.<br>Weapons fire automatically! Harvest planets for resources!</p>
        <button id="startBtn" style="display: none;">Start Game</button>
        <div id="loadingText">Loading models...</div>
        <div id="modelGrid"></div>
    </div>

    <button id="settingsBtn" style="display: none;">âš™</button>

    <div id="settingsPanel">
        <h2>Settings</h2>
        <div class="setting-group">
            <label>X Sensitivity (Horizontal)</label>
            <input type="range" id="xSensitivity" min="0.5" max="3" step="0.1" value="1.5">
            <div class="setting-value" id="xSensitivityValue">1.5</div>
        </div>
        <div class="setting-group">
            <label>Y Sensitivity (Vertical)</label>
            <input type="range" id="ySensitivity" min="0.5" max="3" step="0.1" value="1.2">
            <div class="setting-value" id="ySensitivityValue">1.2</div>
        </div>
        <div class="setting-group">
            <label>Max Ship Height (% of screen)</label>
            <input type="range" id="maxHeight" min="30" max="70" step="5" value="50">
            <div class="setting-value" id="maxHeightValue">50%</div>
        </div>
        <div class="setting-group">
            <label>Ship Speed</label>
            <input type="range" id="shipSpeed" min="0.5" max="2" step="0.1" value="1">
            <div class="setting-value" id="shipSpeedValue">1.0x</div>
        </div>
        <div class="setting-group">
            <label>Fire Rate</label>
            <input type="range" id="fireRate" min="0.5" max="3" step="0.1" value="1">
            <div class="setting-value" id="fireRateValue">1.0x</div>
        </div>
        <div class="setting-group">
            <label>Scroll Speed</label>
            <input type="range" id="scrollSpeed" min="0.5" max="2" step="0.1" value="1">
            <div class="setting-value" id="scrollSpeedValue">1.0x</div>
        </div>
        <button id="closeSettings">Close</button>
    </div>

    <div id="hud" style="display: none;">
        <div>Score: <span id="score">0</span></div>
        <div>Health: <span id="health">100</span></div>
        <div>Wave: <span id="wave">1</span></div>
    </div>

    <div id="shieldsDisplay" style="display: none;">
        <span>Base:</span>
        <div id="shieldsBar"><div id="shieldsBarFill"></div></div>
        <span id="shieldsValue">100</span>
    </div>

    <div id="resourcesHud" style="display: none;"></div>
    <div id="collectNotifications"></div>

    <div id="harvestBar"><div id="harvestBarFill"></div></div>
    <div id="targetingOverlay">
        <div class="targeting-corner top-left"></div>
        <div class="targeting-corner top-right"></div>
        <div class="targeting-corner bottom-left"></div>
        <div class="targeting-corner bottom-right"></div>
    </div>

    <div id="gameOver">
        <h2>Game Over</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button id="restartBtn">Play Again</button>
    </div>

    <script>
        // Ship model names
        const shipNames = ['Bob', 'Challenger', 'Dispatcher', 'Executioner', 'Imperial',
                          'Insurgent', 'Omen', 'Pancake', 'Spitfire', 'Striker', 'Zenith'];
        const colorVariants = ['Blue', 'Green', 'Orange', 'Purple', 'Red'];

        // Resource types with colors for display
        const RESOURCES = {
            Iron: { color: '#aaaaaa', symbol: 'Fe' },
            Copper: { color: '#dd8844', symbol: 'Cu' },
            Silicon: { color: '#88aacc', symbol: 'Si' },
            Titanium: { color: '#ccccee', symbol: 'Ti' },
            Hydrogen: { color: '#aaddff', symbol: 'H' },
            Helium: { color: '#ffddaa', symbol: 'He' },
            Water: { color: '#4488ff', symbol: 'H2O' },
            Carbon: { color: '#444444', symbol: 'C' },
            Oxygen: { color: '#aaffaa', symbol: 'O' },
            Sulfur: { color: '#dddd44', symbol: 'S' },
            Nitrogen: { color: '#aaaaff', symbol: 'N' },
            Gold: { color: '#ffdd00', symbol: 'Au' }
        };

        // Planet types with their resources and image paths
        const PLANET_TYPES = {
            // Gaseous planets - yield gases
            BlueGiant: {
                category: 'Gaseous', folder: 'Blue Giant', prefix: 'BlueGiant',
                resources: { Hydrogen: [30, 50], Helium: [20, 40] }, harvests: 2, tint: [0.7, 0.8, 1.0]
            },
            GreenGiant: {
                category: 'Gaseous', folder: 'Green Giant', prefix: 'GreenGiant',
                resources: { Hydrogen: [25, 45], Nitrogen: [15, 30] }, harvests: 2, tint: [0.7, 1.0, 0.8]
            },
            OrangeGiant: {
                category: 'Gaseous', folder: 'Orange Giant', prefix: 'OrgangeGiant',
                resources: { Helium: [35, 55], Hydrogen: [20, 35] }, harvests: 2, tint: [1.0, 0.8, 0.6]
            },
            RedGiant: {
                category: 'Gaseous', folder: 'Red Giant', prefix: 'RedGiant',
                resources: { Hydrogen: [40, 60], Helium: [25, 40] }, harvests: 3, tint: [1.0, 0.7, 0.7]
            },
            YellowGiant: {
                category: 'Gaseous', folder: 'Yellow Giant', prefix: 'YellowGiant',
                resources: { Helium: [30, 50], Hydrogen: [25, 40] }, harvests: 2, tint: [1.0, 1.0, 0.8]
            },
            // Rocky planets - yield metals
            Rocky: {
                category: 'Solid', folder: 'Rocky', prefix: 'Rocky',
                resources: { Iron: [15, 30], Silicon: [10, 20] }, harvests: 2, tint: [0.9, 0.8, 0.7]
            },
            Cratered: {
                category: 'Solid', folder: 'Cratered', prefix: 'Cratered',
                resources: { Iron: [20, 35], Titanium: [10, 20] }, harvests: 2, tint: [0.8, 0.8, 0.8]
            },
            Barren: {
                category: 'Solid', folder: 'Barren', prefix: 'Barren',
                resources: { Silicon: [15, 25], Copper: [10, 20] }, harvests: 1, tint: [0.9, 0.85, 0.8]
            },
            Lunar: {
                category: 'Solid', folder: 'Lunar', prefix: 'Lunar',
                resources: { Titanium: [15, 30], Iron: [10, 20] }, harvests: 1, tint: [0.85, 0.85, 0.9]
            },
            // Ice planets - yield water and gases
            Frozen: {
                category: 'Solid', folder: 'Frozen', prefix: 'Frozen',
                resources: { Water: [25, 45], Nitrogen: [15, 25] }, harvests: 2, tint: [0.8, 0.9, 1.0]
            },
            Icy: {
                category: 'Solid', folder: 'Icy', prefix: 'Icy',
                resources: { Water: [30, 50], Oxygen: [10, 20] }, harvests: 2, tint: [0.85, 0.95, 1.0]
            },
            Glacial: {
                category: 'Solid', folder: 'Glacial', prefix: 'Glacial',
                resources: { Water: [35, 55], Nitrogen: [15, 30] }, harvests: 3, tint: [0.75, 0.9, 1.0]
            },
            // Volcanic - yield rare metals
            Magma: {
                category: 'Solid', folder: 'Magma', prefix: 'Magma',
                resources: { Iron: [25, 45], Sulfur: [20, 35], Gold: [5, 15] }, harvests: 2, tint: [1.0, 0.7, 0.5]
            },
            // Life planets - yield organics
            Lush: {
                category: 'Solid', folder: 'Lush', prefix: 'Lush',
                resources: { Carbon: [20, 40], Oxygen: [25, 45], Water: [15, 25] }, harvests: 3, tint: [0.8, 1.0, 0.8]
            },
            Tropical: {
                category: 'Solid', folder: 'Tropical', prefix: 'Tropical',
                resources: { Carbon: [25, 45], Oxygen: [20, 35], Water: [20, 35] }, harvests: 3, tint: [0.85, 1.0, 0.85]
            },
            Ocean: {
                category: 'Solid', folder: 'Ocean', prefix: 'Ocean',
                resources: { Water: [50, 80], Oxygen: [15, 30] }, harvests: 4, tint: [0.7, 0.85, 1.0]
            },
            // Arid planets
            Arid: {
                category: 'Solid', folder: 'Arid', prefix: 'Arid',
                resources: { Silicon: [20, 35], Copper: [15, 25] }, harvests: 1, tint: [1.0, 0.9, 0.7]
            },
            Dry: {
                category: 'Solid', folder: 'Dry', prefix: 'Dry',
                resources: { Silicon: [15, 30], Iron: [10, 20] }, harvests: 1, tint: [0.95, 0.85, 0.7]
            }
        };

        // Game Settings
        const settings = {
            xSensitivity: 1.5,
            ySensitivity: 1.2,
            maxHeight: 0.5,
            shipSpeed: 1.0,
            fireRate: 1.0,
            scrollSpeed: 1.0,
            playerShip: 'Bob',
            playerColor: 'Blue',
            enemyShip: 'Spitfire',
            enemyColor: 'Red'
        };

        // Loaded model templates
        const modelTemplates = {};
        const previewScenes = [];

        // Sun types
        const SUN_TYPES = {
            YellowSun: { folder: 'Yellow Sun', prefix: 'Sun_Yellow', tint: [1.0, 1.0, 0.8] },
            RedSun: { folder: 'Red Sun', prefix: 'Sun_Red', tint: [1.0, 0.7, 0.6] },
            BlueSun: { folder: 'Blue Sun', prefix: 'Sun_Blue', tint: [0.7, 0.8, 1.0] }
        };

        // Game State
        let gameState = {
            score: 0,
            health: 100,
            wave: 1,
            isPlaying: false,
            isPaused: false,
            enemies: [],
            playerBullets: [],
            enemyBullets: [],
            loot: [],
            planets: [],
            suns: [],
            solarSystems: [],
            stars: [],
            lastFireTime: 0,
            waveTimer: 0,
            enemiesInWave: 0,
            enemiesSpawned: 0,
            nextSolarSystemY: 0,
            harvestingPlanet: null,
            harvestProgress: 0,
            resources: {},
            baseShields: 100,
            escapedEnemies: 0,
            pendingNotifications: {}
        };

        // Initialize resources
        function initResources() {
            gameState.resources = {};
            Object.keys(RESOURCES).forEach(r => gameState.resources[r] = 0);
        }

        // Main game canvas and engine
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true);

        // Game dimensions
        let gameWidth, gameHeight, orthoHeight = 10, orthoWidth;

        function updateGameDimensions() {
            gameWidth = engine.getRenderWidth();
            gameHeight = engine.getRenderHeight();
            const aspect = gameWidth / gameHeight;
            orthoWidth = orthoHeight * aspect;
        }

        // Create preview cards for each ship
        async function createModelPreviews() {
            const modelGrid = document.getElementById('modelGrid');
            const loadingText = document.getElementById('loadingText');

            let loadedCount = 0;
            const totalModels = shipNames.length;

            for (const shipName of shipNames) {
                const card = document.createElement('div');
                card.className = 'model-card';

                const previewCanvas = document.createElement('canvas');
                previewCanvas.id = `preview-${shipName}`;
                card.appendChild(previewCanvas);

                const nameLabel = document.createElement('div');
                nameLabel.className = 'model-name';
                nameLabel.textContent = shipName;
                card.appendChild(nameLabel);

                modelGrid.appendChild(card);

                const previewEngine = new BABYLON.Engine(previewCanvas, true);
                const previewScene = new BABYLON.Scene(previewEngine);
                previewScene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.15, 1);

                const camera = new BABYLON.ArcRotateCamera('camera', 0, Math.PI / 3, 5, BABYLON.Vector3.Zero(), previewScene);

                const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), previewScene);
                light.intensity = 1.0;
                const light2 = new BABYLON.DirectionalLight('light2', new BABYLON.Vector3(1, -1, 1), previewScene);
                light2.intensity = 0.5;

                try {
                    const basePath = `assets/Ultimate Spaceships/${shipName}/`;
                    const result = await BABYLON.SceneLoader.ImportMeshAsync('', basePath + 'glTF/', `${shipName}.gltf`, previewScene);

                    const rootMesh = result.meshes[0];

                    const texturePath = `${basePath}Textures/${shipName}_Blue.png`;
                    const texture = new BABYLON.Texture(texturePath, previewScene);

                    result.meshes.forEach(mesh => {
                        if (mesh.material) mesh.material.dispose();
                        const mat = new BABYLON.StandardMaterial(`${shipName}Mat`, previewScene);
                        mat.diffuseTexture = texture;
                        mat.emissiveTexture = texture;
                        mat.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                        mat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                        mesh.material = mat;
                    });

                    const boundingInfo = rootMesh.getHierarchyBoundingVectors(true);
                    const size = boundingInfo.max.subtract(boundingInfo.min);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 2 / maxDim;
                    rootMesh.scaling = new BABYLON.Vector3(scale, scale, scale);

                    const center = boundingInfo.min.add(boundingInfo.max).scale(0.5 * scale);
                    rootMesh.position = center.negate();

                    previewScene.shipMesh = rootMesh;

                    modelTemplates[shipName] = { path: basePath, scale: scale };

                } catch (e) {
                    console.error(`Failed to load ${shipName}:`, e);
                    const placeholder = BABYLON.MeshBuilder.CreateBox('placeholder', {size: 1}, previewScene);
                    const mat = new BABYLON.StandardMaterial('placeholderMat', previewScene);
                    mat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                    placeholder.material = mat;
                    previewScene.shipMesh = placeholder;
                }

                previewEngine.runRenderLoop(() => {
                    if (previewScene.shipMesh) previewScene.shipMesh.rotation.y += 0.02;
                    previewScene.render();
                });

                previewScenes.push({ engine: previewEngine, scene: previewScene });

                loadedCount++;
                loadingText.textContent = `Loading models... ${loadedCount}/${totalModels}`;
            }

            loadingText.style.display = 'none';
            document.getElementById('startBtn').style.display = 'block';
        }

        // Main game scene
        let scene, playerShip, playerShipMesh;
        let materials = {};

        function createMainScene() {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.02, 0.02, 0.08, 1);

            const camera = new BABYLON.FreeCamera('camera', new BABYLON.Vector3(0, 0, -10), scene);
            camera.setTarget(new BABYLON.Vector3(0, 0, 0));
            camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;

            function updateCamera() {
                updateGameDimensions();
                const aspect = gameWidth / gameHeight;
                camera.orthoTop = orthoHeight;
                camera.orthoBottom = -orthoHeight;
                camera.orthoLeft = -orthoHeight * aspect;
                camera.orthoRight = orthoHeight * aspect;
            }
            updateCamera();
            window.addEventListener('resize', updateCamera);

            const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, -1), scene);
            light.intensity = 1.0;
            const light2 = new BABYLON.DirectionalLight('light2', new BABYLON.Vector3(0, 0, -1), scene);
            light2.intensity = 0.8;

            materials.playerBullet = new BABYLON.StandardMaterial('playerBulletMat', scene);
            materials.playerBullet.emissiveColor = new BABYLON.Color3(0, 1, 0.5);

            materials.enemyBullet = new BABYLON.StandardMaterial('enemyBulletMat', scene);
            materials.enemyBullet.emissiveColor = new BABYLON.Color3(1, 0.5, 0);

            return scene;
        }

        // Show collection notification as icon at top
        function showResourceCollection(resourceType, amount) {
            // Batch notifications for the same resource
            if (!gameState.pendingNotifications[resourceType]) {
                gameState.pendingNotifications[resourceType] = {
                    amount: 0,
                    timeout: null
                };
            }

            gameState.pendingNotifications[resourceType].amount += amount;

            // Clear existing timeout and set a new one
            if (gameState.pendingNotifications[resourceType].timeout) {
                clearTimeout(gameState.pendingNotifications[resourceType].timeout);
            }

            // Show notification after small delay to batch rapid collections
            gameState.pendingNotifications[resourceType].timeout = setTimeout(() => {
                const totalAmount = gameState.pendingNotifications[resourceType].amount;
                delete gameState.pendingNotifications[resourceType];

                const container = document.getElementById('collectNotifications');
                const resourceInfo = RESOURCES[resourceType];

                const notif = document.createElement('div');
                notif.className = 'collect-notif';
                notif.innerHTML = `
                    <div class="symbol" style="background: ${resourceInfo.color}">${resourceInfo.symbol}</div>
                    <span class="amount">x${totalAmount}</span>
                `;
                container.appendChild(notif);

                setTimeout(() => notif.remove(), 2000);
            }, 100);
        }

        // Create explosion effect
        function createExplosion(x, y, size = 'small', color = 'orange') {
            if (!scene) return;

            const isLarge = size === 'large';
            const particleCount = isLarge ? 30 : 12;
            const explosionSize = isLarge ? 0.8 : 0.3;
            const duration = isLarge ? 600 : 300;

            const particles = [];
            const colors = {
                orange: { r: 1, g: 0.5, b: 0 },
                red: { r: 1, g: 0.2, b: 0.1 },
                blue: { r: 0.3, g: 0.5, b: 1 },
                yellow: { r: 1, g: 0.8, b: 0.2 },
                green: { r: 0.3, g: 1, b: 0.5 }
            };
            const baseColor = colors[color] || colors.orange;

            for (let i = 0; i < particleCount; i++) {
                const particle = BABYLON.MeshBuilder.CreateSphere('explosionParticle', {
                    diameter: explosionSize * (0.3 + Math.random() * 0.7)
                }, scene);

                particle.position.x = x;
                particle.position.y = y;
                particle.position.z = -0.1;

                const angle = Math.random() * Math.PI * 2;
                const speed = (isLarge ? 0.15 : 0.08) * (0.5 + Math.random());
                particle.velocityX = Math.cos(angle) * speed;
                particle.velocityY = Math.sin(angle) * speed;

                const mat = new BABYLON.StandardMaterial('explosionMat' + i, scene);
                const colorVariation = 0.8 + Math.random() * 0.4;
                mat.emissiveColor = new BABYLON.Color3(
                    baseColor.r * colorVariation,
                    baseColor.g * colorVariation,
                    baseColor.b * colorVariation
                );
                mat.disableLighting = true;
                particle.material = mat;

                particle.startTime = performance.now();
                particle.duration = duration * (0.7 + Math.random() * 0.6);
                particles.push(particle);
            }

            const animateExplosion = () => {
                const now = performance.now();
                let allDone = true;

                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    const elapsed = now - p.startTime;
                    const progress = elapsed / p.duration;

                    if (progress >= 1) {
                        p.dispose();
                        particles.splice(i, 1);
                    } else {
                        allDone = false;
                        p.position.x += p.velocityX;
                        p.position.y += p.velocityY;
                        p.velocityX *= 0.95;
                        p.velocityY *= 0.95;
                        const scale = 1 - progress * 0.5;
                        p.scaling.setAll(scale);
                        if (p.material) p.material.alpha = 1 - progress;
                    }
                }

                if (!allDone) requestAnimationFrame(animateExplosion);
            };

            requestAnimationFrame(animateExplosion);
        }

        // Flash effect for ships when hit
        function flashShip(meshOrNode, duration = 150) {
            if (!meshOrNode) return;

            const meshes = meshOrNode.getChildMeshes ? meshOrNode.getChildMeshes() : [meshOrNode];
            const originalColors = [];

            meshes.forEach((mesh, i) => {
                if (mesh.material) {
                    originalColors[i] = mesh.material.emissiveColor.clone();
                    mesh.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
                }
            });

            setTimeout(() => {
                meshes.forEach((mesh, i) => {
                    if (mesh.material && originalColors[i]) {
                        mesh.material.emissiveColor = originalColors[i];
                    }
                });
            }, duration);
        }

        // Create loot drop when enemy dies (now gives resources)
        function createLoot(x, y, enemyType) {
            if (!scene) return;

            // Enemies drop ship materials
            const enemyResources = ['Iron', 'Copper', 'Titanium', 'Silicon'];
            const pieceCount = enemyType === 'shooter' ? 3 : enemyType === 'fast' ? 1 : 2;

            for (let i = 0; i < pieceCount; i++) {
                const shapes = ['box', 'octahedron', 'icosphere'];
                const shapeType = shapes[Math.floor(Math.random() * shapes.length)];

                let lootMesh;
                // BIGGER LOOT SIZE
                const size = 0.35 + Math.random() * 0.15;

                if (shapeType === 'box') {
                    lootMesh = BABYLON.MeshBuilder.CreateBox('loot', { size: size }, scene);
                } else if (shapeType === 'octahedron') {
                    lootMesh = BABYLON.MeshBuilder.CreatePolyhedron('loot', { type: 1, size: size * 0.5 }, scene);
                } else {
                    lootMesh = BABYLON.MeshBuilder.CreateIcoSphere('loot', { radius: size * 0.5, subdivisions: 1 }, scene);
                }

                const offsetX = (Math.random() - 0.5) * 1.5;
                const offsetY = (Math.random() - 0.5) * 1.5;
                lootMesh.position.x = x + offsetX;
                lootMesh.position.y = y + offsetY;
                lootMesh.position.z = -0.2;

                lootMesh.rotation.x = Math.random() * Math.PI * 2;
                lootMesh.rotation.y = Math.random() * Math.PI * 2;
                lootMesh.rotation.z = Math.random() * Math.PI * 2;

                // Assign a resource type
                const resourceType = enemyResources[Math.floor(Math.random() * enemyResources.length)];
                const resourceInfo = RESOURCES[resourceType];

                const lootMat = new BABYLON.StandardMaterial('lootMat', scene);
                // Parse hex color
                const hex = resourceInfo.color;
                const r = parseInt(hex.slice(1,3), 16) / 255;
                const g = parseInt(hex.slice(3,5), 16) / 255;
                const b = parseInt(hex.slice(5,7), 16) / 255;

                lootMat.emissiveColor = new BABYLON.Color3(r, g, b);
                lootMat.diffuseColor = new BABYLON.Color3(r * 0.5, g * 0.5, b * 0.5);
                lootMat.specularColor = new BABYLON.Color3(1, 1, 1);
                lootMesh.material = lootMat;

                // Bigger glow core
                const core = BABYLON.MeshBuilder.CreateSphere('lootCore', { diameter: size * 0.7 }, scene);
                core.parent = lootMesh;
                const coreMat = new BABYLON.StandardMaterial('lootCoreMat', scene);
                coreMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
                coreMat.disableLighting = true;
                coreMat.alpha = 0.7;
                core.material = coreMat;

                lootMesh.velocityX = offsetX * 0.02;
                lootMesh.velocityY = offsetY * 0.02;
                lootMesh.rotSpeed = (Math.random() - 0.5) * 0.1;
                lootMesh.pulsePhase = Math.random() * Math.PI * 2;
                lootMesh.baseColor = { r, g, b };
                lootMesh.resourceType = resourceType;
                lootMesh.resourceAmount = Math.floor(Math.random() * 3) + 1; // 1-3 per piece
                lootMesh.spawnTime = performance.now();

                gameState.loot.push(lootMesh);
            }
        }

        // Update loot
        function updateLoot(scrollMultiplier) {
            if (!playerShip) return;

            const now = performance.now();

            for (let i = gameState.loot.length - 1; i >= 0; i--) {
                const loot = gameState.loot[i];

                loot.velocityX *= 0.98;
                loot.velocityY *= 0.98;

                loot.position.x += loot.velocityX;
                loot.position.y += loot.velocityY - 0.02 * settings.scrollSpeed * (0.5 + scrollMultiplier);

                loot.rotation.x += loot.rotSpeed;
                loot.rotation.y += loot.rotSpeed * 1.3;
                loot.rotation.z += loot.rotSpeed * 0.7;

                const age = (now - loot.spawnTime) / 1000;
                const pulse = 0.7 + 0.3 * Math.sin(age * 5 + loot.pulsePhase);
                if (loot.material) {
                    loot.material.emissiveColor = new BABYLON.Color3(
                        loot.baseColor.r * pulse,
                        loot.baseColor.g * pulse,
                        loot.baseColor.b * pulse
                    );
                }

                const dx = loot.position.x - playerShip.position.x;
                const dy = loot.position.y - playerShip.position.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 1.2) {
                    // Collect resource (no notification for enemy loot, only planets)
                    gameState.resources[loot.resourceType] += loot.resourceAmount;
                    gameState.score += loot.resourceAmount * 5;
                    updateHUD();

                    createExplosion(loot.position.x, loot.position.y, 'small', 'blue');

                    loot.getChildMeshes().forEach(m => m.dispose());
                    loot.dispose();
                    gameState.loot.splice(i, 1);
                    continue;
                }

                if (loot.position.y < -orthoHeight - 2) {
                    loot.getChildMeshes().forEach(m => m.dispose());
                    loot.dispose();
                    gameState.loot.splice(i, 1);
                }
            }
        }

        // Create a sun
        function createSun(x, y) {
            if (!scene) return null;

            const sunTypeKeys = Object.keys(SUN_TYPES);
            const sunTypeKey = sunTypeKeys[Math.floor(Math.random() * sunTypeKeys.length)];
            const sunType = SUN_TYPES[sunTypeKey];

            const variant = Math.floor(Math.random() * 5) + 1;
            const variantStr = variant.toString().padStart(2, '0');
            const imagePath = `assets/Medium Planets 256x256/Suns/${sunType.folder}/${sunType.prefix}_${variantStr}-256x256.png`;

            const sunSize = 4 + Math.random() * 2; // 4-6 units

            const sun = BABYLON.MeshBuilder.CreatePlane('sun', { size: sunSize }, scene);
            sun.position.x = x;
            sun.position.y = y;
            sun.position.z = 0.6; // Behind planets

            const texture = new BABYLON.Texture(imagePath, scene);
            texture.hasAlpha = true;

            const mat = new BABYLON.StandardMaterial('sunMat', scene);
            mat.diffuseTexture = texture;
            mat.emissiveTexture = texture;
            mat.emissiveColor = new BABYLON.Color3(
                sunType.tint[0] * 0.6,
                sunType.tint[1] * 0.6,
                sunType.tint[2] * 0.6
            );
            mat.useAlphaFromDiffuseTexture = true;
            mat.backFaceCulling = false;
            sun.material = mat;

            sun.size = sunSize;
            sun.isSun = true;

            return sun;
        }

        // Create a planet at specific position
        function createPlanetAt(x, y) {
            if (!scene) return null;

            const typeKeys = Object.keys(PLANET_TYPES);
            const typeKey = typeKeys[Math.floor(Math.random() * typeKeys.length)];
            const planetType = PLANET_TYPES[typeKey];

            const variant = Math.floor(Math.random() * 5) + 1;
            const variantStr = variant.toString().padStart(2, '0');
            const imagePath = `assets/Medium Planets 256x256/${planetType.category}/${planetType.folder}/${planetType.prefix}_${variantStr}-256x256.png`;

            const planetSize = 2 + Math.random() * 1.5; // 2-3.5 units

            const planet = BABYLON.MeshBuilder.CreatePlane('planet', { size: planetSize }, scene);
            planet.position.x = x;
            planet.position.y = y;
            planet.position.z = 0.5;

            const texture = new BABYLON.Texture(imagePath, scene);
            texture.hasAlpha = true;

            const mat = new BABYLON.StandardMaterial('planetMat', scene);
            mat.diffuseTexture = texture;
            mat.emissiveTexture = texture;
            mat.emissiveColor = new BABYLON.Color3(
                planetType.tint[0] * 0.3,
                planetType.tint[1] * 0.3,
                planetType.tint[2] * 0.3
            );
            mat.useAlphaFromDiffuseTexture = true;
            mat.backFaceCulling = false;
            planet.material = mat;

            planet.planetType = typeKey;
            planet.planetData = planetType;
            planet.harvestsRemaining = planetType.harvests;
            planet.size = planetSize;
            planet.harvestRadius = planetSize * 0.8;

            return planet;
        }

        // Create a solar system (sun with orbiting planets)
        function createSolarSystem() {
            if (!scene) return;

            // Center of solar system
            const centerX = (Math.random() - 0.5) * (orthoWidth * 1.2);
            const centerY = orthoHeight + 8; // Start above screen

            // Create sun at center
            const sun = createSun(centerX, centerY);
            if (sun) {
                gameState.suns.push(sun);
            }

            // Create 2-5 planets orbiting the sun
            const planetCount = 2 + Math.floor(Math.random() * 4);
            const minOrbitRadius = sun ? sun.size * 0.8 : 3;

            for (let i = 0; i < planetCount; i++) {
                const orbitRadius = minOrbitRadius + 2 + i * 2 + Math.random() * 1.5;
                const angle = Math.random() * Math.PI * 2;

                const px = centerX + Math.cos(angle) * orbitRadius;
                const py = centerY + Math.sin(angle) * orbitRadius * 0.4; // Flatten orbits

                const planet = createPlanetAt(px, py);
                if (planet) {
                    planet.orbitCenterX = centerX;
                    planet.orbitRadius = orbitRadius;
                    planet.orbitAngle = angle;
                    planet.orbitSpeed = 0.0003 + Math.random() * 0.0002;
                    gameState.planets.push(planet);
                }
            }

            // Schedule next solar system with spacing (screen's worth on average)
            const spacing = orthoHeight * 2 * (0.7 + Math.random() * 0.6); // 0.7-1.3 screens
            gameState.nextSolarSystemY = centerY + spacing;
        }

        // Update suns
        function updateSuns(scrollMultiplier) {
            for (let i = gameState.suns.length - 1; i >= 0; i--) {
                const sun = gameState.suns[i];

                sun.position.y -= 0.015 * settings.scrollSpeed * (0.5 + scrollMultiplier);
                sun.rotation.z += 0.0005;

                if (sun.position.y < -orthoHeight - sun.size) {
                    sun.dispose();
                    gameState.suns.splice(i, 1);
                }
            }
        }

        // Convert world position to screen position
        function worldToScreen(worldX, worldY) {
            const screenX = ((worldX + orthoWidth) / (orthoWidth * 2)) * gameWidth;
            const screenY = ((orthoHeight - worldY) / (orthoHeight * 2)) * gameHeight;
            return { x: screenX, y: screenY };
        }

        // Update targeting overlay
        function updateTargetingOverlay(planet) {
            const overlay = document.getElementById('targetingOverlay');
            const corners = overlay.querySelectorAll('.targeting-corner');

            if (!planet) {
                corners.forEach(c => c.style.display = 'none');
                return;
            }

            const screenPos = worldToScreen(planet.position.x, planet.position.y);
            const screenSize = (planet.size / (orthoHeight * 2)) * gameHeight * 1.2;
            const halfSize = screenSize / 2;

            const positions = [
                { x: screenPos.x - halfSize - 10, y: screenPos.y - halfSize - 10 }, // top-left
                { x: screenPos.x + halfSize - 10, y: screenPos.y - halfSize - 10 }, // top-right
                { x: screenPos.x - halfSize - 10, y: screenPos.y + halfSize - 10 }, // bottom-left
                { x: screenPos.x + halfSize - 10, y: screenPos.y + halfSize - 10 }  // bottom-right
            ];

            corners.forEach((corner, i) => {
                corner.style.display = 'block';
                corner.style.left = positions[i].x + 'px';
                corner.style.top = positions[i].y + 'px';
            });
        }

        // Update planets
        function updatePlanets(scrollMultiplier, deltaTime) {
            if (!playerShip) return;

            let nearPlanet = null;
            let nearestDist = Infinity;

            for (let i = gameState.planets.length - 1; i >= 0; i--) {
                const planet = gameState.planets[i];

                // Move planet down
                planet.position.y -= 0.015 * settings.scrollSpeed * (0.5 + scrollMultiplier);

                // Update orbit center if planet is orbiting
                if (planet.orbitCenterX !== undefined) {
                    // Find matching sun and update orbit center
                    planet.orbitAngle += planet.orbitSpeed * deltaTime;
                    // The orbit center also moves down with the solar system
                }

                // Slow rotation
                planet.rotation.z += 0.001;

                // Check distance to player
                const dx = planet.position.x - playerShip.position.x;
                const dy = planet.position.y - playerShip.position.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < planet.harvestRadius && planet.harvestsRemaining > 0) {
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearPlanet = planet;
                    }
                }

                // Remove if off screen
                if (planet.position.y < -orthoHeight - planet.size) {
                    planet.dispose();
                    gameState.planets.splice(i, 1);
                }
            }

            // Handle harvesting UI
            const harvestBar = document.getElementById('harvestBar');
            const harvestBarFill = document.getElementById('harvestBarFill');

            if (nearPlanet && nearPlanet.harvestsRemaining > 0) {
                if (gameState.harvestingPlanet !== nearPlanet) {
                    gameState.harvestingPlanet = nearPlanet;
                    gameState.harvestProgress = 0;
                }

                gameState.harvestProgress += deltaTime / 2000; // 2 seconds to harvest

                harvestBar.style.display = 'block';
                harvestBarFill.style.width = `${Math.min(100, gameState.harvestProgress * 100)}%`;

                // Show targeting corners
                updateTargetingOverlay(nearPlanet);

                if (gameState.harvestProgress >= 1) {
                    // Harvest complete!
                    nearPlanet.harvestsRemaining--;
                    gameState.harvestProgress = 0;

                    // Give resources
                    const resources = nearPlanet.planetData.resources;
                    Object.keys(resources).forEach(resName => {
                        const [min, max] = resources[resName];
                        const amount = Math.floor(Math.random() * (max - min + 1)) + min;
                        gameState.resources[resName] += amount;
                        gameState.score += amount * 2;
                        showResourceCollection(resName, amount);
                    });

                    updateHUD();

                    createExplosion(nearPlanet.position.x, nearPlanet.position.y, 'large', 'green');

                    // Flash the planet
                    if (nearPlanet.material) {
                        const origEmissive = nearPlanet.material.emissiveColor.clone();
                        nearPlanet.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
                        setTimeout(() => {
                            if (nearPlanet.material) nearPlanet.material.emissiveColor = origEmissive;
                        }, 200);
                    }

                    if (nearPlanet.harvestsRemaining <= 0) {
                        // Planet depleted - fade it
                        if (nearPlanet.material) {
                            nearPlanet.material.alpha = 0.5;
                            nearPlanet.material.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                        }
                    }
                }
            } else {
                gameState.harvestingPlanet = null;
                gameState.harvestProgress = 0;
                harvestBar.style.display = 'none';
                updateTargetingOverlay(null);
            }
        }

        // Load a ship model for gameplay
        async function loadShipModel(shipName, colorVariant, targetScene, faceDirection = 'up') {
            const basePath = `assets/Ultimate Spaceships/${shipName}/`;

            try {
                const result = await BABYLON.SceneLoader.ImportMeshAsync('', basePath + 'glTF/', `${shipName}.gltf`, targetScene);
                const rootMesh = result.meshes[0];

                const texturePath = `${basePath}Textures/${shipName}_${colorVariant}.png`;
                const texture = new BABYLON.Texture(texturePath, targetScene);

                result.meshes.forEach(mesh => {
                    if (mesh.material) mesh.material.dispose();
                    const mat = new BABYLON.StandardMaterial(`${shipName}${colorVariant}Mat`, targetScene);
                    mat.diffuseTexture = texture;
                    mat.emissiveTexture = texture;
                    mat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                    mesh.material = mat;
                });

                const boundingInfo = rootMesh.getHierarchyBoundingVectors(true);
                const size = boundingInfo.max.subtract(boundingInfo.min);
                const maxDim = Math.max(size.x, size.y, size.z);
                const gameScale = 1.5 / maxDim;
                rootMesh.scaling = new BABYLON.Vector3(gameScale, gameScale, gameScale);

                if (faceDirection === 'up') {
                    rootMesh.rotationQuaternion = null;
                    rootMesh.rotation.set(-Math.PI / 2, 0, 0);
                } else {
                    rootMesh.rotationQuaternion = null;
                    rootMesh.rotation.set(Math.PI / 2, 0, 0);
                }

                return rootMesh;
            } catch (e) {
                console.error(`Failed to load ship ${shipName}:`, e);
                const placeholder = BABYLON.MeshBuilder.CreateBox('placeholder', {width: 0.8, height: 1.2, depth: 0.3}, targetScene);
                const mat = new BABYLON.StandardMaterial('placeholderMat', targetScene);
                mat.diffuseColor = colorVariant === 'Blue' ? new BABYLON.Color3(0.2, 0.4, 1) : new BABYLON.Color3(1, 0.2, 0.2);
                mat.emissiveColor = mat.diffuseColor.scale(0.3);
                placeholder.material = mat;
                return placeholder;
            }
        }

        // Create player ship
        async function createPlayerShip() {
            playerShip = new BABYLON.TransformNode('playerShip', scene);

            playerShipMesh = await loadShipModel(settings.playerShip, settings.playerColor, scene, 'up');
            playerShipMesh.parent = playerShip;

            playerShip.position = new BABYLON.Vector3(0, -7, 0);
            playerShip.targetX = 0;
            playerShip.targetY = -7;
            playerShip.velocityX = 0;
            playerShip.currentTilt = 0;

            return playerShip;
        }

        // Create stars
        function createStars(count = 150) {
            updateGameDimensions();

            for (let i = 0; i < count; i++) {
                const size = Math.random() * 0.08 + 0.02;
                const star = BABYLON.MeshBuilder.CreateSphere('star' + i, { diameter: size }, scene);

                star.position.x = (Math.random() - 0.5) * orthoWidth * 2.5;
                star.position.y = (Math.random() - 0.5) * orthoHeight * 2.5;
                star.position.z = 1 + Math.random() * 2;

                const starMat = new BABYLON.StandardMaterial('starMat' + i, scene);
                const brightness = Math.random() * 0.5 + 0.5;
                starMat.emissiveColor = new BABYLON.Color3(brightness, brightness, brightness * 0.9);
                star.material = starMat;

                star.speed = (Math.random() * 0.3 + 0.1) * (0.5 + size * 5);
                gameState.stars.push(star);
            }
        }

        // Create enemy
        async function createEnemy(type = 'basic', x, y) {
            const enemy = new BABYLON.TransformNode('enemy', scene);

            const enemyMesh = await loadShipModel(settings.enemyShip, settings.enemyColor, scene, 'down');
            enemyMesh.parent = enemy;

            enemy.position.x = x;
            enemy.position.y = y;
            enemy.position.z = 0;
            enemy.type = type;
            enemy.health = type === 'shooter' ? 5 : type === 'fast' ? 2 : 3;
            enemy.speed = type === 'fast' ? 0.08 : 0.03;
            enemy.lastFireTime = 0;
            enemy.fireRate = type === 'shooter' ? 1500 : 3000;
            enemy.movementPattern = Math.random() > 0.5 ? 'sine' : 'straight';
            enemy.startX = x;
            enemy.time = Math.random() * Math.PI * 2;
            enemy.mesh = enemyMesh;
            enemy.prevX = x;
            enemy.currentTilt = 0;

            return enemy;
        }

        // Create bullet
        function createBullet(isPlayer, x, y, velocityX = 0, velocityY = 0.2) {
            let bullet;

            if (isPlayer) {
                bullet = BABYLON.MeshBuilder.CreateSphere('bullet', { diameter: 0.15 }, scene);
                bullet.material = materials.playerBullet;
            } else {
                bullet = BABYLON.MeshBuilder.CreateCapsule('bullet', { height: 0.5, radius: 0.1 }, scene);
                bullet.rotation.z = Math.atan2(velocityX, -velocityY);

                const enemyBulletMat = new BABYLON.StandardMaterial('enemyBulletMat', scene);
                enemyBulletMat.emissiveColor = new BABYLON.Color3(1, 0.3, 0.8);
                enemyBulletMat.diffuseColor = new BABYLON.Color3(1, 0.5, 1);
                enemyBulletMat.alpha = 0.9;
                bullet.material = enemyBulletMat;

                const core = BABYLON.MeshBuilder.CreateSphere('bulletCore', { diameter: 0.15 }, scene);
                core.parent = bullet;
                core.position.y = 0;
                const coreMat = new BABYLON.StandardMaterial('coreMat', scene);
                coreMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
                coreMat.disableLighting = true;
                core.material = coreMat;
            }

            bullet.position.x = x;
            bullet.position.y = y;
            bullet.position.z = -0.1;
            bullet.velocityX = velocityX;
            bullet.velocityY = velocityY;
            bullet.isPlayer = isPlayer;

            return bullet;
        }

        // Input handling
        let inputState = {
            isPressed: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0
        };

        function handleInputStart(x, y) {
            inputState.isPressed = true;
            inputState.startX = x;
            inputState.startY = y;
            inputState.currentX = x;
            inputState.currentY = y;
        }

        function handleInputMove(x, y) {
            if (inputState.isPressed) {
                inputState.currentX = x;
                inputState.currentY = y;
            }
        }

        function handleInputEnd() {
            inputState.isPressed = false;
        }

        document.addEventListener('touchstart', (e) => {
            if (gameState.isPlaying && !gameState.isPaused && e.touches.length > 0) {
                e.preventDefault();
                const touch = e.touches[0];
                handleInputStart(touch.clientX, touch.clientY);
            }
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            if (gameState.isPlaying && !gameState.isPaused && e.touches.length > 0) {
                e.preventDefault();
                const touch = e.touches[0];
                handleInputMove(touch.clientX, touch.clientY);
            }
        }, { passive: false });

        document.addEventListener('touchend', (e) => {
            handleInputEnd();
        }, { passive: false });

        document.addEventListener('mousedown', (e) => {
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
            if (gameState.isPlaying && !gameState.isPaused) {
                e.preventDefault();
                handleInputStart(e.clientX, e.clientY);
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (inputState.isPressed && gameState.isPlaying && !gameState.isPaused) {
                handleInputMove(e.clientX, e.clientY);
            }
        });

        document.addEventListener('mouseup', (e) => {
            handleInputEnd();
        });

        document.addEventListener('mouseleave', (e) => {
            handleInputEnd();
        });

        // Update player position
        function updatePlayerPosition(deltaTime) {
            if (!playerShip) return 0.3;

            if (inputState.isPressed) {
                const deltaX = (inputState.currentX - inputState.startX) * settings.xSensitivity;
                const deltaY = (inputState.currentY - inputState.startY) * settings.ySensitivity;

                inputState.startX = inputState.currentX;
                inputState.startY = inputState.currentY;

                const worldDeltaX = (deltaX / gameWidth) * orthoWidth * 2;
                const worldDeltaY = -(deltaY / gameHeight) * orthoHeight * 2;

                playerShip.targetX += worldDeltaX;
                playerShip.targetY += worldDeltaY;
            }

            const maxX = orthoWidth - 1;
            playerShip.targetX = Math.max(-maxX, Math.min(maxX, playerShip.targetX));

            const minY = -orthoHeight + 1;
            const maxY = -orthoHeight + (orthoHeight * 2 * settings.maxHeight);
            playerShip.targetY = Math.max(minY, Math.min(maxY, playerShip.targetY));

            const lerpFactor = 0.15 * settings.shipSpeed;
            const prevX = playerShip.position.x;
            playerShip.position.x += (playerShip.targetX - playerShip.position.x) * lerpFactor;
            playerShip.position.y += (playerShip.targetY - playerShip.position.y) * lerpFactor;

            playerShip.velocityX = playerShip.position.x - prevX;

            const targetTilt = -playerShip.velocityX * 8;
            const maxTilt = Math.PI / 6;
            const clampedTilt = Math.max(-maxTilt, Math.min(maxTilt, targetTilt));

            playerShip.currentTilt += (clampedTilt - playerShip.currentTilt) * 0.15;

            if (playerShipMesh) {
                playerShipMesh.rotation.y = playerShip.currentTilt;
            }

            const normalizedY = (playerShip.position.y + orthoHeight) / (orthoHeight * 2);
            return Math.max(0.1, normalizedY + 0.2);
        }

        // Fire weapons
        function firePlayerWeapons(currentTime) {
            if (!playerShip) return;

            const fireInterval = 300 / settings.fireRate;

            if (currentTime - gameState.lastFireTime > fireInterval && gameState.enemies.length > 0) {
                const bullet = createBullet(true, playerShip.position.x, playerShip.position.y + 0.5, 0, 0.35);
                gameState.playerBullets.push(bullet);

                gameState.lastFireTime = currentTime;
            }
        }

        // Spawn wave
        function spawnWave() {
            const waveConfig = {
                1: { count: 5 },
                2: { count: 7 },
                3: { count: 8 },
                4: { count: 10 },
                5: { count: 12 }
            };

            const config = waveConfig[Math.min(gameState.wave, 5)] || waveConfig[5];
            gameState.enemiesInWave = config.count + Math.floor(Math.max(0, gameState.wave - 5) * 2);
            gameState.enemiesSpawned = 0;
        }

        // Spawn enemy
        async function spawnEnemy() {
            if (gameState.enemiesSpawned >= gameState.enemiesInWave) return;

            const types = ['basic', 'basic', 'fast', 'shooter'];
            const type = types[Math.floor(Math.random() * Math.min(types.length, 1 + gameState.wave))];

            const maxX = orthoWidth - 1;
            const x = (Math.random() - 0.5) * maxX * 1.5;
            const y = orthoHeight + 2;

            const enemy = await createEnemy(type, x, y);
            gameState.enemies.push(enemy);
            gameState.enemiesSpawned++;
        }

        // Update enemies
        function updateEnemies(deltaTime, currentTime, scrollMultiplier) {
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];

                enemy.time += deltaTime * 0.003;

                const prevX = enemy.position.x;

                if (enemy.movementPattern === 'sine') {
                    enemy.position.x = enemy.startX + Math.sin(enemy.time) * 2;
                }

                enemy.position.y -= enemy.speed * settings.scrollSpeed * (0.5 + scrollMultiplier);

                const velocityX = enemy.position.x - prevX;
                const targetTilt = -velocityX * 8;
                const maxTilt = Math.PI / 6;
                const clampedTilt = Math.max(-maxTilt, Math.min(maxTilt, targetTilt));
                enemy.currentTilt += (clampedTilt - enemy.currentTilt) * 0.15;

                if (enemy.mesh) {
                    enemy.mesh.rotation.y = enemy.currentTilt;
                }

                if ((enemy.type === 'shooter' || enemy.type === 'basic') &&
                    currentTime - enemy.lastFireTime > enemy.fireRate && playerShip) {

                    const dx = playerShip.position.x - enemy.position.x;
                    const dy = playerShip.position.y - enemy.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 0) {
                        const bullet = createBullet(false, enemy.position.x, enemy.position.y - 0.3,
                            (dx / dist) * 0.1, (dy / dist) * 0.1);
                        gameState.enemyBullets.push(bullet);
                    }

                    enemy.lastFireTime = currentTime;
                }

                if (enemy.position.y < -orthoHeight - 2) {
                    // Enemy escaped - damage base shields
                    gameState.escapedEnemies++;
                    gameState.baseShields -= 10;
                    updateHUD();

                    // Show warning flash
                    const shieldsBar = document.getElementById('shieldsBarFill');
                    shieldsBar.style.background = '#ff4444';
                    setTimeout(() => {
                        shieldsBar.style.background = 'linear-gradient(90deg, #44aaff, #88ddff)';
                    }, 200);

                    if (gameState.baseShields <= 0) {
                        gameOver();
                    }

                    enemy.getChildMeshes().forEach(m => m.dispose());
                    enemy.dispose();
                    gameState.enemies.splice(i, 1);
                }
            }
        }

        // Update bullets
        function updateBullets() {
            for (let i = gameState.playerBullets.length - 1; i >= 0; i--) {
                const bullet = gameState.playerBullets[i];
                bullet.position.x += bullet.velocityX;
                bullet.position.y += bullet.velocityY;

                let bulletHit = false;
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    const dx = bullet.position.x - enemy.position.x;
                    const dy = bullet.position.y - enemy.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 0.5) {
                        enemy.health--;

                        createExplosion(bullet.position.x, bullet.position.y, 'small', 'yellow');

                        bullet.dispose();
                        gameState.playerBullets.splice(i, 1);
                        bulletHit = true;

                        if (enemy.health <= 0) {
                            createExplosion(enemy.position.x, enemy.position.y, 'large', 'orange');
                            createLoot(enemy.position.x, enemy.position.y, enemy.type);

                            const points = enemy.type === 'shooter' ? 30 : enemy.type === 'fast' ? 20 : 10;
                            gameState.score += points * gameState.wave;
                            updateHUD();

                            enemy.getChildMeshes().forEach(m => m.dispose());
                            enemy.dispose();
                            gameState.enemies.splice(j, 1);
                        } else {
                            flashShip(enemy.mesh);
                        }
                        break;
                    }
                }

                if (!bulletHit && bullet.position.y > orthoHeight + 2) {
                    bullet.dispose();
                    gameState.playerBullets.splice(i, 1);
                }
            }

            for (let i = gameState.enemyBullets.length - 1; i >= 0; i--) {
                const bullet = gameState.enemyBullets[i];
                bullet.position.x += bullet.velocityX;
                bullet.position.y += bullet.velocityY;

                if (playerShip) {
                    const dx = bullet.position.x - playerShip.position.x;
                    const dy = bullet.position.y - playerShip.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 0.5) {
                        createExplosion(bullet.position.x, bullet.position.y, 'small', 'orange');
                        flashShip(playerShipMesh);

                        gameState.health -= 10;
                        updateHUD();
                        bullet.dispose();
                        gameState.enemyBullets.splice(i, 1);

                        if (gameState.health <= 0) {
                            createExplosion(playerShip.position.x, playerShip.position.y, 'large', 'blue');
                            gameOver();
                        }
                        continue;
                    }
                }

                if (bullet.position.y < -orthoHeight - 2 || bullet.position.y > orthoHeight + 2 ||
                    bullet.position.x < -orthoWidth - 2 || bullet.position.x > orthoWidth + 2) {
                    bullet.dispose();
                    gameState.enemyBullets.splice(i, 1);
                }
            }
        }

        // Update stars
        function updateStars(scrollMultiplier) {
            const baseSpeed = 0.05 * settings.scrollSpeed;
            const adjustedSpeed = baseSpeed * (0.5 + scrollMultiplier);

            gameState.stars.forEach(star => {
                star.position.y -= star.speed * adjustedSpeed;

                if (star.position.y < -orthoHeight - 5) {
                    star.position.y = orthoHeight + 5;
                    star.position.x = (Math.random() - 0.5) * orthoWidth * 2.5;
                }
            });
        }

        // Check collisions
        function checkPlayerCollision() {
            if (!playerShip) return;

            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                const dx = playerShip.position.x - enemy.position.x;
                const dy = playerShip.position.y - enemy.position.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 0.7) {
                    const midX = (playerShip.position.x + enemy.position.x) / 2;
                    const midY = (playerShip.position.y + enemy.position.y) / 2;
                    createExplosion(midX, midY, 'large', 'orange');

                    createLoot(enemy.position.x, enemy.position.y, enemy.type);

                    flashShip(playerShipMesh);

                    gameState.health -= 25;
                    updateHUD();

                    enemy.getChildMeshes().forEach(m => m.dispose());
                    enemy.dispose();
                    gameState.enemies.splice(i, 1);

                    if (gameState.health <= 0) {
                        createExplosion(playerShip.position.x, playerShip.position.y, 'large', 'blue');
                        gameOver();
                    }
                }
            }
        }

        // Update HUD
        function updateHUD() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('health').textContent = Math.max(0, gameState.health);
            document.getElementById('wave').textContent = gameState.wave;

            // Update base shields
            const shieldsPercent = Math.max(0, gameState.baseShields);
            document.getElementById('shieldsBarFill').style.width = `${shieldsPercent}%`;
            document.getElementById('shieldsValue').textContent = Math.max(0, gameState.baseShields);

            // Update resources display - show as icons at top
            const resourcesHud = document.getElementById('resourcesHud');
            let html = '';
            const displayResources = ['Iron', 'Copper', 'Titanium', 'Silicon', 'Water', 'Hydrogen', 'Carbon', 'Gold'];
            displayResources.forEach(res => {
                const amount = gameState.resources[res] || 0;
                if (amount > 0) {
                    const info = RESOURCES[res];
                    html += `<div class="resource-icon">
                        <div class="symbol" style="background: ${info.color}">${info.symbol}</div>
                        <span class="count">${amount}</span>
                    </div>`;
                }
            });
            resourcesHud.innerHTML = html;
        }

        // Game over
        function gameOver() {
            gameState.isPlaying = false;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('harvestBar').style.display = 'none';
            document.getElementById('harvestLabel').style.display = 'none';
        }

        // Reset game
        async function resetGame() {
            gameState.enemies.forEach(enemy => {
                enemy.getChildMeshes().forEach(m => m.dispose());
                enemy.dispose();
            });
            gameState.enemies = [];

            gameState.playerBullets.forEach(b => b.dispose());
            gameState.playerBullets = [];
            gameState.enemyBullets.forEach(b => b.dispose());
            gameState.enemyBullets = [];

            gameState.loot.forEach(l => {
                l.getChildMeshes().forEach(m => m.dispose());
                l.dispose();
            });
            gameState.loot = [];

            gameState.planets.forEach(p => p.dispose());
            gameState.planets = [];

            gameState.suns.forEach(s => s.dispose());
            gameState.suns = [];

            gameState.score = 0;
            gameState.health = 100;
            gameState.wave = 1;
            gameState.lastFireTime = 0;
            gameState.waveTimer = 0;
            gameState.enemiesInWave = 0;
            gameState.enemiesSpawned = 0;
            gameState.nextSolarSystemY = orthoHeight + 15;
            gameState.harvestingPlanet = null;
            gameState.harvestProgress = 0;
            gameState.baseShields = 100;
            gameState.escapedEnemies = 0;
            gameState.pendingNotifications = {};

            initResources();

            if (playerShip) {
                playerShip.position.x = 0;
                playerShip.position.y = -7;
                playerShip.targetX = 0;
                playerShip.targetY = -7;
            }

            updateHUD();
            spawnWave();
        }

        // Settings UI
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsPanel = document.getElementById('settingsPanel');
        const closeSettings = document.getElementById('closeSettings');

        settingsBtn.addEventListener('click', () => {
            settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
            gameState.isPaused = settingsPanel.style.display === 'block';
        });

        closeSettings.addEventListener('click', () => {
            settingsPanel.style.display = 'none';
            gameState.isPaused = false;
        });

        function setupSlider(id, settingKey, suffix = '', multiplier = 1) {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(id + 'Value');

            slider.addEventListener('input', () => {
                const value = parseFloat(slider.value);
                settings[settingKey] = value * multiplier;
                valueDisplay.textContent = value + suffix;
            });
        }

        setupSlider('xSensitivity', 'xSensitivity');
        setupSlider('ySensitivity', 'ySensitivity');
        setupSlider('maxHeight', 'maxHeight', '%', 0.01);
        setupSlider('shipSpeed', 'shipSpeed', 'x');
        setupSlider('fireRate', 'fireRate', 'x');
        setupSlider('scrollSpeed', 'scrollSpeed', 'x');

        // Start game
        const startScreen = document.getElementById('startScreen');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const gameOverPanel = document.getElementById('gameOver');

        startBtn.addEventListener('click', async () => {
            previewScenes.forEach(p => {
                p.engine.stopRenderLoop();
                p.scene.dispose();
                p.engine.dispose();
            });

            startScreen.style.display = 'none';
            document.getElementById('settingsBtn').style.display = 'flex';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('shieldsDisplay').style.display = 'flex';
            document.getElementById('resourcesHud').style.display = 'flex';

            createMainScene();
            await createPlayerShip();
            createStars();
            initResources();
            spawnWave();

            // Initialize solar system spawning
            gameState.nextSolarSystemY = orthoHeight + 15;
            gameState.baseShields = 100;

            gameState.isPlaying = true;

            let lastTime = performance.now();
            let spawnTimer = 0;

            scene.registerBeforeRender(() => {
                if (!gameState.isPlaying || gameState.isPaused) return;

                const currentTime = performance.now();
                const deltaTime = Math.min(currentTime - lastTime, 50);
                lastTime = currentTime;

                const scrollMultiplier = updatePlayerPosition(deltaTime);
                updateStars(scrollMultiplier);
                firePlayerWeapons(currentTime);

                spawnTimer += deltaTime;
                if (spawnTimer > 800 && gameState.enemiesSpawned < gameState.enemiesInWave) {
                    spawnEnemy();
                    spawnTimer = 0;
                }

                // Spawn solar systems with spacing
                // Check if we need to spawn a new solar system
                // nextSolarSystemY tracks when the next system should appear at the top
                gameState.nextSolarSystemY -= 0.015 * settings.scrollSpeed * (0.5 + scrollMultiplier);
                if (gameState.nextSolarSystemY < orthoHeight + 10) {
                    createSolarSystem();
                }

                // Update suns
                updateSuns(scrollMultiplier);

                if (gameState.enemiesSpawned >= gameState.enemiesInWave && gameState.enemies.length === 0) {
                    gameState.wave++;
                    updateHUD();
                    spawnWave();
                }

                updateEnemies(deltaTime, currentTime, scrollMultiplier);
                updateBullets();
                updateLoot(scrollMultiplier);
                updatePlanets(scrollMultiplier, deltaTime);
                checkPlayerCollision();
            });

            engine.runRenderLoop(() => {
                scene.render();
            });
        });

        restartBtn.addEventListener('click', () => {
            gameOverPanel.style.display = 'none';
            gameState.isPlaying = true;
            resetGame();
        });

        window.addEventListener('resize', () => {
            engine.resize();
            updateGameDimensions();
        });

        createModelPreviews();
    </script>
</body>
</html>
